// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`JSON and date handling options > generates schemas with coerceDates enabled > coerce-dates/constants.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export const TABLE_USERS = 'users';
"
`;

exports[`JSON and date handling options > generates schemas with coerceDates enabled > coerce-dates/tables/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './users';
"
`;

exports[`JSON and date handling options > generates schemas with coerceDates enabled > coerce-dates/tables/users/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema';
"
`;

exports[`JSON and date handling options > generates schemas with coerceDates enabled > coerce-dates/tables/users/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const USER_ROLES = ['admin', 'editor', 'viewer'] as const;

/**
 * The base read schema for the "public.users" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const UsersTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('users_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.coerce.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.coerce.date()).nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents the raw database record without any transformations.
 */
export type UserReadBaseRecord = z.output<typeof UsersTableReadSchema>;

/**
* The read transform function for the "public.users" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformUserReadRecord = (data: UserReadBaseRecord): {
    id: UserReadBaseRecord['id'],
    name: UserReadBaseRecord['name'],
    email?: UserReadBaseRecord['email'],
    status?: UserReadBaseRecord['status'],
    profile?: UserReadBaseRecord['profile'],
    createdAt?: UserReadBaseRecord['created_at'],
    roles?: UserReadBaseRecord['roles'],
    dates?: UserReadBaseRecord['dates'],
} => ({
    id: data.id,
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    createdAt: data.created_at,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The read schema for the "public.users" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const UsersTableSchema = UsersTableReadSchema.transform(transformUserReadRecord);

/**
 * The base write schema for the "public.users" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const UsersTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().max(255).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().max(20).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: z.any().nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish().optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type UserInsertBaseRecord = z.output<typeof UsersTableWriteSchema>;

/**
 * The base record type for the "public.users" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type UserUpdateBaseRecord = Partial<UserInsertBaseRecord>;

/**
 * The insert transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserInsertRecord = (data: UserInsertBaseRecord): {
    name: UserInsertBaseRecord['name'],
    email?: UserInsertBaseRecord['email'],
    status?: UserInsertBaseRecord['status'],
    profile?: UserInsertBaseRecord['profile'],
    created_at?: UserInsertBaseRecord['createdAt'],
    roles?: UserInsertBaseRecord['roles'],
    dates?: UserInsertBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The update transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserUpdateRecord = (data: UserUpdateBaseRecord): {
    name: UserUpdateBaseRecord['name'],
    email?: UserUpdateBaseRecord['email'],
    status?: UserUpdateBaseRecord['status'],
    profile?: UserUpdateBaseRecord['profile'],
    created_at?: UserUpdateBaseRecord['createdAt'],
    roles?: UserUpdateBaseRecord['roles'],
    dates?: UserUpdateBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The insert schema for the "public.users" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const UsersTableInsertSchema = UsersTableWriteSchema.transform(transformUserInsertRecord);

/**
 * The update schema for the "public.users" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const UsersTableUpdateSchema = UsersTableWriteSchema.partial().transform(transformUserUpdateRecord);

type TableInsertRecord = z.input<typeof UsersTableInsertSchema>;
type TableReadRecord = z.output<typeof UsersTableSchema>;
export type UserRole = (typeof USER_ROLES)[number];

/**
* Represents a database record from the "public.users" table.
*/
export interface UserRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    name: TableReadRecord['name'];
    /**
    */
    email?: TableReadRecord['email'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    */
    profile?: TableReadRecord['profile'];
    /**
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    */
    roles?: TableReadRecord['roles'];
    /**
    */
    dates?: TableReadRecord['dates'];
}

/**
* Represents an insertable database record from the "public.users" table.
*/
export interface UserInsertRecord {
    /**
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * @maxLen: 255
    */
    email?: TableInsertRecord['email'];
    /**
    * @maxLen: 20
    * @default: 'active'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    */
    profile?: TableInsertRecord['profile'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    */
    roles?: TableInsertRecord['roles'];
    /**
    */
    dates?: TableInsertRecord['dates'];
}

/**
* Represents an updateable database record from the "public.users" table.
*/
export type UserUpdateRecord = Partial<UserInsertRecord>;
"
`;

exports[`JSON and date handling options > generates schemas with coerceDates enabled > coerce-dates/types.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export type Table = 
    | 'users'
"
`;

exports[`JSON and date handling options > generates schemas with defaultEmptyArray enabled > default-empty-array/constants.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export const TABLE_USERS = 'users';
"
`;

exports[`JSON and date handling options > generates schemas with defaultEmptyArray enabled > default-empty-array/tables/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './users';
"
`;

exports[`JSON and date handling options > generates schemas with defaultEmptyArray enabled > default-empty-array/tables/users/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema';
"
`;

exports[`JSON and date handling options > generates schemas with defaultEmptyArray enabled > default-empty-array/tables/users/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const USER_ROLES = ['admin', 'editor', 'viewer'] as const;

/**
 * The base read schema for the "public.users" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const UsersTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('users_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().transform((value) => value ?? []).optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish().transform((value) => value ?? []).optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents the raw database record without any transformations.
 */
export type UserReadBaseRecord = z.output<typeof UsersTableReadSchema>;

/**
* The read transform function for the "public.users" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformUserReadRecord = (data: UserReadBaseRecord): {
    id: UserReadBaseRecord['id'],
    name: UserReadBaseRecord['name'],
    email?: UserReadBaseRecord['email'],
    status?: UserReadBaseRecord['status'],
    profile?: UserReadBaseRecord['profile'],
    createdAt?: UserReadBaseRecord['created_at'],
    roles?: UserReadBaseRecord['roles'],
    dates?: UserReadBaseRecord['dates'],
} => ({
    id: data.id,
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    createdAt: data.created_at,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The read schema for the "public.users" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const UsersTableSchema = UsersTableReadSchema.transform(transformUserReadRecord);

/**
 * The base write schema for the "public.users" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const UsersTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().max(255).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().max(20).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: z.any().nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish().optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type UserInsertBaseRecord = z.output<typeof UsersTableWriteSchema>;

/**
 * The base record type for the "public.users" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type UserUpdateBaseRecord = Partial<UserInsertBaseRecord>;

/**
 * The insert transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserInsertRecord = (data: UserInsertBaseRecord): {
    name: UserInsertBaseRecord['name'],
    email?: UserInsertBaseRecord['email'],
    status?: UserInsertBaseRecord['status'],
    profile?: UserInsertBaseRecord['profile'],
    created_at?: UserInsertBaseRecord['createdAt'],
    roles?: UserInsertBaseRecord['roles'],
    dates?: UserInsertBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The update transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserUpdateRecord = (data: UserUpdateBaseRecord): {
    name: UserUpdateBaseRecord['name'],
    email?: UserUpdateBaseRecord['email'],
    status?: UserUpdateBaseRecord['status'],
    profile?: UserUpdateBaseRecord['profile'],
    created_at?: UserUpdateBaseRecord['createdAt'],
    roles?: UserUpdateBaseRecord['roles'],
    dates?: UserUpdateBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The insert schema for the "public.users" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const UsersTableInsertSchema = UsersTableWriteSchema.transform(transformUserInsertRecord);

/**
 * The update schema for the "public.users" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const UsersTableUpdateSchema = UsersTableWriteSchema.partial().transform(transformUserUpdateRecord);

type TableInsertRecord = z.input<typeof UsersTableInsertSchema>;
type TableReadRecord = z.output<typeof UsersTableSchema>;
export type UserRole = (typeof USER_ROLES)[number];

/**
* Represents a database record from the "public.users" table.
*/
export interface UserRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    name: TableReadRecord['name'];
    /**
    */
    email?: TableReadRecord['email'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    */
    profile?: TableReadRecord['profile'];
    /**
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    */
    roles?: TableReadRecord['roles'];
    /**
    */
    dates?: TableReadRecord['dates'];
}

/**
* Represents an insertable database record from the "public.users" table.
*/
export interface UserInsertRecord {
    /**
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * @maxLen: 255
    */
    email?: TableInsertRecord['email'];
    /**
    * @maxLen: 20
    * @default: 'active'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    */
    profile?: TableInsertRecord['profile'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    */
    roles?: TableInsertRecord['roles'];
    /**
    */
    dates?: TableInsertRecord['dates'];
}

/**
* Represents an updateable database record from the "public.users" table.
*/
export type UserUpdateRecord = Partial<UserInsertRecord>;
"
`;

exports[`JSON and date handling options > generates schemas with defaultEmptyArray enabled > default-empty-array/types.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export type Table = 
    | 'users'
"
`;

exports[`JSON and date handling options > generates schemas with stringifyDates enabled > stringify-dates/constants.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export const TABLE_USERS = 'users';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyDates enabled > stringify-dates/tables/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './users';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyDates enabled > stringify-dates/tables/users/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyDates enabled > stringify-dates/tables/users/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const USER_ROLES = ['admin', 'editor', 'viewer'] as const;

/**
 * The base read schema for the "public.users" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const UsersTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('users_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents the raw database record without any transformations.
 */
export type UserReadBaseRecord = z.output<typeof UsersTableReadSchema>;

/**
* The read transform function for the "public.users" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformUserReadRecord = (data: UserReadBaseRecord): {
    id: UserReadBaseRecord['id'],
    name: UserReadBaseRecord['name'],
    email?: UserReadBaseRecord['email'],
    status?: UserReadBaseRecord['status'],
    profile?: UserReadBaseRecord['profile'],
    createdAt?: UserReadBaseRecord['created_at'],
    roles?: UserReadBaseRecord['roles'],
    dates?: UserReadBaseRecord['dates'],
} => ({
    id: data.id,
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    createdAt: data.created_at,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The read schema for the "public.users" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const UsersTableSchema = UsersTableReadSchema.transform(transformUserReadRecord);

/**
 * The base write schema for the "public.users" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const UsersTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().max(255).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().max(20).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: z.any().nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().transform((value) => value ? value.toISOString() : value).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish().transform((value) => value ? value.map(date => date.toISOString()) : value).optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type UserInsertBaseRecord = z.output<typeof UsersTableWriteSchema>;

/**
 * The base record type for the "public.users" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type UserUpdateBaseRecord = Partial<UserInsertBaseRecord>;

/**
 * The insert transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserInsertRecord = (data: UserInsertBaseRecord): {
    name: UserInsertBaseRecord['name'],
    email?: UserInsertBaseRecord['email'],
    status?: UserInsertBaseRecord['status'],
    profile?: UserInsertBaseRecord['profile'],
    created_at?: UserInsertBaseRecord['createdAt'],
    roles?: UserInsertBaseRecord['roles'],
    dates?: UserInsertBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The update transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserUpdateRecord = (data: UserUpdateBaseRecord): {
    name: UserUpdateBaseRecord['name'],
    email?: UserUpdateBaseRecord['email'],
    status?: UserUpdateBaseRecord['status'],
    profile?: UserUpdateBaseRecord['profile'],
    created_at?: UserUpdateBaseRecord['createdAt'],
    roles?: UserUpdateBaseRecord['roles'],
    dates?: UserUpdateBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The insert schema for the "public.users" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const UsersTableInsertSchema = UsersTableWriteSchema.transform(transformUserInsertRecord);

/**
 * The update schema for the "public.users" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const UsersTableUpdateSchema = UsersTableWriteSchema.partial().transform(transformUserUpdateRecord);

type TableInsertRecord = z.input<typeof UsersTableInsertSchema>;
type TableReadRecord = z.output<typeof UsersTableSchema>;
export type UserRole = (typeof USER_ROLES)[number];

/**
* Represents a database record from the "public.users" table.
*/
export interface UserRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    name: TableReadRecord['name'];
    /**
    */
    email?: TableReadRecord['email'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    */
    profile?: TableReadRecord['profile'];
    /**
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    */
    roles?: TableReadRecord['roles'];
    /**
    */
    dates?: TableReadRecord['dates'];
}

/**
* Represents an insertable database record from the "public.users" table.
*/
export interface UserInsertRecord {
    /**
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * @maxLen: 255
    */
    email?: TableInsertRecord['email'];
    /**
    * @maxLen: 20
    * @default: 'active'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    */
    profile?: TableInsertRecord['profile'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    */
    roles?: TableInsertRecord['roles'];
    /**
    */
    dates?: TableInsertRecord['dates'];
}

/**
* Represents an updateable database record from the "public.users" table.
*/
export type UserUpdateRecord = Partial<UserInsertRecord>;
"
`;

exports[`JSON and date handling options > generates schemas with stringifyDates enabled > stringify-dates/types.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export type Table = 
    | 'users'
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson disabled > no-stringify-json/constants.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export const TABLE_POSTS = 'posts';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson disabled > no-stringify-json/tables/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './posts';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson disabled > no-stringify-json/tables/posts/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson disabled > no-stringify-json/tables/posts/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const POST_STATUSES = ['draft', 'published', 'archived'] as const;

/**
 * The base read schema for the "public.posts" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const PostsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('posts_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    published_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents the raw database record without any transformations.
 */
export type PostReadBaseRecord = z.output<typeof PostsTableReadSchema>;

/**
* The read transform function for the "public.posts" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformPostReadRecord = (data: PostReadBaseRecord): {
    id: PostReadBaseRecord['id'],
    userId?: PostReadBaseRecord['user_id'],
    title: PostReadBaseRecord['title'],
    content?: PostReadBaseRecord['content'],
    published?: PostReadBaseRecord['published'],
    status?: PostReadBaseRecord['status'],
    views?: PostReadBaseRecord['views'],
    tags?: PostReadBaseRecord['tags'],
    metadata?: PostReadBaseRecord['metadata'],
    publishedAt?: PostReadBaseRecord['published_at'],
    updatedAt?: PostReadBaseRecord['updated_at'],
} => ({
    id: data.id,
    userId: data.user_id,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    publishedAt: data.published_at,
    updatedAt: data.updated_at,
});

/**
 * The read schema for the "public.posts" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const PostsTableSchema = PostsTableReadSchema.transform(transformPostReadRecord);

/**
 * The base write schema for the "public.posts" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const PostsTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.number().int().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.any().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    publishedAt: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type PostInsertBaseRecord = z.output<typeof PostsTableWriteSchema>;

/**
 * The base record type for the "public.posts" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type PostUpdateBaseRecord = Partial<PostInsertBaseRecord>;

/**
 * The insert transform function for the "public.posts" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostInsertRecord = (data: PostInsertBaseRecord): {
    user_id?: PostInsertBaseRecord['userId'],
    title: PostInsertBaseRecord['title'],
    content?: PostInsertBaseRecord['content'],
    published?: PostInsertBaseRecord['published'],
    status?: PostInsertBaseRecord['status'],
    views?: PostInsertBaseRecord['views'],
    tags?: PostInsertBaseRecord['tags'],
    metadata?: PostInsertBaseRecord['metadata'],
    published_at?: PostInsertBaseRecord['publishedAt'],
    updated_at?: PostInsertBaseRecord['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.posts" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostUpdateRecord = (data: PostUpdateBaseRecord): {
    user_id?: PostUpdateBaseRecord['userId'],
    title: PostUpdateBaseRecord['title'],
    content?: PostUpdateBaseRecord['content'],
    published?: PostUpdateBaseRecord['published'],
    status?: PostUpdateBaseRecord['status'],
    views?: PostUpdateBaseRecord['views'],
    tags?: PostUpdateBaseRecord['tags'],
    metadata?: PostUpdateBaseRecord['metadata'],
    published_at?: PostUpdateBaseRecord['publishedAt'],
    updated_at?: PostUpdateBaseRecord['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.posts" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const PostsTableInsertSchema = PostsTableWriteSchema.transform(transformPostInsertRecord);

/**
 * The update schema for the "public.posts" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const PostsTableUpdateSchema = PostsTableWriteSchema.partial().transform(transformPostUpdateRecord);

type TableInsertRecord = z.input<typeof PostsTableInsertSchema>;
type TableReadRecord = z.output<typeof PostsTableSchema>;
export type PostStatus = (typeof POST_STATUSES)[number];

/**
* Represents a database record from the "public.posts" table.
*/
export interface PostRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    title: TableReadRecord['title'];
    /**
    */
    content?: TableReadRecord['content'];
    /**
    */
    published?: TableReadRecord['published'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    * Number of views for the post
    */
    views?: TableReadRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableReadRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableReadRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.posts" table.
*/
export interface PostInsertRecord {
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    */
    title: TableInsertRecord['title'];
    /**
    */
    content?: TableInsertRecord['content'];
    /**
    * @default: false
    */
    published?: TableInsertRecord['published'];
    /**
    * @maxLen: 20
    * @default: 'draft'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    * Number of views for the post
    * @default: 0
    */
    views?: TableInsertRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableInsertRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.posts" table.
*/
export type PostUpdateRecord = Partial<PostInsertRecord>;
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson disabled > no-stringify-json/types.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export type Table = 
    | 'posts'
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson enabled > stringify-json/constants.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export const TABLE_POSTS = 'posts';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson enabled > stringify-json/tables/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './posts';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson enabled > stringify-json/tables/posts/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema';
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson enabled > stringify-json/tables/posts/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const POST_STATUSES = ['draft', 'published', 'archived'] as const;

/**
 * The base read schema for the "public.posts" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const PostsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('posts_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    published_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents the raw database record without any transformations.
 */
export type PostReadBaseRecord = z.output<typeof PostsTableReadSchema>;

/**
* The read transform function for the "public.posts" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformPostReadRecord = (data: PostReadBaseRecord): {
    id: PostReadBaseRecord['id'],
    userId?: PostReadBaseRecord['user_id'],
    title: PostReadBaseRecord['title'],
    content?: PostReadBaseRecord['content'],
    published?: PostReadBaseRecord['published'],
    status?: PostReadBaseRecord['status'],
    views?: PostReadBaseRecord['views'],
    tags?: PostReadBaseRecord['tags'],
    metadata?: PostReadBaseRecord['metadata'],
    publishedAt?: PostReadBaseRecord['published_at'],
    updatedAt?: PostReadBaseRecord['updated_at'],
} => ({
    id: data.id,
    userId: data.user_id,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    publishedAt: data.published_at,
    updatedAt: data.updated_at,
});

/**
 * The read schema for the "public.posts" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const PostsTableSchema = PostsTableReadSchema.transform(transformPostReadRecord);

/**
 * The base write schema for the "public.posts" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const PostsTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.number().int().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.any().nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    publishedAt: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type PostInsertBaseRecord = z.output<typeof PostsTableWriteSchema>;

/**
 * The base record type for the "public.posts" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type PostUpdateBaseRecord = Partial<PostInsertBaseRecord>;

/**
 * The insert transform function for the "public.posts" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostInsertRecord = (data: PostInsertBaseRecord): {
    user_id?: PostInsertBaseRecord['userId'],
    title: PostInsertBaseRecord['title'],
    content?: PostInsertBaseRecord['content'],
    published?: PostInsertBaseRecord['published'],
    status?: PostInsertBaseRecord['status'],
    views?: PostInsertBaseRecord['views'],
    tags?: PostInsertBaseRecord['tags'],
    metadata?: PostInsertBaseRecord['metadata'],
    published_at?: PostInsertBaseRecord['publishedAt'],
    updated_at?: PostInsertBaseRecord['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.posts" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostUpdateRecord = (data: PostUpdateBaseRecord): {
    user_id?: PostUpdateBaseRecord['userId'],
    title: PostUpdateBaseRecord['title'],
    content?: PostUpdateBaseRecord['content'],
    published?: PostUpdateBaseRecord['published'],
    status?: PostUpdateBaseRecord['status'],
    views?: PostUpdateBaseRecord['views'],
    tags?: PostUpdateBaseRecord['tags'],
    metadata?: PostUpdateBaseRecord['metadata'],
    published_at?: PostUpdateBaseRecord['publishedAt'],
    updated_at?: PostUpdateBaseRecord['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.posts" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const PostsTableInsertSchema = PostsTableWriteSchema.transform(transformPostInsertRecord);

/**
 * The update schema for the "public.posts" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const PostsTableUpdateSchema = PostsTableWriteSchema.partial().transform(transformPostUpdateRecord);

type TableInsertRecord = z.input<typeof PostsTableInsertSchema>;
type TableReadRecord = z.output<typeof PostsTableSchema>;
export type PostStatus = (typeof POST_STATUSES)[number];

/**
* Represents a database record from the "public.posts" table.
*/
export interface PostRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    title: TableReadRecord['title'];
    /**
    */
    content?: TableReadRecord['content'];
    /**
    */
    published?: TableReadRecord['published'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    * Number of views for the post
    */
    views?: TableReadRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableReadRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableReadRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.posts" table.
*/
export interface PostInsertRecord {
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    */
    title: TableInsertRecord['title'];
    /**
    */
    content?: TableInsertRecord['content'];
    /**
    * @default: false
    */
    published?: TableInsertRecord['published'];
    /**
    * @maxLen: 20
    * @default: 'draft'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    * Number of views for the post
    * @default: 0
    */
    views?: TableInsertRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableInsertRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.posts" table.
*/
export type PostUpdateRecord = Partial<PostInsertRecord>;
"
`;

exports[`JSON and date handling options > generates schemas with stringifyJson enabled > stringify-json/types.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export type Table = 
    | 'posts'
"
`;
