// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > constants.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export const MV_USER_POSTS = 'mv_user_posts';
export const TABLE_AUDIT_LOGS = 'audit_logs';
export const TABLE_CATEGORIES = 'categories';
export const TABLE_COMMENTS = 'comments';
export const TABLE_CONSTRAINT_VARIATIONS = 'constraint_variations';
export const TABLE_ENUM_TESTS = 'enum_tests';
export const TABLE_FILES = 'files';
export const TABLE_GEOGRAPHIC_DATA = 'geographic_data';
export const TABLE_INVENTORY = 'inventory';
export const TABLE_NETWORK_LOGS = 'network_logs';
export const TABLE_ORDER_ITEMS = 'order_items';
export const TABLE_ORDERS = 'orders';
export const TABLE_POST_CATEGORIES = 'post_categories';
export const TABLE_POSTS = 'posts';
export const TABLE_PRODUCTS = 'products';
export const TABLE_TIME_SERIES = 'time_series';
export const TABLE_USER_SESSIONS = 'user_sessions';
export const TABLE_USERS = 'users';
export const VIEW_USER_POSTS = 'view_user_posts';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > materialized_views/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './mv_user_posts/index.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > materialized_views/mv_user_posts/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > materialized_views/mv_user_posts/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.mv_user_posts" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const MvUserPostsReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    user_name: z.string().nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.number().int().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_title: z.string().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_content: z.string().nullable().optional(),
});

/**
 * The base record type for the "public.mv_user_posts" table.
 * This type represents the raw database record without any transformations.
 */
export type MvUserPostReadRecord = z.output<typeof MvUserPostsReadSchema>;

/**
* The read transform function for the "public.mv_user_posts" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformMvUserPostReadRecord = (data: MvUserPostReadRecord): {
    userId?: MvUserPostReadRecord['user_id'],
    userName?: MvUserPostReadRecord['user_name'],
    postId?: MvUserPostReadRecord['post_id'],
    postTitle?: MvUserPostReadRecord['post_title'],
    postContent?: MvUserPostReadRecord['post_content'],
} => ({
    userId: data.user_id ?? undefined,
    userName: data.user_name ?? undefined,
    postId: data.post_id ?? undefined,
    postTitle: data.post_title ?? undefined,
    postContent: data.post_content ?? undefined,
});

/**
 * The read schema for the "public.mv_user_posts" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const MvUserPostsSchema = MvUserPostsReadSchema.transform(transformMvUserPostReadRecord);

type TableReadRecord = z.output<typeof MvUserPostsSchema>;

/**
* Represents a database record from the "public.mv_user_posts" materialized_view.
*/
export interface MvUserPostRecord {
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    userName?: TableReadRecord['userName'];
    /**
    */
    postId?: TableReadRecord['postId'];
    /**
    */
    postTitle?: TableReadRecord['postTitle'];
    /**
    */
    postContent?: TableReadRecord['postContent'];
}
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/audit_logs/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/audit_logs/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { AuditLogOldValuesSchema, AuditLogNewValuesSchema } from '../../json.js';


/**
 * The base read schema for the "public.audit_logs" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const AuditLogsTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('audit_logs_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    action: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    table_name: z.string().nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    record_id: z.number().int().nullable().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    old_values: AuditLogOldValuesSchema.nullable().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    new_values: AuditLogNewValuesSchema.nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents the raw database record without any transformations.
 */
export type AuditLogReadRecord = z.output<typeof AuditLogsTableReadSchema>;

/**
* The read transform function for the "public.audit_logs" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformAuditLogReadRecord = (data: AuditLogReadRecord): {
    id: AuditLogReadRecord['id'],
    userId?: AuditLogReadRecord['user_id'],
    action: AuditLogReadRecord['action'],
    tableName?: AuditLogReadRecord['table_name'],
    recordId?: AuditLogReadRecord['record_id'],
    oldValues?: AuditLogReadRecord['old_values'],
    newValues?: AuditLogReadRecord['new_values'],
    createdAt?: AuditLogReadRecord['created_at'],
} => ({
    id: data.id,
    userId: data.user_id ?? undefined,
    action: data.action,
    tableName: data.table_name ?? undefined,
    recordId: data.record_id ?? undefined,
    oldValues: data.old_values ?? undefined,
    newValues: data.new_values ?? undefined,
    createdAt: data.created_at ?? undefined,
});

/**
 * The read schema for the "public.audit_logs" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const AuditLogsTableSchema = AuditLogsTableReadSchema.transform(transformAuditLogReadRecord);

/**
 * The base write schema for the "public.audit_logs" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const AuditLogsTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    action: z.string().max(50),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    tableName: z.string().max(50).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    recordId: z.number().int().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    oldValues: AuditLogOldValuesSchema.nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    newValues: AuditLogNewValuesSchema.nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof AuditLogsTableWriteSchema>;

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.audit_logs" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformAuditLogInsertRecord = (data: ): {
    user_id?: ['userId'],
    action: ['action'],
    table_name?: ['tableName'],
    record_id?: ['recordId'],
    old_values?: ['oldValues'],
    new_values?: ['newValues'],
    created_at?: ['createdAt'],
} => ({
    user_id: data.userId,
    action: data.action,
    table_name: data.tableName,
    record_id: data.recordId,
    old_values: (data.oldValues ? JSON.stringify(data.oldValues) : data.oldValues),
    new_values: (data.newValues ? JSON.stringify(data.newValues) : data.newValues),
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.audit_logs" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformAuditLogUpdateRecord = (data: ): {
    user_id?: ['userId'],
    action: ['action'],
    table_name?: ['tableName'],
    record_id?: ['recordId'],
    old_values?: ['oldValues'],
    new_values?: ['newValues'],
    created_at?: ['createdAt'],
} => ({
    user_id: data.userId,
    action: data.action,
    table_name: data.tableName,
    record_id: data.recordId,
    old_values: (data.oldValues ? JSON.stringify(data.oldValues) : data.oldValues),
    new_values: (data.newValues ? JSON.stringify(data.newValues) : data.newValues),
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.audit_logs" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const AuditLogsTableInsertSchema = AuditLogsTableWriteSchema.transform(transformAuditLogInsertRecord);

/**
 * The update schema for the "public.audit_logs" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const AuditLogsTableUpdateSchema = AuditLogsTableWriteSchema.partial().transform(transformAuditLogUpdateRecord);

type TableInsertRecord = z.input<typeof AuditLogsTableInsertSchema>;
type TableReadRecord = z.output<typeof AuditLogsTableSchema>;

/**
* Represents a database record from the "public.audit_logs" table.
*/
export interface AuditLogRecord {
    /**
    * Primary key for audit logs table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the user who performed the action
    */
    userId?: TableReadRecord['userId'];
    /**
    * Type of action performed
    */
    action: TableReadRecord['action'];
    /**
    * Name of the table affected
    */
    tableName?: TableReadRecord['tableName'];
    /**
    * ID of the record affected
    */
    recordId?: TableReadRecord['recordId'];
    /**
    * Previous values before the change
    */
    oldValues?: TableReadRecord['oldValues'];
    /**
    * New values after the change
    */
    newValues?: TableReadRecord['newValues'];
    /**
    * Timestamp when the action was performed
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.audit_logs" table.
*/
export interface AuditLogInsertRecord {
    /**
    * ID of the user who performed the action
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Type of action performed
    * @maxLen: 50
    */
    action: TableInsertRecord['action'];
    /**
    * Name of the table affected
    * @maxLen: 50
    */
    tableName?: TableInsertRecord['tableName'];
    /**
    * ID of the record affected
    */
    recordId?: TableInsertRecord['recordId'];
    /**
    * Previous values before the change
    */
    oldValues?: TableInsertRecord['oldValues'];
    /**
    * New values after the change
    */
    newValues?: TableInsertRecord['newValues'];
    /**
    * Timestamp when the action was performed
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.audit_logs" table.
*/
export type AuditLogUpdateRecord = Partial<AuditLogInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/categories/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/categories/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.categories" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const CategoriesTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('categories_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.string().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.categories" table.
 * This type represents the raw database record without any transformations.
 */
export type CategoryReadRecord = z.output<typeof CategoriesTableReadSchema>;

/**
* The read transform function for the "public.categories" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformCategoryReadRecord = (data: CategoryReadRecord): {
    id: CategoryReadRecord['id'],
    name: CategoryReadRecord['name'],
    description?: CategoryReadRecord['description'],
    color?: CategoryReadRecord['color'],
    createdAt?: CategoryReadRecord['created_at'],
} => ({
    id: data.id,
    name: data.name,
    description: data.description ?? undefined,
    color: data.color ?? undefined,
    createdAt: data.created_at ?? undefined,
});

/**
 * The read schema for the "public.categories" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const CategoriesTableSchema = CategoriesTableReadSchema.transform(transformCategoryReadRecord);

/**
 * The base write schema for the "public.categories" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const CategoriesTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.string().max(7).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.categories" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof CategoriesTableWriteSchema>;

/**
 * The base record type for the "public.categories" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.categories" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformCategoryInsertRecord = (data: ): {
    name: ['name'],
    description?: ['description'],
    color?: ['color'],
    created_at?: ['createdAt'],
} => ({
    name: data.name,
    description: data.description,
    color: data.color,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.categories" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformCategoryUpdateRecord = (data: ): {
    name: ['name'],
    description?: ['description'],
    color?: ['color'],
    created_at?: ['createdAt'],
} => ({
    name: data.name,
    description: data.description,
    color: data.color,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.categories" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const CategoriesTableInsertSchema = CategoriesTableWriteSchema.transform(transformCategoryInsertRecord);

/**
 * The update schema for the "public.categories" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const CategoriesTableUpdateSchema = CategoriesTableWriteSchema.partial().transform(transformCategoryUpdateRecord);

type TableInsertRecord = z.input<typeof CategoriesTableInsertSchema>;
type TableReadRecord = z.output<typeof CategoriesTableSchema>;

/**
* Represents a database record from the "public.categories" table.
*/
export interface CategoryRecord {
    /**
    * Primary key for categories table
    */
    id: TableReadRecord['id'];
    /**
    * Name of the category
    */
    name: TableReadRecord['name'];
    /**
    * Description of the category
    */
    description?: TableReadRecord['description'];
    /**
    * Hex color code for the category
    */
    color?: TableReadRecord['color'];
    /**
    * Timestamp when the category was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.categories" table.
*/
export interface CategoryInsertRecord {
    /**
    * Name of the category
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * Description of the category
    */
    description?: TableInsertRecord['description'];
    /**
    * Hex color code for the category
    * @maxLen: 7
    */
    color?: TableInsertRecord['color'];
    /**
    * Timestamp when the category was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.categories" table.
*/
export type CategoryUpdateRecord = Partial<CategoryInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/comments/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/comments/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.comments" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const CommentsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('comments_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.number().int().nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    parent_id: z.number().int().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    is_approved: z.boolean().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.comments" table.
 * This type represents the raw database record without any transformations.
 */
export type CommentReadRecord = z.output<typeof CommentsTableReadSchema>;

/**
* The read transform function for the "public.comments" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformCommentReadRecord = (data: CommentReadRecord): {
    id: CommentReadRecord['id'],
    postId?: CommentReadRecord['post_id'],
    userId?: CommentReadRecord['user_id'],
    parentId?: CommentReadRecord['parent_id'],
    content: CommentReadRecord['content'],
    isApproved?: CommentReadRecord['is_approved'],
    createdAt?: CommentReadRecord['created_at'],
    updatedAt?: CommentReadRecord['updated_at'],
} => ({
    id: data.id,
    postId: data.post_id ?? undefined,
    userId: data.user_id ?? undefined,
    parentId: data.parent_id ?? undefined,
    content: data.content,
    isApproved: data.is_approved ?? undefined,
    createdAt: data.created_at ?? undefined,
    updatedAt: data.updated_at ?? undefined,
});

/**
 * The read schema for the "public.comments" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const CommentsTableSchema = CommentsTableReadSchema.transform(transformCommentReadRecord);

/**
 * The base write schema for the "public.comments" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const CommentsTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    postId: z.number().int().nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    parentId: z.number().int().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    isApproved: z.boolean().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.comments" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof CommentsTableWriteSchema>;

/**
 * The base record type for the "public.comments" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.comments" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformCommentInsertRecord = (data: ): {
    post_id?: ['postId'],
    user_id?: ['userId'],
    parent_id?: ['parentId'],
    content: ['content'],
    is_approved?: ['isApproved'],
    created_at?: ['createdAt'],
    updated_at?: ['updatedAt'],
} => ({
    post_id: data.postId,
    user_id: data.userId,
    parent_id: data.parentId,
    content: data.content,
    is_approved: data.isApproved,
    created_at: data.createdAt,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.comments" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformCommentUpdateRecord = (data: ): {
    post_id?: ['postId'],
    user_id?: ['userId'],
    parent_id?: ['parentId'],
    content: ['content'],
    is_approved?: ['isApproved'],
    created_at?: ['createdAt'],
    updated_at?: ['updatedAt'],
} => ({
    post_id: data.postId,
    user_id: data.userId,
    parent_id: data.parentId,
    content: data.content,
    is_approved: data.isApproved,
    created_at: data.createdAt,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.comments" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const CommentsTableInsertSchema = CommentsTableWriteSchema.transform(transformCommentInsertRecord);

/**
 * The update schema for the "public.comments" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const CommentsTableUpdateSchema = CommentsTableWriteSchema.partial().transform(transformCommentUpdateRecord);

type TableInsertRecord = z.input<typeof CommentsTableInsertSchema>;
type TableReadRecord = z.output<typeof CommentsTableSchema>;

/**
* Represents a database record from the "public.comments" table.
*/
export interface CommentRecord {
    /**
    * Primary key for comments table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the post this comment belongs to
    */
    postId?: TableReadRecord['postId'];
    /**
    * ID of the user who wrote the comment
    */
    userId?: TableReadRecord['userId'];
    /**
    * ID of the parent comment for nested comments
    */
    parentId?: TableReadRecord['parentId'];
    /**
    * Content of the comment
    */
    content: TableReadRecord['content'];
    /**
    * Whether the comment has been approved by moderators
    */
    isApproved?: TableReadRecord['isApproved'];
    /**
    * Timestamp when the comment was created
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    * Timestamp when the comment was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.comments" table.
*/
export interface CommentInsertRecord {
    /**
    * ID of the post this comment belongs to
    */
    postId?: TableInsertRecord['postId'];
    /**
    * ID of the user who wrote the comment
    */
    userId?: TableInsertRecord['userId'];
    /**
    * ID of the parent comment for nested comments
    */
    parentId?: TableInsertRecord['parentId'];
    /**
    * Content of the comment
    */
    content: TableInsertRecord['content'];
    /**
    * Whether the comment has been approved by moderators
    * @default: false
    */
    isApproved?: TableInsertRecord['isApproved'];
    /**
    * Timestamp when the comment was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    * Timestamp when the comment was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.comments" table.
*/
export type CommentUpdateRecord = Partial<CommentInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/constraint_variations/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/constraint_variations/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const CONSTRAINT_VARIATION_ANIMALS = ['cat', 'dog', 'bird', 'fish'] as const;
export const CONSTRAINT_VARIATION_FRUITS = ['apple', 'banana', 'orange', 'grape'] as const;
export const CONSTRAINT_VARIATION_VEHICLES = ['car', 'truck', 'motorcycle', 'bicycle'] as const;
export const CONSTRAINT_VARIATION_LANGUAGES = ['en', 'es', 'fr', 'de', 'it'] as const;
export const CONSTRAINT_VARIATION_ACTIVE_STATUSES = ['true', 'false'] as const;

/**
 * The base read schema for the "public.constraint_variations" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const ConstraintVariationsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('constraint_variations_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    animal: z.enum(CONSTRAINT_VARIATION_ANIMALS).nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    fruit: z.enum(CONSTRAINT_VARIATION_FRUITS).nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    vehicle: z.enum(CONSTRAINT_VARIATION_VEHICLES).nullable().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    language: z.enum(CONSTRAINT_VARIATION_LANGUAGES).nullable().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    rating: z.number().int().nullable().optional(),
    /**
    * dataType: bool
    * defaultValue: 
    */
    active_status: z.enum(CONSTRAINT_VARIATION_ACTIVE_STATUSES).nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents the raw database record without any transformations.
 */
export type ConstraintVariationReadRecord = z.output<typeof ConstraintVariationsTableReadSchema>;

/**
* The read transform function for the "public.constraint_variations" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformConstraintVariationReadRecord = (data: ConstraintVariationReadRecord): {
    id: ConstraintVariationReadRecord['id'],
    animal?: ConstraintVariationReadRecord['animal'],
    fruit?: ConstraintVariationReadRecord['fruit'],
    vehicle?: ConstraintVariationReadRecord['vehicle'],
    language?: ConstraintVariationReadRecord['language'],
    rating?: ConstraintVariationReadRecord['rating'],
    activeStatus?: ConstraintVariationReadRecord['active_status'],
    createdAt?: ConstraintVariationReadRecord['created_at'],
} => ({
    id: data.id,
    animal: data.animal ?? undefined,
    fruit: data.fruit ?? undefined,
    vehicle: data.vehicle ?? undefined,
    language: data.language ?? undefined,
    rating: data.rating ?? undefined,
    activeStatus: data.active_status ?? undefined,
    createdAt: data.created_at ?? undefined,
});

/**
 * The read schema for the "public.constraint_variations" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const ConstraintVariationsTableSchema = ConstraintVariationsTableReadSchema.transform(transformConstraintVariationReadRecord);

/**
 * The base write schema for the "public.constraint_variations" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const ConstraintVariationsTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    animal: z.enum(CONSTRAINT_VARIATION_ANIMALS).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    fruit: z.enum(CONSTRAINT_VARIATION_FRUITS).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    vehicle: z.enum(CONSTRAINT_VARIATION_VEHICLES).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    language: z.enum(CONSTRAINT_VARIATION_LANGUAGES).nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    rating: z.number().int().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: 
    */
    activeStatus: z.enum(CONSTRAINT_VARIATION_ACTIVE_STATUSES).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof ConstraintVariationsTableWriteSchema>;

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.constraint_variations" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformConstraintVariationInsertRecord = (data: ): {
    animal?: ['animal'],
    fruit?: ['fruit'],
    vehicle?: ['vehicle'],
    language?: ['language'],
    rating?: ['rating'],
    active_status?: ['activeStatus'],
    created_at?: ['createdAt'],
} => ({
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    active_status: data.activeStatus,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.constraint_variations" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformConstraintVariationUpdateRecord = (data: ): {
    animal?: ['animal'],
    fruit?: ['fruit'],
    vehicle?: ['vehicle'],
    language?: ['language'],
    rating?: ['rating'],
    active_status?: ['activeStatus'],
    created_at?: ['createdAt'],
} => ({
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    active_status: data.activeStatus,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.constraint_variations" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const ConstraintVariationsTableInsertSchema = ConstraintVariationsTableWriteSchema.transform(transformConstraintVariationInsertRecord);

/**
 * The update schema for the "public.constraint_variations" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const ConstraintVariationsTableUpdateSchema = ConstraintVariationsTableWriteSchema.partial().transform(transformConstraintVariationUpdateRecord);

type TableInsertRecord = z.input<typeof ConstraintVariationsTableInsertSchema>;
type TableReadRecord = z.output<typeof ConstraintVariationsTableSchema>;
export type ConstraintVariationAnimal = (typeof CONSTRAINT_VARIATION_ANIMALS)[number];
export type ConstraintVariationFruit = (typeof CONSTRAINT_VARIATION_FRUITS)[number];
export type ConstraintVariationVehicle = (typeof CONSTRAINT_VARIATION_VEHICLES)[number];
export type ConstraintVariationLanguage = (typeof CONSTRAINT_VARIATION_LANGUAGES)[number];
export type ConstraintVariationActiveStatus = (typeof CONSTRAINT_VARIATION_ACTIVE_STATUSES)[number];

/**
* Represents a database record from the "public.constraint_variations" table.
*/
export interface ConstraintVariationRecord {
    /**
    * Primary key for constraint variations table
    */
    id: TableReadRecord['id'];
    /**
    * Type of animal
    */
    animal?: TableReadRecord['animal'];
    /**
    * Type of fruit
    */
    fruit?: TableReadRecord['fruit'];
    /**
    * Type of vehicle
    */
    vehicle?: TableReadRecord['vehicle'];
    /**
    * Language code
    */
    language?: TableReadRecord['language'];
    /**
    * Rating score (1-5)
    */
    rating?: TableReadRecord['rating'];
    /**
    * Whether the item is active
    */
    activeStatus?: TableReadRecord['activeStatus'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.constraint_variations" table.
*/
export interface ConstraintVariationInsertRecord {
    /**
    * Type of animal
    * @maxLen: 20
    */
    animal?: TableInsertRecord['animal'];
    /**
    * Type of fruit
    */
    fruit?: TableInsertRecord['fruit'];
    /**
    * Type of vehicle
    * @maxLen: 15
    */
    vehicle?: TableInsertRecord['vehicle'];
    /**
    * Language code
    * @maxLen: 2
    */
    language?: TableInsertRecord['language'];
    /**
    * Rating score (1-5)
    */
    rating?: TableInsertRecord['rating'];
    /**
    * Whether the item is active
    */
    activeStatus?: TableInsertRecord['activeStatus'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.constraint_variations" table.
*/
export type ConstraintVariationUpdateRecord = Partial<ConstraintVariationInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/enum_tests/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/enum_tests/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const ENUM_TEST_PRIORITIES = ['low', 'medium', 'high', 'critical'] as const;
export const ENUM_TEST_COLORS = ['red', 'green', 'blue', 'yellow'] as const;
export const ENUM_TEST_SIZES = ['xs', 's', 'm', 'l', 'xl', 'xxl'] as const;
export const ENUM_TEST_GRADES = ['A', 'B', 'C', 'D', 'F'] as const;
export const ENUM_TEST_CATEGORIES = ['electronics', 'clothing', 'books', 'home-garden'] as const;
export const ENUM_TEST_MOODS = ['happy', 'sad', 'angry', 'excited', 'calm'] as const;
export const ENUM_TEST_DIRECTIONS = ['north', 'south', 'east', 'west'] as const;
export const ENUM_TEST_WEATHER_CONDITIONS = ['sunny', 'cloudy', 'rainy', 'snowy', 'foggy'] as const;
export const ENUM_TEST_TASK_STATUSES = ['todo', 'in-progress', 'done', 'cancelled'] as const;
export const ENUM_TEST_DIFFICULTIES = ['1', '2', '3', '4', '5'] as const;
export const ENUM_TEST_WEEKDAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const;
export const ENUM_TEST_PAYMENT_METHODS = ['cash', 'credit-card', 'debit-card', 'paypal', 'bank-transfer'] as const;

/**
 * The base read schema for the "public.enum_tests" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const EnumTestsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('enum_tests_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    priority: z.enum(ENUM_TEST_PRIORITIES).nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.enum(ENUM_TEST_COLORS).nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    size: z.enum(ENUM_TEST_SIZES).nullable().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    grade: z.enum(ENUM_TEST_GRADES).nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    category: z.enum(ENUM_TEST_CATEGORIES).nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    mood: z.enum(ENUM_TEST_MOODS).nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    direction: z.enum(ENUM_TEST_DIRECTIONS).nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    weather_condition: z.enum(ENUM_TEST_WEATHER_CONDITIONS).nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    task_status: z.enum(ENUM_TEST_TASK_STATUSES).nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    difficulty: z.enum(ENUM_TEST_DIFFICULTIES).nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    weekday: z.enum(ENUM_TEST_WEEKDAYS).nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    payment_method: z.enum(ENUM_TEST_PAYMENT_METHODS).nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents the raw database record without any transformations.
 */
export type EnumTestReadRecord = z.output<typeof EnumTestsTableReadSchema>;

/**
* The read transform function for the "public.enum_tests" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformEnumTestReadRecord = (data: EnumTestReadRecord): {
    id: EnumTestReadRecord['id'],
    priority?: EnumTestReadRecord['priority'],
    color?: EnumTestReadRecord['color'],
    size?: EnumTestReadRecord['size'],
    grade?: EnumTestReadRecord['grade'],
    category?: EnumTestReadRecord['category'],
    mood?: EnumTestReadRecord['mood'],
    direction?: EnumTestReadRecord['direction'],
    weatherCondition?: EnumTestReadRecord['weather_condition'],
    taskStatus?: EnumTestReadRecord['task_status'],
    difficulty?: EnumTestReadRecord['difficulty'],
    weekday?: EnumTestReadRecord['weekday'],
    paymentMethod?: EnumTestReadRecord['payment_method'],
    createdAt?: EnumTestReadRecord['created_at'],
} => ({
    id: data.id,
    priority: data.priority ?? undefined,
    color: data.color ?? undefined,
    size: data.size ?? undefined,
    grade: data.grade ?? undefined,
    category: data.category ?? undefined,
    mood: data.mood ?? undefined,
    direction: data.direction ?? undefined,
    weatherCondition: data.weather_condition ?? undefined,
    taskStatus: data.task_status ?? undefined,
    difficulty: data.difficulty ?? undefined,
    weekday: data.weekday ?? undefined,
    paymentMethod: data.payment_method ?? undefined,
    createdAt: data.created_at ?? undefined,
});

/**
 * The read schema for the "public.enum_tests" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const EnumTestsTableSchema = EnumTestsTableReadSchema.transform(transformEnumTestReadRecord);

/**
 * The base write schema for the "public.enum_tests" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const EnumTestsTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    priority: z.enum(ENUM_TEST_PRIORITIES).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.enum(ENUM_TEST_COLORS).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    size: z.enum(ENUM_TEST_SIZES).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    grade: z.enum(ENUM_TEST_GRADES).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    category: z.enum(ENUM_TEST_CATEGORIES).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    mood: z.enum(ENUM_TEST_MOODS).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    direction: z.enum(ENUM_TEST_DIRECTIONS).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    weatherCondition: z.enum(ENUM_TEST_WEATHER_CONDITIONS).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    taskStatus: z.enum(ENUM_TEST_TASK_STATUSES).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    difficulty: z.enum(ENUM_TEST_DIFFICULTIES).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    weekday: z.enum(ENUM_TEST_WEEKDAYS).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    paymentMethod: z.enum(ENUM_TEST_PAYMENT_METHODS).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof EnumTestsTableWriteSchema>;

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.enum_tests" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformEnumTestInsertRecord = (data: ): {
    priority?: ['priority'],
    color?: ['color'],
    size?: ['size'],
    grade?: ['grade'],
    category?: ['category'],
    mood?: ['mood'],
    direction?: ['direction'],
    weather_condition?: ['weatherCondition'],
    task_status?: ['taskStatus'],
    difficulty?: ['difficulty'],
    weekday?: ['weekday'],
    payment_method?: ['paymentMethod'],
    created_at?: ['createdAt'],
} => ({
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weather_condition: data.weatherCondition,
    task_status: data.taskStatus,
    difficulty: data.difficulty,
    weekday: data.weekday,
    payment_method: data.paymentMethod,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.enum_tests" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformEnumTestUpdateRecord = (data: ): {
    priority?: ['priority'],
    color?: ['color'],
    size?: ['size'],
    grade?: ['grade'],
    category?: ['category'],
    mood?: ['mood'],
    direction?: ['direction'],
    weather_condition?: ['weatherCondition'],
    task_status?: ['taskStatus'],
    difficulty?: ['difficulty'],
    weekday?: ['weekday'],
    payment_method?: ['paymentMethod'],
    created_at?: ['createdAt'],
} => ({
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weather_condition: data.weatherCondition,
    task_status: data.taskStatus,
    difficulty: data.difficulty,
    weekday: data.weekday,
    payment_method: data.paymentMethod,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.enum_tests" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const EnumTestsTableInsertSchema = EnumTestsTableWriteSchema.transform(transformEnumTestInsertRecord);

/**
 * The update schema for the "public.enum_tests" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const EnumTestsTableUpdateSchema = EnumTestsTableWriteSchema.partial().transform(transformEnumTestUpdateRecord);

type TableInsertRecord = z.input<typeof EnumTestsTableInsertSchema>;
type TableReadRecord = z.output<typeof EnumTestsTableSchema>;
export type EnumTestPriority = (typeof ENUM_TEST_PRIORITIES)[number];
export type EnumTestColor = (typeof ENUM_TEST_COLORS)[number];
export type EnumTestSize = (typeof ENUM_TEST_SIZES)[number];
export type EnumTestGrade = (typeof ENUM_TEST_GRADES)[number];
export type EnumTestCategory = (typeof ENUM_TEST_CATEGORIES)[number];
export type EnumTestMood = (typeof ENUM_TEST_MOODS)[number];
export type EnumTestDirection = (typeof ENUM_TEST_DIRECTIONS)[number];
export type EnumTestWeatherCondition = (typeof ENUM_TEST_WEATHER_CONDITIONS)[number];
export type EnumTestTaskStatus = (typeof ENUM_TEST_TASK_STATUSES)[number];
export type EnumTestDifficulty = (typeof ENUM_TEST_DIFFICULTIES)[number];
export type EnumTestWeekday = (typeof ENUM_TEST_WEEKDAYS)[number];
export type EnumTestPaymentMethod = (typeof ENUM_TEST_PAYMENT_METHODS)[number];

/**
* Represents a database record from the "public.enum_tests" table.
*/
export interface EnumTestRecord {
    /**
    * Primary key for enum tests table
    */
    id: TableReadRecord['id'];
    /**
    * Task priority level
    */
    priority?: TableReadRecord['priority'];
    /**
    * Color selection
    */
    color?: TableReadRecord['color'];
    /**
    * Size option
    */
    size?: TableReadRecord['size'];
    /**
    * Letter grade
    */
    grade?: TableReadRecord['grade'];
    /**
    * Product category
    */
    category?: TableReadRecord['category'];
    /**
    * Current mood state
    */
    mood?: TableReadRecord['mood'];
    /**
    * Compass direction
    */
    direction?: TableReadRecord['direction'];
    /**
    * Current weather condition
    */
    weatherCondition?: TableReadRecord['weatherCondition'];
    /**
    * Status of the task
    */
    taskStatus?: TableReadRecord['taskStatus'];
    /**
    * Difficulty level (1-5)
    */
    difficulty?: TableReadRecord['difficulty'];
    /**
    * Day of the week
    */
    weekday?: TableReadRecord['weekday'];
    /**
    * Payment method used
    */
    paymentMethod?: TableReadRecord['paymentMethod'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.enum_tests" table.
*/
export interface EnumTestInsertRecord {
    /**
    * Task priority level
    * @maxLen: 10
    */
    priority?: TableInsertRecord['priority'];
    /**
    * Color selection
    * @maxLen: 20
    */
    color?: TableInsertRecord['color'];
    /**
    * Size option
    */
    size?: TableInsertRecord['size'];
    /**
    * Letter grade
    * @maxLen: 1
    */
    grade?: TableInsertRecord['grade'];
    /**
    * Product category
    * @maxLen: 30
    */
    category?: TableInsertRecord['category'];
    /**
    * Current mood state
    */
    mood?: TableInsertRecord['mood'];
    /**
    * Compass direction
    * @maxLen: 10
    */
    direction?: TableInsertRecord['direction'];
    /**
    * Current weather condition
    */
    weatherCondition?: TableInsertRecord['weatherCondition'];
    /**
    * Status of the task
    * @maxLen: 20
    */
    taskStatus?: TableInsertRecord['taskStatus'];
    /**
    * Difficulty level (1-5)
    */
    difficulty?: TableInsertRecord['difficulty'];
    /**
    * Day of the week
    * @maxLen: 10
    */
    weekday?: TableInsertRecord['weekday'];
    /**
    * Payment method used
    */
    paymentMethod?: TableInsertRecord['paymentMethod'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.enum_tests" table.
*/
export type EnumTestUpdateRecord = Partial<EnumTestInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/files/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/files/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { FileMetadataSchema } from '../../json.js';


/**
 * The base read schema for the "public.files" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const FilesTableReadSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    file_path: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    file_size: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mime_type: z.string().nullable().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().nullable().optional(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binary_data: z.string().nullable().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    is_encrypted: z.boolean().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    upload_time: z.date().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiry_date: z.date().nullable().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: FileMetadataSchema.nullable().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    access_count: z.number().int().nullable().optional(),
});

/**
 * The base record type for the "public.files" table.
 * This type represents the raw database record without any transformations.
 */
export type FileReadRecord = z.output<typeof FilesTableReadSchema>;

/**
* The read transform function for the "public.files" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformFileReadRecord = (data: FileReadRecord): {
    id: FileReadRecord['id'],
    filename: FileReadRecord['filename'],
    filePath: FileReadRecord['file_path'],
    fileSize: FileReadRecord['file_size'],
    mimeType?: FileReadRecord['mime_type'],
    checksum?: FileReadRecord['checksum'],
    binaryData?: FileReadRecord['binary_data'],
    isEncrypted?: FileReadRecord['is_encrypted'],
    uploadTime?: FileReadRecord['upload_time'],
    expiryDate?: FileReadRecord['expiry_date'],
    metadata?: FileReadRecord['metadata'],
    tags?: FileReadRecord['tags'],
    accessCount?: FileReadRecord['access_count'],
} => ({
    id: data.id,
    filename: data.filename,
    filePath: data.file_path,
    fileSize: data.file_size,
    mimeType: data.mime_type ?? undefined,
    checksum: data.checksum ?? undefined,
    binaryData: data.binary_data ?? undefined,
    isEncrypted: data.is_encrypted ?? undefined,
    uploadTime: data.upload_time ?? undefined,
    expiryDate: data.expiry_date ?? undefined,
    metadata: data.metadata ?? undefined,
    tags: data.tags ?? [],
    accessCount: data.access_count ?? undefined,
});

/**
 * The read schema for the "public.files" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const FilesTableSchema = FilesTableReadSchema.transform(transformFileReadRecord);

/**
 * The base write schema for the "public.files" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const FilesTableWriteSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string().max(255),
    /**
    * dataType: text
    * defaultValue: 
    */
    filePath: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    fileSize: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mimeType: z.string().max(100).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().max(64).nullish().optional(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binaryData: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    isEncrypted: z.boolean().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    uploadTime: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiryDate: z.date().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: FileMetadataSchema.nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    accessCount: z.number().int().nullish().optional(),
});

/**
 * The base record type for the "public.files" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof FilesTableWriteSchema>;

/**
 * The base record type for the "public.files" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.files" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformFileInsertRecord = (data: ): {
    id: ['id'],
    filename: ['filename'],
    file_path: ['filePath'],
    file_size: ['fileSize'],
    mime_type?: ['mimeType'],
    checksum?: ['checksum'],
    binary_data?: ['binaryData'],
    is_encrypted?: ['isEncrypted'],
    upload_time?: ['uploadTime'],
    expiry_date?: ['expiryDate'],
    metadata?: ['metadata'],
    tags?: ['tags'],
    access_count?: ['accessCount'],
} => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    tags: data.tags,
    access_count: data.accessCount,
});

/**
 * The update transform function for the "public.files" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformFileUpdateRecord = (data: ): {
    id: ['id'],
    filename: ['filename'],
    file_path: ['filePath'],
    file_size: ['fileSize'],
    mime_type?: ['mimeType'],
    checksum?: ['checksum'],
    binary_data?: ['binaryData'],
    is_encrypted?: ['isEncrypted'],
    upload_time?: ['uploadTime'],
    expiry_date?: ['expiryDate'],
    metadata?: ['metadata'],
    tags?: ['tags'],
    access_count?: ['accessCount'],
} => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    tags: data.tags,
    access_count: data.accessCount,
});

/**
 * The insert schema for the "public.files" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const FilesTableInsertSchema = FilesTableWriteSchema.transform(transformFileInsertRecord);

/**
 * The update schema for the "public.files" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const FilesTableUpdateSchema = FilesTableWriteSchema.partial().transform(transformFileUpdateRecord);

type TableInsertRecord = z.input<typeof FilesTableInsertSchema>;
type TableReadRecord = z.output<typeof FilesTableSchema>;

/**
* Represents a database record from the "public.files" table.
*/
export interface FileRecord {
    /**
    * Primary key for files table
    */
    id: TableReadRecord['id'];
    /**
    * Original filename
    */
    filename: TableReadRecord['filename'];
    /**
    * Path to the file
    */
    filePath: TableReadRecord['filePath'];
    /**
    * Size of the file in bytes
    */
    fileSize: TableReadRecord['fileSize'];
    /**
    * MIME type of the file
    */
    mimeType?: TableReadRecord['mimeType'];
    /**
    * SHA-256 checksum of the file
    */
    checksum?: TableReadRecord['checksum'];
    /**
    * Binary data of the file
    */
    binaryData?: TableReadRecord['binaryData'];
    /**
    * Whether the file is encrypted
    */
    isEncrypted?: TableReadRecord['isEncrypted'];
    /**
    * Timestamp when file was uploaded
    */
    uploadTime?: TableReadRecord['uploadTime'];
    /**
    * Expiry date of the file
    */
    expiryDate?: TableReadRecord['expiryDate'];
    /**
    * File metadata in JSON format
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Array of file tags
    */
    tags?: TableReadRecord['tags'];
    /**
    * Number of times file was accessed
    */
    accessCount?: TableReadRecord['accessCount'];
}

/**
* Represents an insertable database record from the "public.files" table.
*/
export interface FileInsertRecord {
    /**
    * Primary key for files table
    * @default: gen_random_uuid()
    */
    id: TableInsertRecord['id'];
    /**
    * Original filename
    * @maxLen: 255
    */
    filename: TableInsertRecord['filename'];
    /**
    * Path to the file
    */
    filePath: TableInsertRecord['filePath'];
    /**
    * Size of the file in bytes
    */
    fileSize: TableInsertRecord['fileSize'];
    /**
    * MIME type of the file
    * @maxLen: 100
    */
    mimeType?: TableInsertRecord['mimeType'];
    /**
    * SHA-256 checksum of the file
    * @maxLen: 64
    */
    checksum?: TableInsertRecord['checksum'];
    /**
    * Binary data of the file
    */
    binaryData?: TableInsertRecord['binaryData'];
    /**
    * Whether the file is encrypted
    * @default: false
    */
    isEncrypted?: TableInsertRecord['isEncrypted'];
    /**
    * Timestamp when file was uploaded
    * @default: now()
    */
    uploadTime?: TableInsertRecord['uploadTime'];
    /**
    * Expiry date of the file
    */
    expiryDate?: TableInsertRecord['expiryDate'];
    /**
    * File metadata in JSON format
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Array of file tags
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Number of times file was accessed
    * @default: 0
    */
    accessCount?: TableInsertRecord['accessCount'];
}

/**
* Represents an updateable database record from the "public.files" table.
*/
export type FileUpdateRecord = Partial<FileInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/geographic_data/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/geographic_data/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.geographic_data" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const GeographicDataTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('geographic_data_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    location_name: z.string(),
    /**
    * dataType: point
    * defaultValue: 
    */
    coordinates: z.string(),
    /**
    * dataType: polygon
    * defaultValue: 
    */
    boundary: z.string().nullable().optional(),
    /**
    * dataType: circle
    * defaultValue: 
    */
    area_circle: z.string().nullable().optional(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    elevation: z.number().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    timezone: z.string().nullable().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    country_code: z.string().nullable().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    postal_codes: z.array(z.string()).nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    population: z.number().int().nullable().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    established_date: z.date().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    last_updated: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents the raw database record without any transformations.
 */
export type GeographicDataReadRecord = z.output<typeof GeographicDataTableReadSchema>;

/**
* The read transform function for the "public.geographic_data" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformGeographicDataReadRecord = (data: GeographicDataReadRecord): {
    id: GeographicDataReadRecord['id'],
    locationName: GeographicDataReadRecord['location_name'],
    coordinates: GeographicDataReadRecord['coordinates'],
    boundary?: GeographicDataReadRecord['boundary'],
    areaCircle?: GeographicDataReadRecord['area_circle'],
    elevation?: GeographicDataReadRecord['elevation'],
    timezone?: GeographicDataReadRecord['timezone'],
    countryCode?: GeographicDataReadRecord['country_code'],
    postalCodes?: GeographicDataReadRecord['postal_codes'],
    population?: GeographicDataReadRecord['population'],
    establishedDate?: GeographicDataReadRecord['established_date'],
    lastUpdated?: GeographicDataReadRecord['last_updated'],
} => ({
    id: data.id,
    locationName: data.location_name,
    coordinates: data.coordinates,
    boundary: data.boundary ?? undefined,
    areaCircle: data.area_circle ?? undefined,
    elevation: data.elevation ?? undefined,
    timezone: data.timezone ?? undefined,
    countryCode: data.country_code ?? undefined,
    postalCodes: data.postal_codes ?? [],
    population: data.population ?? undefined,
    establishedDate: data.established_date ?? undefined,
    lastUpdated: data.last_updated ?? undefined,
});

/**
 * The read schema for the "public.geographic_data" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const GeographicDataTableSchema = GeographicDataTableReadSchema.transform(transformGeographicDataReadRecord);

/**
 * The base write schema for the "public.geographic_data" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const GeographicDataTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    locationName: z.string().max(255),
    /**
    * dataType: point
    * defaultValue: 
    */
    coordinates: z.string(),
    /**
    * dataType: polygon
    * defaultValue: 
    */
    boundary: z.string().nullish().optional(),
    /**
    * dataType: circle
    * defaultValue: 
    */
    areaCircle: z.string().nullish().optional(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    elevation: z.number().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    timezone: z.string().max(50).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    countryCode: z.string().max(2).nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    postalCodes: z.array(z.string()).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    population: z.number().int().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    establishedDate: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    lastUpdated: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof GeographicDataTableWriteSchema>;

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.geographic_data" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformGeographicDataInsertRecord = (data: ): {
    location_name: ['locationName'],
    coordinates: ['coordinates'],
    boundary?: ['boundary'],
    area_circle?: ['areaCircle'],
    elevation?: ['elevation'],
    timezone?: ['timezone'],
    country_code?: ['countryCode'],
    postal_codes?: ['postalCodes'],
    population?: ['population'],
    established_date?: ['establishedDate'],
    last_updated?: ['lastUpdated'],
} => ({
    location_name: data.locationName,
    coordinates: data.coordinates,
    boundary: data.boundary,
    area_circle: data.areaCircle,
    elevation: data.elevation,
    timezone: data.timezone,
    country_code: data.countryCode,
    postal_codes: data.postalCodes,
    population: data.population,
    established_date: data.establishedDate,
    last_updated: data.lastUpdated,
});

/**
 * The update transform function for the "public.geographic_data" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformGeographicDataUpdateRecord = (data: ): {
    location_name: ['locationName'],
    coordinates: ['coordinates'],
    boundary?: ['boundary'],
    area_circle?: ['areaCircle'],
    elevation?: ['elevation'],
    timezone?: ['timezone'],
    country_code?: ['countryCode'],
    postal_codes?: ['postalCodes'],
    population?: ['population'],
    established_date?: ['establishedDate'],
    last_updated?: ['lastUpdated'],
} => ({
    location_name: data.locationName,
    coordinates: data.coordinates,
    boundary: data.boundary,
    area_circle: data.areaCircle,
    elevation: data.elevation,
    timezone: data.timezone,
    country_code: data.countryCode,
    postal_codes: data.postalCodes,
    population: data.population,
    established_date: data.establishedDate,
    last_updated: data.lastUpdated,
});

/**
 * The insert schema for the "public.geographic_data" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const GeographicDataTableInsertSchema = GeographicDataTableWriteSchema.transform(transformGeographicDataInsertRecord);

/**
 * The update schema for the "public.geographic_data" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const GeographicDataTableUpdateSchema = GeographicDataTableWriteSchema.partial().transform(transformGeographicDataUpdateRecord);

type TableInsertRecord = z.input<typeof GeographicDataTableInsertSchema>;
type TableReadRecord = z.output<typeof GeographicDataTableSchema>;

/**
* Represents a database record from the "public.geographic_data" table.
*/
export interface GeographicDataRecord {
    /**
    * Primary key for geographic data table
    */
    id: TableReadRecord['id'];
    /**
    * Name of the location
    */
    locationName: TableReadRecord['locationName'];
    /**
    * Geographic coordinates
    */
    coordinates: TableReadRecord['coordinates'];
    /**
    * Geographic boundary as polygon
    */
    boundary?: TableReadRecord['boundary'];
    /**
    * Area represented as circle
    */
    areaCircle?: TableReadRecord['areaCircle'];
    /**
    * Elevation above sea level
    */
    elevation?: TableReadRecord['elevation'];
    /**
    * Timezone of the location
    */
    timezone?: TableReadRecord['timezone'];
    /**
    * ISO country code
    */
    countryCode?: TableReadRecord['countryCode'];
    /**
    * Array of postal codes
    */
    postalCodes?: TableReadRecord['postalCodes'];
    /**
    * Population count
    */
    population?: TableReadRecord['population'];
    /**
    * Date when location was established
    */
    establishedDate?: TableReadRecord['establishedDate'];
    /**
    * Timestamp when data was last updated
    */
    lastUpdated?: TableReadRecord['lastUpdated'];
}

/**
* Represents an insertable database record from the "public.geographic_data" table.
*/
export interface GeographicDataInsertRecord {
    /**
    * Name of the location
    * @maxLen: 255
    */
    locationName: TableInsertRecord['locationName'];
    /**
    * Geographic coordinates
    */
    coordinates: TableInsertRecord['coordinates'];
    /**
    * Geographic boundary as polygon
    */
    boundary?: TableInsertRecord['boundary'];
    /**
    * Area represented as circle
    */
    areaCircle?: TableInsertRecord['areaCircle'];
    /**
    * Elevation above sea level
    */
    elevation?: TableInsertRecord['elevation'];
    /**
    * Timezone of the location
    * @maxLen: 50
    */
    timezone?: TableInsertRecord['timezone'];
    /**
    * ISO country code
    * @maxLen: 2
    */
    countryCode?: TableInsertRecord['countryCode'];
    /**
    * Array of postal codes
    */
    postalCodes?: TableInsertRecord['postalCodes'];
    /**
    * Population count
    */
    population?: TableInsertRecord['population'];
    /**
    * Date when location was established
    */
    establishedDate?: TableInsertRecord['establishedDate'];
    /**
    * Timestamp when data was last updated
    * @default: now()
    */
    lastUpdated?: TableInsertRecord['lastUpdated'];
}

/**
* Represents an updateable database record from the "public.geographic_data" table.
*/
export type GeographicDataUpdateRecord = Partial<GeographicDataInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './audit_logs/index.js';
export * from './categories/index.js';
export * from './comments/index.js';
export * from './constraint_variations/index.js';
export * from './enum_tests/index.js';
export * from './files/index.js';
export * from './geographic_data/index.js';
export * from './inventory/index.js';
export * from './network_logs/index.js';
export * from './order_items/index.js';
export * from './orders/index.js';
export * from './post_categories/index.js';
export * from './posts/index.js';
export * from './products/index.js';
export * from './time_series/index.js';
export * from './user_sessions/index.js';
export * from './users/index.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/inventory/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/inventory/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { InventorySupplierInfoSchema } from '../../json.js';


/**
 * The base read schema for the "public.inventory" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const InventoryTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    product_id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stock_quantity: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reserved_quantity: z.number().int().nullable().optional(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorder_level: z.number().int().nullable().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    last_restocked: z.date().nullable().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplier_info: InventorySupplierInfoSchema.nullable().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouse_locations: z.array(z.string()).nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.inventory" table.
 * This type represents the raw database record without any transformations.
 */
export type InventoryReadRecord = z.output<typeof InventoryTableReadSchema>;

/**
* The read transform function for the "public.inventory" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformInventoryReadRecord = (data: InventoryReadRecord): {
    productId: InventoryReadRecord['product_id'],
    stockQuantity: InventoryReadRecord['stock_quantity'],
    reservedQuantity?: InventoryReadRecord['reserved_quantity'],
    reorderLevel?: InventoryReadRecord['reorder_level'],
    lastRestocked?: InventoryReadRecord['last_restocked'],
    supplierInfo?: InventoryReadRecord['supplier_info'],
    warehouseLocations?: InventoryReadRecord['warehouse_locations'],
    updatedAt?: InventoryReadRecord['updated_at'],
} => ({
    productId: data.product_id,
    stockQuantity: data.stock_quantity,
    reservedQuantity: data.reserved_quantity ?? undefined,
    reorderLevel: data.reorder_level ?? undefined,
    lastRestocked: data.last_restocked ?? undefined,
    supplierInfo: data.supplier_info ?? undefined,
    warehouseLocations: data.warehouse_locations ?? [],
    updatedAt: data.updated_at ?? undefined,
});

/**
 * The read schema for the "public.inventory" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const InventoryTableSchema = InventoryTableReadSchema.transform(transformInventoryReadRecord);

/**
 * The base write schema for the "public.inventory" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const InventoryTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    productId: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stockQuantity: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reservedQuantity: z.number().int().nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorderLevel: z.number().int().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    lastRestocked: z.date().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplierInfo: InventorySupplierInfoSchema.nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouseLocations: z.array(z.string()).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.inventory" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof InventoryTableWriteSchema>;

/**
 * The base record type for the "public.inventory" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.inventory" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformInventoryInsertRecord = (data: ): {
    product_id: ['productId'],
    stock_quantity: ['stockQuantity'],
    reserved_quantity?: ['reservedQuantity'],
    reorder_level?: ['reorderLevel'],
    last_restocked?: ['lastRestocked'],
    supplier_info?: ['supplierInfo'],
    warehouse_locations?: ['warehouseLocations'],
    updated_at?: ['updatedAt'],
} => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: (data.supplierInfo ? JSON.stringify(data.supplierInfo) : data.supplierInfo),
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.inventory" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformInventoryUpdateRecord = (data: ): {
    product_id: ['productId'],
    stock_quantity: ['stockQuantity'],
    reserved_quantity?: ['reservedQuantity'],
    reorder_level?: ['reorderLevel'],
    last_restocked?: ['lastRestocked'],
    supplier_info?: ['supplierInfo'],
    warehouse_locations?: ['warehouseLocations'],
    updated_at?: ['updatedAt'],
} => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: (data.supplierInfo ? JSON.stringify(data.supplierInfo) : data.supplierInfo),
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.inventory" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const InventoryTableInsertSchema = InventoryTableWriteSchema.transform(transformInventoryInsertRecord);

/**
 * The update schema for the "public.inventory" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const InventoryTableUpdateSchema = InventoryTableWriteSchema.partial().transform(transformInventoryUpdateRecord);

type TableInsertRecord = z.input<typeof InventoryTableInsertSchema>;
type TableReadRecord = z.output<typeof InventoryTableSchema>;

/**
* Represents a database record from the "public.inventory" table.
*/
export interface InventoryRecord {
    /**
    * ID of the product
    */
    productId: TableReadRecord['productId'];
    /**
    * Current stock quantity
    */
    stockQuantity: TableReadRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    */
    reservedQuantity?: TableReadRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    */
    reorderLevel?: TableReadRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableReadRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableReadRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableReadRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.inventory" table.
*/
export interface InventoryInsertRecord {
    /**
    * ID of the product
    */
    productId: TableInsertRecord['productId'];
    /**
    * Current stock quantity
    * @default: 0
    */
    stockQuantity: TableInsertRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    * @default: 0
    */
    reservedQuantity?: TableInsertRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    * @default: 10
    */
    reorderLevel?: TableInsertRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableInsertRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableInsertRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableInsertRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.inventory" table.
*/
export type InventoryUpdateRecord = Partial<InventoryInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/network_logs/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/network_logs/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { NetworkLogHeadersSchema } from '../../json.js';


/**
 * The base read schema for the "public.network_logs" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const NetworkLogsTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('network_logs_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ip_address: z.string(),
    /**
    * dataType: int4range
    * defaultValue: 
    */
    port_range: z.any().nullable().optional(),
    /**
    * dataType: macaddr
    * defaultValue: 
    */
    mac_address: z.string().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    request_time: z.date().nullable().optional(),
    /**
    * dataType: interval
    * defaultValue: 
    */
    response_time: z.any().nullable().optional(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytes_sent: z.number().int().nullable().optional(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytes_received: z.number().int().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    protocol: z.string().nullable().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    status_code: z.number().int().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    user_agent: z.string().nullable().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    headers: NetworkLogHeadersSchema.nullable().optional(),
});

/**
 * The base record type for the "public.network_logs" table.
 * This type represents the raw database record without any transformations.
 */
export type NetworkLogReadRecord = z.output<typeof NetworkLogsTableReadSchema>;

/**
* The read transform function for the "public.network_logs" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformNetworkLogReadRecord = (data: NetworkLogReadRecord): {
    id: NetworkLogReadRecord['id'],
    ipAddress: NetworkLogReadRecord['ip_address'],
    portRange?: NetworkLogReadRecord['port_range'],
    macAddress?: NetworkLogReadRecord['mac_address'],
    requestTime?: NetworkLogReadRecord['request_time'],
    responseTime?: NetworkLogReadRecord['response_time'],
    bytesSent?: NetworkLogReadRecord['bytes_sent'],
    bytesReceived?: NetworkLogReadRecord['bytes_received'],
    protocol?: NetworkLogReadRecord['protocol'],
    statusCode?: NetworkLogReadRecord['status_code'],
    userAgent?: NetworkLogReadRecord['user_agent'],
    headers?: NetworkLogReadRecord['headers'],
} => ({
    id: data.id,
    ipAddress: data.ip_address,
    portRange: data.port_range ?? undefined,
    macAddress: data.mac_address ?? undefined,
    requestTime: data.request_time ?? undefined,
    responseTime: data.response_time ?? undefined,
    bytesSent: data.bytes_sent ?? undefined,
    bytesReceived: data.bytes_received ?? undefined,
    protocol: data.protocol ?? undefined,
    statusCode: data.status_code ?? undefined,
    userAgent: data.user_agent ?? undefined,
    headers: data.headers ?? undefined,
});

/**
 * The read schema for the "public.network_logs" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const NetworkLogsTableSchema = NetworkLogsTableReadSchema.transform(transformNetworkLogReadRecord);

/**
 * The base write schema for the "public.network_logs" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const NetworkLogsTableWriteSchema = z.object({
    /**
    * dataType: inet
    * defaultValue: 
    */
    ipAddress: z.string(),
    /**
    * dataType: int4range
    * defaultValue: 
    */
    portRange: z.any().nullish().optional(),
    /**
    * dataType: macaddr
    * defaultValue: 
    */
    macAddress: z.string().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    requestTime: z.date().nullish().optional(),
    /**
    * dataType: interval
    * defaultValue: 
    */
    responseTime: z.any().nullish().optional(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytesSent: z.number().int().nullish().optional(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytesReceived: z.number().int().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    protocol: z.string().max(10).nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    statusCode: z.number().int().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    userAgent: z.string().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    headers: NetworkLogHeadersSchema.nullish().optional(),
});

/**
 * The base record type for the "public.network_logs" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof NetworkLogsTableWriteSchema>;

/**
 * The base record type for the "public.network_logs" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.network_logs" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformNetworkLogInsertRecord = (data: ): {
    ip_address: ['ipAddress'],
    port_range?: ['portRange'],
    mac_address?: ['macAddress'],
    request_time?: ['requestTime'],
    response_time?: ['responseTime'],
    bytes_sent?: ['bytesSent'],
    bytes_received?: ['bytesReceived'],
    protocol?: ['protocol'],
    status_code?: ['statusCode'],
    user_agent?: ['userAgent'],
    headers?: ['headers'],
} => ({
    ip_address: data.ipAddress,
    port_range: data.portRange,
    mac_address: data.macAddress,
    request_time: data.requestTime,
    response_time: data.responseTime,
    bytes_sent: data.bytesSent,
    bytes_received: data.bytesReceived,
    protocol: data.protocol,
    status_code: data.statusCode,
    user_agent: data.userAgent,
    headers: (data.headers ? JSON.stringify(data.headers) : data.headers),
});

/**
 * The update transform function for the "public.network_logs" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformNetworkLogUpdateRecord = (data: ): {
    ip_address: ['ipAddress'],
    port_range?: ['portRange'],
    mac_address?: ['macAddress'],
    request_time?: ['requestTime'],
    response_time?: ['responseTime'],
    bytes_sent?: ['bytesSent'],
    bytes_received?: ['bytesReceived'],
    protocol?: ['protocol'],
    status_code?: ['statusCode'],
    user_agent?: ['userAgent'],
    headers?: ['headers'],
} => ({
    ip_address: data.ipAddress,
    port_range: data.portRange,
    mac_address: data.macAddress,
    request_time: data.requestTime,
    response_time: data.responseTime,
    bytes_sent: data.bytesSent,
    bytes_received: data.bytesReceived,
    protocol: data.protocol,
    status_code: data.statusCode,
    user_agent: data.userAgent,
    headers: (data.headers ? JSON.stringify(data.headers) : data.headers),
});

/**
 * The insert schema for the "public.network_logs" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const NetworkLogsTableInsertSchema = NetworkLogsTableWriteSchema.transform(transformNetworkLogInsertRecord);

/**
 * The update schema for the "public.network_logs" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const NetworkLogsTableUpdateSchema = NetworkLogsTableWriteSchema.partial().transform(transformNetworkLogUpdateRecord);

type TableInsertRecord = z.input<typeof NetworkLogsTableInsertSchema>;
type TableReadRecord = z.output<typeof NetworkLogsTableSchema>;

/**
* Represents a database record from the "public.network_logs" table.
*/
export interface NetworkLogRecord {
    /**
    * Primary key for network logs table
    */
    id: TableReadRecord['id'];
    /**
    * IP address of the request
    */
    ipAddress: TableReadRecord['ipAddress'];
    /**
    * Port range used
    */
    portRange?: TableReadRecord['portRange'];
    /**
    * MAC address of the device
    */
    macAddress?: TableReadRecord['macAddress'];
    /**
    * Timestamp of the request
    */
    requestTime?: TableReadRecord['requestTime'];
    /**
    * Response time duration
    */
    responseTime?: TableReadRecord['responseTime'];
    /**
    * Number of bytes sent
    */
    bytesSent?: TableReadRecord['bytesSent'];
    /**
    * Number of bytes received
    */
    bytesReceived?: TableReadRecord['bytesReceived'];
    /**
    * Network protocol used
    */
    protocol?: TableReadRecord['protocol'];
    /**
    * HTTP status code
    */
    statusCode?: TableReadRecord['statusCode'];
    /**
    * User agent string
    */
    userAgent?: TableReadRecord['userAgent'];
    /**
    * Request headers in JSON format
    */
    headers?: TableReadRecord['headers'];
}

/**
* Represents an insertable database record from the "public.network_logs" table.
*/
export interface NetworkLogInsertRecord {
    /**
    * IP address of the request
    */
    ipAddress: TableInsertRecord['ipAddress'];
    /**
    * Port range used
    */
    portRange?: TableInsertRecord['portRange'];
    /**
    * MAC address of the device
    */
    macAddress?: TableInsertRecord['macAddress'];
    /**
    * Timestamp of the request
    * @default: now()
    */
    requestTime?: TableInsertRecord['requestTime'];
    /**
    * Response time duration
    */
    responseTime?: TableInsertRecord['responseTime'];
    /**
    * Number of bytes sent
    * @default: 0
    */
    bytesSent?: TableInsertRecord['bytesSent'];
    /**
    * Number of bytes received
    * @default: 0
    */
    bytesReceived?: TableInsertRecord['bytesReceived'];
    /**
    * Network protocol used
    * @maxLen: 10
    */
    protocol?: TableInsertRecord['protocol'];
    /**
    * HTTP status code
    */
    statusCode?: TableInsertRecord['statusCode'];
    /**
    * User agent string
    */
    userAgent?: TableInsertRecord['userAgent'];
    /**
    * Request headers in JSON format
    */
    headers?: TableInsertRecord['headers'];
}

/**
* Represents an updateable database record from the "public.network_logs" table.
*/
export type NetworkLogUpdateRecord = Partial<NetworkLogInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/order_items/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/order_items/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.order_items" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const OrderItemsTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('order_items_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    order_id: z.number().int().nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    product_id: z.number().int().nullable().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    quantity: z.number().int(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    unit_price: z.number(),
    /**
    * dataType: numeric
    * defaultValue: 0
    */
    discount_percent: z.number().nullable().optional(),
    /**
    * dataType: numeric
    * defaultValue: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    line_total: z.number().nullable().optional(),
});

/**
 * The base record type for the "public.order_items" table.
 * This type represents the raw database record without any transformations.
 */
export type OrderItemReadRecord = z.output<typeof OrderItemsTableReadSchema>;

/**
* The read transform function for the "public.order_items" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformOrderItemReadRecord = (data: OrderItemReadRecord): {
    id: OrderItemReadRecord['id'],
    orderId?: OrderItemReadRecord['order_id'],
    productId?: OrderItemReadRecord['product_id'],
    quantity: OrderItemReadRecord['quantity'],
    unitPrice: OrderItemReadRecord['unit_price'],
    discountPercent?: OrderItemReadRecord['discount_percent'],
    lineTotal?: OrderItemReadRecord['line_total'],
} => ({
    id: data.id,
    orderId: data.order_id ?? undefined,
    productId: data.product_id ?? undefined,
    quantity: data.quantity,
    unitPrice: data.unit_price,
    discountPercent: data.discount_percent ?? undefined,
    lineTotal: data.line_total ?? undefined,
});

/**
 * The read schema for the "public.order_items" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const OrderItemsTableSchema = OrderItemsTableReadSchema.transform(transformOrderItemReadRecord);

/**
 * The base write schema for the "public.order_items" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const OrderItemsTableWriteSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: 
    */
    orderId: z.number().int().nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    productId: z.number().int().nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    quantity: z.number().int(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    unitPrice: z.number().max(655362),
    /**
    * dataType: numeric
    * defaultValue: 0
    */
    discountPercent: z.number().max(327682).nullish().optional(),
    /**
    * dataType: numeric
    * defaultValue: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    lineTotal: z.number().max(786434).nullish().optional(),
});

/**
 * The base record type for the "public.order_items" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof OrderItemsTableWriteSchema>;

/**
 * The base record type for the "public.order_items" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.order_items" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformOrderItemInsertRecord = (data: ): {
    order_id?: ['orderId'],
    product_id?: ['productId'],
    quantity: ['quantity'],
    unit_price: ['unitPrice'],
    discount_percent?: ['discountPercent'],
    line_total?: ['lineTotal'],
} => ({
    order_id: data.orderId,
    product_id: data.productId,
    quantity: data.quantity,
    unit_price: data.unitPrice,
    discount_percent: data.discountPercent,
    line_total: data.lineTotal,
});

/**
 * The update transform function for the "public.order_items" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformOrderItemUpdateRecord = (data: ): {
    order_id?: ['orderId'],
    product_id?: ['productId'],
    quantity: ['quantity'],
    unit_price: ['unitPrice'],
    discount_percent?: ['discountPercent'],
    line_total?: ['lineTotal'],
} => ({
    order_id: data.orderId,
    product_id: data.productId,
    quantity: data.quantity,
    unit_price: data.unitPrice,
    discount_percent: data.discountPercent,
    line_total: data.lineTotal,
});

/**
 * The insert schema for the "public.order_items" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const OrderItemsTableInsertSchema = OrderItemsTableWriteSchema.transform(transformOrderItemInsertRecord);

/**
 * The update schema for the "public.order_items" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const OrderItemsTableUpdateSchema = OrderItemsTableWriteSchema.partial().transform(transformOrderItemUpdateRecord);

type TableInsertRecord = z.input<typeof OrderItemsTableInsertSchema>;
type TableReadRecord = z.output<typeof OrderItemsTableSchema>;

/**
* Represents a database record from the "public.order_items" table.
*/
export interface OrderItemRecord {
    /**
    * Primary key for order items table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the order this item belongs to
    */
    orderId?: TableReadRecord['orderId'];
    /**
    * ID of the product
    */
    productId?: TableReadRecord['productId'];
    /**
    * Quantity of the product ordered
    */
    quantity: TableReadRecord['quantity'];
    /**
    * Price per unit
    */
    unitPrice: TableReadRecord['unitPrice'];
    /**
    * Discount percentage applied
    */
    discountPercent?: TableReadRecord['discountPercent'];
    /**
    * Calculated line total
    */
    lineTotal?: TableReadRecord['lineTotal'];
}

/**
* Represents an insertable database record from the "public.order_items" table.
*/
export interface OrderItemInsertRecord {
    /**
    * ID of the order this item belongs to
    */
    orderId?: TableInsertRecord['orderId'];
    /**
    * ID of the product
    */
    productId?: TableInsertRecord['productId'];
    /**
    * Quantity of the product ordered
    */
    quantity: TableInsertRecord['quantity'];
    /**
    * Price per unit
    * @maxLen: 655362
    */
    unitPrice: TableInsertRecord['unitPrice'];
    /**
    * Discount percentage applied
    * @maxLen: 327682
    * @default: 0
    */
    discountPercent?: TableInsertRecord['discountPercent'];
    /**
    * Calculated line total
    * @maxLen: 786434
    * @default: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    lineTotal?: TableInsertRecord['lineTotal'];
}

/**
* Represents an updateable database record from the "public.order_items" table.
*/
export type OrderItemUpdateRecord = Partial<OrderItemInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/orders/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/orders/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { OrderMetadataSchema } from '../../json.js';


/**
 * The base read schema for the "public.orders" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const OrdersTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('orders_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    order_number: z.string(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullable().optional(),
    /**
    * dataType: order_status
    * defaultValue: 'pending'::order_status
    */
    status: z.any().nullable().optional(),
    /**
    * dataType: money
    * defaultValue: 
    */
    total_amount: z.number(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    tax_amount: z.number().nullable().optional(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    shipping_cost: z.number().nullable().optional(),
    /**
    * dataType: date
    * defaultValue: CURRENT_DATE
    */
    order_date: z.date().nullable().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    shipped_date: z.date().nullable().optional(),
    /**
    * dataType: time
    * defaultValue: 
    */
    delivery_time: z.string().nullable().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    notes: z.array(z.string()).nullable().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: OrderMetadataSchema.nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.orders" table.
 * This type represents the raw database record without any transformations.
 */
export type OrderReadRecord = z.output<typeof OrdersTableReadSchema>;

/**
* The read transform function for the "public.orders" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformOrderReadRecord = (data: OrderReadRecord): {
    id: OrderReadRecord['id'],
    orderNumber: OrderReadRecord['order_number'],
    userId?: OrderReadRecord['user_id'],
    status?: OrderReadRecord['status'],
    totalAmount: OrderReadRecord['total_amount'],
    taxAmount?: OrderReadRecord['tax_amount'],
    shippingCost?: OrderReadRecord['shipping_cost'],
    orderDate?: OrderReadRecord['order_date'],
    shippedDate?: OrderReadRecord['shipped_date'],
    deliveryTime?: OrderReadRecord['delivery_time'],
    notes?: OrderReadRecord['notes'],
    metadata?: OrderReadRecord['metadata'],
    createdAt?: OrderReadRecord['created_at'],
} => ({
    id: data.id,
    orderNumber: data.order_number,
    userId: data.user_id ?? undefined,
    status: data.status ?? undefined,
    totalAmount: data.total_amount,
    taxAmount: data.tax_amount ?? undefined,
    shippingCost: data.shipping_cost ?? undefined,
    orderDate: data.order_date ?? undefined,
    shippedDate: data.shipped_date ?? undefined,
    deliveryTime: data.delivery_time ?? undefined,
    notes: data.notes ?? [],
    metadata: data.metadata ?? undefined,
    createdAt: data.created_at ?? undefined,
});

/**
 * The read schema for the "public.orders" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const OrdersTableSchema = OrdersTableReadSchema.transform(transformOrderReadRecord);

/**
 * The base write schema for the "public.orders" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const OrdersTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    orderNumber: z.string().max(20),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: order_status
    * defaultValue: 'pending'::order_status
    */
    status: z.any().nullish().optional(),
    /**
    * dataType: money
    * defaultValue: 
    */
    totalAmount: z.number(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    taxAmount: z.number().nullish().optional(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    shippingCost: z.number().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: CURRENT_DATE
    */
    orderDate: z.date().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    shippedDate: z.date().nullish().optional(),
    /**
    * dataType: time
    * defaultValue: 
    */
    deliveryTime: z.string().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    notes: z.array(z.string()).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: OrderMetadataSchema.nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.orders" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof OrdersTableWriteSchema>;

/**
 * The base record type for the "public.orders" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.orders" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformOrderInsertRecord = (data: ): {
    order_number: ['orderNumber'],
    user_id?: ['userId'],
    status?: ['status'],
    total_amount: ['totalAmount'],
    tax_amount?: ['taxAmount'],
    shipping_cost?: ['shippingCost'],
    order_date?: ['orderDate'],
    shipped_date?: ['shippedDate'],
    delivery_time?: ['deliveryTime'],
    notes?: ['notes'],
    metadata?: ['metadata'],
    created_at?: ['createdAt'],
} => ({
    order_number: data.orderNumber,
    user_id: data.userId,
    status: data.status,
    total_amount: data.totalAmount,
    tax_amount: data.taxAmount,
    shipping_cost: data.shippingCost,
    order_date: data.orderDate,
    shipped_date: data.shippedDate,
    delivery_time: data.deliveryTime,
    notes: data.notes,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.orders" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformOrderUpdateRecord = (data: ): {
    order_number: ['orderNumber'],
    user_id?: ['userId'],
    status?: ['status'],
    total_amount: ['totalAmount'],
    tax_amount?: ['taxAmount'],
    shipping_cost?: ['shippingCost'],
    order_date?: ['orderDate'],
    shipped_date?: ['shippedDate'],
    delivery_time?: ['deliveryTime'],
    notes?: ['notes'],
    metadata?: ['metadata'],
    created_at?: ['createdAt'],
} => ({
    order_number: data.orderNumber,
    user_id: data.userId,
    status: data.status,
    total_amount: data.totalAmount,
    tax_amount: data.taxAmount,
    shipping_cost: data.shippingCost,
    order_date: data.orderDate,
    shipped_date: data.shippedDate,
    delivery_time: data.deliveryTime,
    notes: data.notes,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.orders" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const OrdersTableInsertSchema = OrdersTableWriteSchema.transform(transformOrderInsertRecord);

/**
 * The update schema for the "public.orders" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const OrdersTableUpdateSchema = OrdersTableWriteSchema.partial().transform(transformOrderUpdateRecord);

type TableInsertRecord = z.input<typeof OrdersTableInsertSchema>;
type TableReadRecord = z.output<typeof OrdersTableSchema>;

/**
* Represents a database record from the "public.orders" table.
*/
export interface OrderRecord {
    /**
    * Primary key for orders table
    */
    id: TableReadRecord['id'];
    /**
    * Unique order number
    */
    orderNumber: TableReadRecord['orderNumber'];
    /**
    * ID of the user who placed the order
    */
    userId?: TableReadRecord['userId'];
    /**
    * Current status of the order
    */
    status?: TableReadRecord['status'];
    /**
    * Total order amount
    */
    totalAmount: TableReadRecord['totalAmount'];
    /**
    * Tax amount for the order
    */
    taxAmount?: TableReadRecord['taxAmount'];
    /**
    * Shipping cost for the order
    */
    shippingCost?: TableReadRecord['shippingCost'];
    /**
    * Date when order was placed
    */
    orderDate?: TableReadRecord['orderDate'];
    /**
    * Date when order was shipped
    */
    shippedDate?: TableReadRecord['shippedDate'];
    /**
    * Expected delivery time
    */
    deliveryTime?: TableReadRecord['deliveryTime'];
    /**
    * Array of order notes
    */
    notes?: TableReadRecord['notes'];
    /**
    * Additional order metadata
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Timestamp when order was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.orders" table.
*/
export interface OrderInsertRecord {
    /**
    * Unique order number
    * @maxLen: 20
    */
    orderNumber: TableInsertRecord['orderNumber'];
    /**
    * ID of the user who placed the order
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Current status of the order
    * @default: 'pending'::order_status
    */
    status?: TableInsertRecord['status'];
    /**
    * Total order amount
    */
    totalAmount: TableInsertRecord['totalAmount'];
    /**
    * Tax amount for the order
    * @default: 0
    */
    taxAmount?: TableInsertRecord['taxAmount'];
    /**
    * Shipping cost for the order
    * @default: 0
    */
    shippingCost?: TableInsertRecord['shippingCost'];
    /**
    * Date when order was placed
    * @default: CURRENT_DATE
    */
    orderDate?: TableInsertRecord['orderDate'];
    /**
    * Date when order was shipped
    */
    shippedDate?: TableInsertRecord['shippedDate'];
    /**
    * Expected delivery time
    */
    deliveryTime?: TableInsertRecord['deliveryTime'];
    /**
    * Array of order notes
    */
    notes?: TableInsertRecord['notes'];
    /**
    * Additional order metadata
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Timestamp when order was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.orders" table.
*/
export type OrderUpdateRecord = Partial<OrderInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/post_categories/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/post_categories/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.post_categories" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const PostCategoriesTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    category_id: z.number().int(),
});

/**
 * The base record type for the "public.post_categories" table.
 * This type represents the raw database record without any transformations.
 */
export type PostCategoryReadRecord = z.output<typeof PostCategoriesTableReadSchema>;

/**
* The read transform function for the "public.post_categories" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformPostCategoryReadRecord = (data: PostCategoryReadRecord): {
    postId: PostCategoryReadRecord['post_id'],
    categoryId: PostCategoryReadRecord['category_id'],
} => ({
    postId: data.post_id,
    categoryId: data.category_id,
});

/**
 * The read schema for the "public.post_categories" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const PostCategoriesTableSchema = PostCategoriesTableReadSchema.transform(transformPostCategoryReadRecord);

/**
 * The base write schema for the "public.post_categories" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const PostCategoriesTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    postId: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    categoryId: z.number().int(),
});

/**
 * The base record type for the "public.post_categories" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof PostCategoriesTableWriteSchema>;

/**
 * The base record type for the "public.post_categories" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.post_categories" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostCategoryInsertRecord = (data: ): {
    post_id: ['postId'],
    category_id: ['categoryId'],
} => ({
    post_id: data.postId,
    category_id: data.categoryId,
});

/**
 * The update transform function for the "public.post_categories" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostCategoryUpdateRecord = (data: ): {
    post_id: ['postId'],
    category_id: ['categoryId'],
} => ({
    post_id: data.postId,
    category_id: data.categoryId,
});

/**
 * The insert schema for the "public.post_categories" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const PostCategoriesTableInsertSchema = PostCategoriesTableWriteSchema.transform(transformPostCategoryInsertRecord);

/**
 * The update schema for the "public.post_categories" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const PostCategoriesTableUpdateSchema = PostCategoriesTableWriteSchema.partial().transform(transformPostCategoryUpdateRecord);

type TableInsertRecord = z.input<typeof PostCategoriesTableInsertSchema>;
type TableReadRecord = z.output<typeof PostCategoriesTableSchema>;

/**
* Represents a database record from the "public.post_categories" table.
*/
export interface PostCategoryRecord {
    /**
    * ID of the post
    */
    postId: TableReadRecord['postId'];
    /**
    * ID of the category
    */
    categoryId: TableReadRecord['categoryId'];
}

/**
* Represents an insertable database record from the "public.post_categories" table.
*/
export interface PostCategoryInsertRecord {
    /**
    * ID of the post
    */
    postId: TableInsertRecord['postId'];
    /**
    * ID of the category
    */
    categoryId: TableInsertRecord['categoryId'];
}

/**
* Represents an updateable database record from the "public.post_categories" table.
*/
export type PostCategoryUpdateRecord = Partial<PostCategoryInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/posts/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/posts/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { PostMetadataSchema } from '../../json.js';

export const POST_STATUSES = ['draft', 'published', 'archived'] as const;

/**
 * The base read schema for the "public.posts" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const PostsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('posts_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullable().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.number().int().nullable().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullable().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: PostMetadataSchema.nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    published_at: z.date().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents the raw database record without any transformations.
 */
export type PostReadRecord = z.output<typeof PostsTableReadSchema>;

/**
* The read transform function for the "public.posts" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformPostReadRecord = (data: PostReadRecord): {
    id: PostReadRecord['id'],
    userId?: PostReadRecord['user_id'],
    title: PostReadRecord['title'],
    content?: PostReadRecord['content'],
    published?: PostReadRecord['published'],
    status?: PostReadRecord['status'],
    views?: PostReadRecord['views'],
    tags?: PostReadRecord['tags'],
    metadata?: PostReadRecord['metadata'],
    publishedAt?: PostReadRecord['published_at'],
    updatedAt?: PostReadRecord['updated_at'],
} => ({
    id: data.id,
    userId: data.user_id ?? undefined,
    title: data.title,
    content: data.content ?? undefined,
    published: data.published ?? undefined,
    status: data.status ?? undefined,
    views: data.views ?? undefined,
    tags: data.tags ?? [],
    metadata: data.metadata ?? undefined,
    publishedAt: data.published_at ?? undefined,
    updatedAt: data.updated_at ?? undefined,
});

/**
 * The read schema for the "public.posts" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const PostsTableSchema = PostsTableReadSchema.transform(transformPostReadRecord);

/**
 * The base write schema for the "public.posts" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const PostsTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.number().int().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: PostMetadataSchema.nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    publishedAt: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof PostsTableWriteSchema>;

/**
 * The base record type for the "public.posts" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.posts" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostInsertRecord = (data: ): {
    user_id?: ['userId'],
    title: ['title'],
    content?: ['content'],
    published?: ['published'],
    status?: ['status'],
    views?: ['views'],
    tags?: ['tags'],
    metadata?: ['metadata'],
    published_at?: ['publishedAt'],
    updated_at?: ['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.posts" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostUpdateRecord = (data: ): {
    user_id?: ['userId'],
    title: ['title'],
    content?: ['content'],
    published?: ['published'],
    status?: ['status'],
    views?: ['views'],
    tags?: ['tags'],
    metadata?: ['metadata'],
    published_at?: ['publishedAt'],
    updated_at?: ['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.posts" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const PostsTableInsertSchema = PostsTableWriteSchema.transform(transformPostInsertRecord);

/**
 * The update schema for the "public.posts" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const PostsTableUpdateSchema = PostsTableWriteSchema.partial().transform(transformPostUpdateRecord);

type TableInsertRecord = z.input<typeof PostsTableInsertSchema>;
type TableReadRecord = z.output<typeof PostsTableSchema>;
export type PostStatus = (typeof POST_STATUSES)[number];

/**
* Represents a database record from the "public.posts" table.
*/
export interface PostRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    title: TableReadRecord['title'];
    /**
    */
    content?: TableReadRecord['content'];
    /**
    */
    published?: TableReadRecord['published'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    * Number of views for the post
    */
    views?: TableReadRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableReadRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableReadRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.posts" table.
*/
export interface PostInsertRecord {
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    */
    title: TableInsertRecord['title'];
    /**
    */
    content?: TableInsertRecord['content'];
    /**
    * @default: false
    */
    published?: TableInsertRecord['published'];
    /**
    * @maxLen: 20
    * @default: 'draft'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    * Number of views for the post
    * @default: 0
    */
    views?: TableInsertRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableInsertRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.posts" table.
*/
export type PostUpdateRecord = Partial<PostInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/products/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/products/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.products" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const ProductsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('products_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sku: z.string(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    price: z.number(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    cost: z.number().nullable().optional(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    weight: z.number().nullable().optional(),
    /**
    * dataType: point
    * defaultValue: 
    */
    dimensions: z.string().nullable().optional(),
    /**
    * dataType: bool
    * defaultValue: true
    */
    is_active: z.boolean().nullable().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    barcode: z.string().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.products" table.
 * This type represents the raw database record without any transformations.
 */
export type ProductReadRecord = z.output<typeof ProductsTableReadSchema>;

/**
* The read transform function for the "public.products" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformProductReadRecord = (data: ProductReadRecord): {
    id: ProductReadRecord['id'],
    name: ProductReadRecord['name'],
    sku: ProductReadRecord['sku'],
    price: ProductReadRecord['price'],
    cost?: ProductReadRecord['cost'],
    weight?: ProductReadRecord['weight'],
    dimensions?: ProductReadRecord['dimensions'],
    isActive?: ProductReadRecord['is_active'],
    barcode?: ProductReadRecord['barcode'],
    description?: ProductReadRecord['description'],
    createdAt?: ProductReadRecord['created_at'],
} => ({
    id: data.id,
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost ?? undefined,
    weight: data.weight ?? undefined,
    dimensions: data.dimensions ?? undefined,
    isActive: data.is_active ?? undefined,
    barcode: data.barcode ?? undefined,
    description: data.description ?? undefined,
    createdAt: data.created_at ?? undefined,
});

/**
 * The read schema for the "public.products" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const ProductsTableSchema = ProductsTableReadSchema.transform(transformProductReadRecord);

/**
 * The base write schema for the "public.products" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const ProductsTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(255),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sku: z.string().max(50),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    price: z.number().max(655362),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    cost: z.number().max(655362).nullish().optional(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    weight: z.number().nullish().optional(),
    /**
    * dataType: point
    * defaultValue: 
    */
    dimensions: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: true
    */
    isActive: z.boolean().nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    barcode: z.string().max(13).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.products" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof ProductsTableWriteSchema>;

/**
 * The base record type for the "public.products" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.products" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformProductInsertRecord = (data: ): {
    name: ['name'],
    sku: ['sku'],
    price: ['price'],
    cost?: ['cost'],
    weight?: ['weight'],
    dimensions?: ['dimensions'],
    is_active?: ['isActive'],
    barcode?: ['barcode'],
    description?: ['description'],
    created_at?: ['createdAt'],
} => ({
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    is_active: data.isActive,
    barcode: data.barcode,
    description: data.description,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.products" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformProductUpdateRecord = (data: ): {
    name: ['name'],
    sku: ['sku'],
    price: ['price'],
    cost?: ['cost'],
    weight?: ['weight'],
    dimensions?: ['dimensions'],
    is_active?: ['isActive'],
    barcode?: ['barcode'],
    description?: ['description'],
    created_at?: ['createdAt'],
} => ({
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    is_active: data.isActive,
    barcode: data.barcode,
    description: data.description,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.products" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const ProductsTableInsertSchema = ProductsTableWriteSchema.transform(transformProductInsertRecord);

/**
 * The update schema for the "public.products" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const ProductsTableUpdateSchema = ProductsTableWriteSchema.partial().transform(transformProductUpdateRecord);

type TableInsertRecord = z.input<typeof ProductsTableInsertSchema>;
type TableReadRecord = z.output<typeof ProductsTableSchema>;

/**
* Represents a database record from the "public.products" table.
*/
export interface ProductRecord {
    /**
    * Primary key for products table
    */
    id: TableReadRecord['id'];
    /**
    * Product name
    */
    name: TableReadRecord['name'];
    /**
    * Stock keeping unit identifier
    */
    sku: TableReadRecord['sku'];
    /**
    * Product price with 2 decimal precision
    */
    price: TableReadRecord['price'];
    /**
    * Product cost with 2 decimal precision
    */
    cost?: TableReadRecord['cost'];
    /**
    * Product weight in kilograms
    */
    weight?: TableReadRecord['weight'];
    /**
    * Product dimensions as geometric point
    */
    dimensions?: TableReadRecord['dimensions'];
    /**
    * Whether the product is active
    */
    isActive?: TableReadRecord['isActive'];
    /**
    * Product barcode (13 characters)
    */
    barcode?: TableReadRecord['barcode'];
    /**
    * Product description
    */
    description?: TableReadRecord['description'];
    /**
    * Timestamp when product was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.products" table.
*/
export interface ProductInsertRecord {
    /**
    * Product name
    * @maxLen: 255
    */
    name: TableInsertRecord['name'];
    /**
    * Stock keeping unit identifier
    * @maxLen: 50
    */
    sku: TableInsertRecord['sku'];
    /**
    * Product price with 2 decimal precision
    * @maxLen: 655362
    */
    price: TableInsertRecord['price'];
    /**
    * Product cost with 2 decimal precision
    * @maxLen: 655362
    */
    cost?: TableInsertRecord['cost'];
    /**
    * Product weight in kilograms
    */
    weight?: TableInsertRecord['weight'];
    /**
    * Product dimensions as geometric point
    */
    dimensions?: TableInsertRecord['dimensions'];
    /**
    * Whether the product is active
    * @default: true
    */
    isActive?: TableInsertRecord['isActive'];
    /**
    * Product barcode (13 characters)
    * @maxLen: 13
    */
    barcode?: TableInsertRecord['barcode'];
    /**
    * Product description
    */
    description?: TableInsertRecord['description'];
    /**
    * Timestamp when product was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.products" table.
*/
export type ProductUpdateRecord = Partial<ProductInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/time_series/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/time_series/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.time_series" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const TimeSeriesTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('time_series_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sensor_id: z.string(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    timestamp: z.date(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    temperature: z.number().nullable().optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    humidity: z.number().nullable().optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    pressure: z.number().nullable().optional(),
    /**
    * dataType: _numeric
    * defaultValue: 
    */
    readings: z.array(z.number()).nullable().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    anomaly_detected: z.boolean().nullable().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    data_quality: z.number().int().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
});

/**
 * The base record type for the "public.time_series" table.
 * This type represents the raw database record without any transformations.
 */
export type TimeSeriesReadRecord = z.output<typeof TimeSeriesTableReadSchema>;

/**
* The read transform function for the "public.time_series" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformTimeSeriesReadRecord = (data: TimeSeriesReadRecord): {
    id: TimeSeriesReadRecord['id'],
    sensorId: TimeSeriesReadRecord['sensor_id'],
    timestamp: TimeSeriesReadRecord['timestamp'],
    temperature?: TimeSeriesReadRecord['temperature'],
    humidity?: TimeSeriesReadRecord['humidity'],
    pressure?: TimeSeriesReadRecord['pressure'],
    readings?: TimeSeriesReadRecord['readings'],
    anomalyDetected?: TimeSeriesReadRecord['anomaly_detected'],
    dataQuality?: TimeSeriesReadRecord['data_quality'],
    createdAt?: TimeSeriesReadRecord['created_at'],
} => ({
    id: data.id,
    sensorId: data.sensor_id,
    timestamp: data.timestamp,
    temperature: data.temperature ?? undefined,
    humidity: data.humidity ?? undefined,
    pressure: data.pressure ?? undefined,
    readings: data.readings ?? [],
    anomalyDetected: data.anomaly_detected ?? undefined,
    dataQuality: data.data_quality ?? undefined,
    createdAt: data.created_at ?? undefined,
});

/**
 * The read schema for the "public.time_series" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const TimeSeriesTableSchema = TimeSeriesTableReadSchema.transform(transformTimeSeriesReadRecord);

/**
 * The base write schema for the "public.time_series" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const TimeSeriesTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sensorId: z.string().max(50),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    timestamp: z.date(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    temperature: z.number().max(327682).nullish().optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    humidity: z.number().max(327682).nullish().optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    pressure: z.number().max(458754).nullish().optional(),
    /**
    * dataType: _numeric
    * defaultValue: 
    */
    readings: z.array(z.number()).nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    anomalyDetected: z.boolean().nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    dataQuality: z.number().int().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.time_series" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof TimeSeriesTableWriteSchema>;

/**
 * The base record type for the "public.time_series" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.time_series" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformTimeSeriesInsertRecord = (data: ): {
    sensor_id: ['sensorId'],
    timestamp: ['timestamp'],
    temperature?: ['temperature'],
    humidity?: ['humidity'],
    pressure?: ['pressure'],
    readings?: ['readings'],
    anomaly_detected?: ['anomalyDetected'],
    data_quality?: ['dataQuality'],
    created_at?: ['createdAt'],
} => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.time_series" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformTimeSeriesUpdateRecord = (data: ): {
    sensor_id: ['sensorId'],
    timestamp: ['timestamp'],
    temperature?: ['temperature'],
    humidity?: ['humidity'],
    pressure?: ['pressure'],
    readings?: ['readings'],
    anomaly_detected?: ['anomalyDetected'],
    data_quality?: ['dataQuality'],
    created_at?: ['createdAt'],
} => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.time_series" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const TimeSeriesTableInsertSchema = TimeSeriesTableWriteSchema.transform(transformTimeSeriesInsertRecord);

/**
 * The update schema for the "public.time_series" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const TimeSeriesTableUpdateSchema = TimeSeriesTableWriteSchema.partial().transform(transformTimeSeriesUpdateRecord);

type TableInsertRecord = z.input<typeof TimeSeriesTableInsertSchema>;
type TableReadRecord = z.output<typeof TimeSeriesTableSchema>;

/**
* Represents a database record from the "public.time_series" table.
*/
export interface TimeSeriesRecord {
    /**
    * Primary key for time series table
    */
    id: TableReadRecord['id'];
    /**
    * Identifier of the sensor
    */
    sensorId: TableReadRecord['sensorId'];
    /**
    * Timestamp of the reading
    */
    timestamp: TableReadRecord['timestamp'];
    /**
    * Temperature reading
    */
    temperature?: TableReadRecord['temperature'];
    /**
    * Humidity reading
    */
    humidity?: TableReadRecord['humidity'];
    /**
    * Pressure reading
    */
    pressure?: TableReadRecord['pressure'];
    /**
    * Array of numeric readings
    */
    readings?: TableReadRecord['readings'];
    /**
    * Whether an anomaly was detected
    */
    anomalyDetected?: TableReadRecord['anomalyDetected'];
    /**
    * Data quality score (1-10)
    */
    dataQuality?: TableReadRecord['dataQuality'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.time_series" table.
*/
export interface TimeSeriesInsertRecord {
    /**
    * Identifier of the sensor
    * @maxLen: 50
    */
    sensorId: TableInsertRecord['sensorId'];
    /**
    * Timestamp of the reading
    */
    timestamp: TableInsertRecord['timestamp'];
    /**
    * Temperature reading
    * @maxLen: 327682
    */
    temperature?: TableInsertRecord['temperature'];
    /**
    * Humidity reading
    * @maxLen: 327682
    */
    humidity?: TableInsertRecord['humidity'];
    /**
    * Pressure reading
    * @maxLen: 458754
    */
    pressure?: TableInsertRecord['pressure'];
    /**
    * Array of numeric readings
    */
    readings?: TableInsertRecord['readings'];
    /**
    * Whether an anomaly was detected
    * @default: false
    */
    anomalyDetected?: TableInsertRecord['anomalyDetected'];
    /**
    * Data quality score (1-10)
    */
    dataQuality?: TableInsertRecord['dataQuality'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.time_series" table.
*/
export type TimeSeriesUpdateRecord = Partial<TimeSeriesInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/user_sessions/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/user_sessions/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.user_sessions" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const UserSessionsTableReadSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    token_hash: z.string(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expires_at: z.date(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    last_used_at: z.date().nullable().optional(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ip_address: z.string().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    user_agent: z.string().nullable().optional(),
});

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents the raw database record without any transformations.
 */
export type UserSessionReadRecord = z.output<typeof UserSessionsTableReadSchema>;

/**
* The read transform function for the "public.user_sessions" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformUserSessionReadRecord = (data: UserSessionReadRecord): {
    id: UserSessionReadRecord['id'],
    userId?: UserSessionReadRecord['user_id'],
    tokenHash: UserSessionReadRecord['token_hash'],
    expiresAt: UserSessionReadRecord['expires_at'],
    createdAt?: UserSessionReadRecord['created_at'],
    lastUsedAt?: UserSessionReadRecord['last_used_at'],
    ipAddress?: UserSessionReadRecord['ip_address'],
    userAgent?: UserSessionReadRecord['user_agent'],
} => ({
    id: data.id,
    userId: data.user_id ?? undefined,
    tokenHash: data.token_hash,
    expiresAt: data.expires_at,
    createdAt: data.created_at ?? undefined,
    lastUsedAt: data.last_used_at ?? undefined,
    ipAddress: data.ip_address ?? undefined,
    userAgent: data.user_agent ?? undefined,
});

/**
 * The read schema for the "public.user_sessions" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const UserSessionsTableSchema = UserSessionsTableReadSchema.transform(transformUserSessionReadRecord);

/**
 * The base write schema for the "public.user_sessions" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const UserSessionsTableWriteSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    tokenHash: z.string().max(255),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiresAt: z.date(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    lastUsedAt: z.date().nullish().optional(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ipAddress: z.string().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    userAgent: z.string().nullish().optional(),
});

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof UserSessionsTableWriteSchema>;

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.user_sessions" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserSessionInsertRecord = (data: ): {
    id: ['id'],
    user_id?: ['userId'],
    token_hash: ['tokenHash'],
    expires_at: ['expiresAt'],
    created_at?: ['createdAt'],
    last_used_at?: ['lastUsedAt'],
    ip_address?: ['ipAddress'],
    user_agent?: ['userAgent'],
} => ({
    id: data.id,
    user_id: data.userId,
    token_hash: data.tokenHash,
    expires_at: data.expiresAt,
    created_at: data.createdAt,
    last_used_at: data.lastUsedAt,
    ip_address: data.ipAddress,
    user_agent: data.userAgent,
});

/**
 * The update transform function for the "public.user_sessions" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserSessionUpdateRecord = (data: ): {
    id: ['id'],
    user_id?: ['userId'],
    token_hash: ['tokenHash'],
    expires_at: ['expiresAt'],
    created_at?: ['createdAt'],
    last_used_at?: ['lastUsedAt'],
    ip_address?: ['ipAddress'],
    user_agent?: ['userAgent'],
} => ({
    id: data.id,
    user_id: data.userId,
    token_hash: data.tokenHash,
    expires_at: data.expiresAt,
    created_at: data.createdAt,
    last_used_at: data.lastUsedAt,
    ip_address: data.ipAddress,
    user_agent: data.userAgent,
});

/**
 * The insert schema for the "public.user_sessions" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const UserSessionsTableInsertSchema = UserSessionsTableWriteSchema.transform(transformUserSessionInsertRecord);

/**
 * The update schema for the "public.user_sessions" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const UserSessionsTableUpdateSchema = UserSessionsTableWriteSchema.partial().transform(transformUserSessionUpdateRecord);

type TableInsertRecord = z.input<typeof UserSessionsTableInsertSchema>;
type TableReadRecord = z.output<typeof UserSessionsTableSchema>;

/**
* Represents a database record from the "public.user_sessions" table.
*/
export interface UserSessionRecord {
    /**
    * Primary key for user sessions table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the user this session belongs to
    */
    userId?: TableReadRecord['userId'];
    /**
    * Hashed session token
    */
    tokenHash: TableReadRecord['tokenHash'];
    /**
    * Timestamp when the session expires
    */
    expiresAt: TableReadRecord['expiresAt'];
    /**
    * Timestamp when the session was created
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    * Timestamp when the session was last used
    */
    lastUsedAt?: TableReadRecord['lastUsedAt'];
    /**
    * IP address of the client
    */
    ipAddress?: TableReadRecord['ipAddress'];
    /**
    * User agent string of the client
    */
    userAgent?: TableReadRecord['userAgent'];
}

/**
* Represents an insertable database record from the "public.user_sessions" table.
*/
export interface UserSessionInsertRecord {
    /**
    * Primary key for user sessions table
    * @default: gen_random_uuid()
    */
    id: TableInsertRecord['id'];
    /**
    * ID of the user this session belongs to
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Hashed session token
    * @maxLen: 255
    */
    tokenHash: TableInsertRecord['tokenHash'];
    /**
    * Timestamp when the session expires
    */
    expiresAt: TableInsertRecord['expiresAt'];
    /**
    * Timestamp when the session was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    * Timestamp when the session was last used
    * @default: now()
    */
    lastUsedAt?: TableInsertRecord['lastUsedAt'];
    /**
    * IP address of the client
    */
    ipAddress?: TableInsertRecord['ipAddress'];
    /**
    * User agent string of the client
    */
    userAgent?: TableInsertRecord['userAgent'];
}

/**
* Represents an updateable database record from the "public.user_sessions" table.
*/
export type UserSessionUpdateRecord = Partial<UserSessionInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/users/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/users/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { UserProfileSchema } from '../../json.js';

export const USER_ROLES = ['admin', 'editor', 'viewer'] as const;

/**
 * The base read schema for the "public.users" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const UsersTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('users_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().nullable().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: UserProfileSchema.nullable().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullable().optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullable().optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents the raw database record without any transformations.
 */
export type UserReadRecord = z.output<typeof UsersTableReadSchema>;

/**
* The read transform function for the "public.users" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformUserReadRecord = (data: UserReadRecord): {
    id: UserReadRecord['id'],
    name: UserReadRecord['name'],
    email?: UserReadRecord['email'],
    status?: UserReadRecord['status'],
    profile?: UserReadRecord['profile'],
    createdAt?: UserReadRecord['created_at'],
    roles?: UserReadRecord['roles'],
    dates?: UserReadRecord['dates'],
} => ({
    id: data.id,
    name: data.name,
    email: data.email ?? undefined,
    status: data.status ?? undefined,
    profile: data.profile ?? undefined,
    createdAt: data.created_at ?? undefined,
    roles: data.roles ?? [],
    dates: data.dates ?? [],
});

/**
 * The read schema for the "public.users" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const UsersTableSchema = UsersTableReadSchema.transform(transformUserReadRecord);

/**
 * The base write schema for the "public.users" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const UsersTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().max(255).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().max(20).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: UserProfileSchema.nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish().optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type  = z.output<typeof UsersTableWriteSchema>;

/**
 * The base record type for the "public.users" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type  = Partial<>;

/**
 * The insert transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserInsertRecord = (data: ): {
    name: ['name'],
    email?: ['email'],
    status?: ['status'],
    profile?: ['profile'],
    created_at?: ['createdAt'],
    roles?: ['roles'],
    dates?: ['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: (data.profile ? JSON.stringify(data.profile) : data.profile),
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The update transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserUpdateRecord = (data: ): {
    name: ['name'],
    email?: ['email'],
    status?: ['status'],
    profile?: ['profile'],
    created_at?: ['createdAt'],
    roles?: ['roles'],
    dates?: ['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: (data.profile ? JSON.stringify(data.profile) : data.profile),
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The insert schema for the "public.users" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const UsersTableInsertSchema = UsersTableWriteSchema.transform(transformUserInsertRecord);

/**
 * The update schema for the "public.users" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const UsersTableUpdateSchema = UsersTableWriteSchema.partial().transform(transformUserUpdateRecord);

type TableInsertRecord = z.input<typeof UsersTableInsertSchema>;
type TableReadRecord = z.output<typeof UsersTableSchema>;
export type UserRole = (typeof USER_ROLES)[number];

/**
* Represents a database record from the "public.users" table.
*/
export interface UserRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    name: TableReadRecord['name'];
    /**
    */
    email?: TableReadRecord['email'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    */
    profile?: TableReadRecord['profile'];
    /**
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    */
    roles?: TableReadRecord['roles'];
    /**
    */
    dates?: TableReadRecord['dates'];
}

/**
* Represents an insertable database record from the "public.users" table.
*/
export interface UserInsertRecord {
    /**
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * @maxLen: 255
    */
    email?: TableInsertRecord['email'];
    /**
    * @maxLen: 20
    * @default: 'active'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    */
    profile?: TableInsertRecord['profile'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    */
    roles?: TableInsertRecord['roles'];
    /**
    */
    dates?: TableInsertRecord['dates'];
}

/**
* Represents an updateable database record from the "public.users" table.
*/
export type UserUpdateRecord = Partial<UserInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > types.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export type Table = 
    | 'audit_logs'
    | 'categories'
    | 'comments'
    | 'constraint_variations'
    | 'enum_tests'
    | 'files'
    | 'geographic_data'
    | 'inventory'
    | 'network_logs'
    | 'order_items'
    | 'orders'
    | 'post_categories'
    | 'posts'
    | 'products'
    | 'time_series'
    | 'user_sessions'
    | 'users'

export type Views = 
    | 'view_user_posts'

export type MaterializedViews = 
    | 'mv_user_posts'
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > views/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './view_user_posts/index.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > views/view_user_posts/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > views/view_user_posts/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.view_user_posts" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const ViewUserPostsReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullable().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    user_name: z.string().nullable().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.number().int().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_title: z.string().nullable().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_content: z.string().nullable().optional(),
});

/**
 * The base record type for the "public.view_user_posts" table.
 * This type represents the raw database record without any transformations.
 */
export type ViewUserPostReadRecord = z.output<typeof ViewUserPostsReadSchema>;

/**
* The read transform function for the "public.view_user_posts" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformViewUserPostReadRecord = (data: ViewUserPostReadRecord): {
    userId?: ViewUserPostReadRecord['user_id'],
    userName?: ViewUserPostReadRecord['user_name'],
    postId?: ViewUserPostReadRecord['post_id'],
    postTitle?: ViewUserPostReadRecord['post_title'],
    postContent?: ViewUserPostReadRecord['post_content'],
} => ({
    userId: data.user_id ?? undefined,
    userName: data.user_name ?? undefined,
    postId: data.post_id ?? undefined,
    postTitle: data.post_title ?? undefined,
    postContent: data.post_content ?? undefined,
});

/**
 * The read schema for the "public.view_user_posts" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const ViewUserPostsSchema = ViewUserPostsReadSchema.transform(transformViewUserPostReadRecord);

type TableReadRecord = z.output<typeof ViewUserPostsSchema>;

/**
* Represents a database record from the "public.view_user_posts" view.
*/
export interface ViewUserPostRecord {
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    userName?: TableReadRecord['userName'];
    /**
    */
    postId?: TableReadRecord['postId'];
    /**
    */
    postTitle?: TableReadRecord['postTitle'];
    /**
    */
    postContent?: TableReadRecord['postContent'];
}
"
`;
