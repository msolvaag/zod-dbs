// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > constants.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export const MV_USER_POSTS = 'mv_user_posts';
export const TABLE_AUDIT_LOGS = 'audit_logs';
export const TABLE_CATEGORIES = 'categories';
export const TABLE_COMMENTS = 'comments';
export const TABLE_CONSTRAINT_VARIATIONS = 'constraint_variations';
export const TABLE_ENUM_TESTS = 'enum_tests';
export const TABLE_FILES = 'files';
export const TABLE_GEOGRAPHIC_DATA = 'geographic_data';
export const TABLE_INVENTORY = 'inventory';
export const TABLE_NETWORK_LOGS = 'network_logs';
export const TABLE_ORDER_ITEMS = 'order_items';
export const TABLE_ORDERS = 'orders';
export const TABLE_POST_CATEGORIES = 'post_categories';
export const TABLE_POSTS = 'posts';
export const TABLE_PRODUCTS = 'products';
export const TABLE_TIME_SERIES = 'time_series';
export const TABLE_USER_SESSIONS = 'user_sessions';
export const TABLE_USERS = 'users';
export const VIEW_USER_POSTS = 'view_user_posts';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > materialized_views/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './mv_user_posts/index.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > materialized_views/mv_user_posts/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > materialized_views/mv_user_posts/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.mv_user_posts" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const MvUserPostsReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    user_name: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_title: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_content: z.string().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.mv_user_posts" table.
 * This type represents the raw database record without any transformations.
 */
export type MvUserPostReadBaseRecord = z.output<typeof MvUserPostsReadSchema>;

/**
* The read transform function for the "public.mv_user_posts" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformMvUserPostReadRecord = (data: MvUserPostReadBaseRecord): {
    userId?: MvUserPostReadBaseRecord['user_id'],
    userName?: MvUserPostReadBaseRecord['user_name'],
    postId?: MvUserPostReadBaseRecord['post_id'],
    postTitle?: MvUserPostReadBaseRecord['post_title'],
    postContent?: MvUserPostReadBaseRecord['post_content'],
} => ({
    userId: data.user_id,
    userName: data.user_name,
    postId: data.post_id,
    postTitle: data.post_title,
    postContent: data.post_content,
});

/**
 * The read schema for the "public.mv_user_posts" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const MvUserPostsSchema = MvUserPostsReadSchema.transform(transformMvUserPostReadRecord);

type TableReadRecord = z.output<typeof MvUserPostsSchema>;

/**
* Represents a database record from the "public.mv_user_posts" materialized_view.
*/
export interface MvUserPostRecord {
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    userName?: TableReadRecord['userName'];
    /**
    */
    postId?: TableReadRecord['postId'];
    /**
    */
    postTitle?: TableReadRecord['postTitle'];
    /**
    */
    postContent?: TableReadRecord['postContent'];
}
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/audit_logs/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/audit_logs/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { AuditLogOldValuesSchema, AuditLogNewValuesSchema } from '../../json.js';


/**
 * The base read schema for the "public.audit_logs" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const AuditLogsTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('audit_logs_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    action: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    table_name: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    record_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    old_values: AuditLogOldValuesSchema.nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    new_values: AuditLogNewValuesSchema.nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents the raw database record without any transformations.
 */
export type AuditLogReadBaseRecord = z.output<typeof AuditLogsTableReadSchema>;

/**
* The read transform function for the "public.audit_logs" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformAuditLogReadRecord = (data: AuditLogReadBaseRecord): {
    id: AuditLogReadBaseRecord['id'],
    userId?: AuditLogReadBaseRecord['user_id'],
    action: AuditLogReadBaseRecord['action'],
    tableName?: AuditLogReadBaseRecord['table_name'],
    recordId?: AuditLogReadBaseRecord['record_id'],
    oldValues?: AuditLogReadBaseRecord['old_values'],
    newValues?: AuditLogReadBaseRecord['new_values'],
    createdAt?: AuditLogReadBaseRecord['created_at'],
} => ({
    id: data.id,
    userId: data.user_id,
    action: data.action,
    tableName: data.table_name,
    recordId: data.record_id,
    oldValues: data.old_values,
    newValues: data.new_values,
    createdAt: data.created_at,
});

/**
 * The read schema for the "public.audit_logs" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const AuditLogsTableSchema = AuditLogsTableReadSchema.transform(transformAuditLogReadRecord);

/**
 * The base write schema for the "public.audit_logs" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const AuditLogsTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    action: z.string().max(50),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    tableName: z.string().max(50).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    recordId: z.number().int().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    oldValues: AuditLogOldValuesSchema.nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    newValues: AuditLogNewValuesSchema.nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type AuditLogInsertBaseRecord = z.output<typeof AuditLogsTableWriteSchema>;

/**
 * The base record type for the "public.audit_logs" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type AuditLogUpdateBaseRecord = Partial<AuditLogInsertBaseRecord>;

/**
 * The insert transform function for the "public.audit_logs" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformAuditLogInsertRecord = (data: AuditLogInsertBaseRecord): {
    user_id?: AuditLogInsertBaseRecord['userId'],
    action: AuditLogInsertBaseRecord['action'],
    table_name?: AuditLogInsertBaseRecord['tableName'],
    record_id?: AuditLogInsertBaseRecord['recordId'],
    old_values?: AuditLogInsertBaseRecord['oldValues'],
    new_values?: AuditLogInsertBaseRecord['newValues'],
    created_at?: AuditLogInsertBaseRecord['createdAt'],
} => ({
    user_id: data.userId,
    action: data.action,
    table_name: data.tableName,
    record_id: data.recordId,
    old_values: data.oldValues,
    new_values: data.newValues,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.audit_logs" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformAuditLogUpdateRecord = (data: AuditLogUpdateBaseRecord): {
    user_id?: AuditLogUpdateBaseRecord['userId'],
    action: AuditLogUpdateBaseRecord['action'],
    table_name?: AuditLogUpdateBaseRecord['tableName'],
    record_id?: AuditLogUpdateBaseRecord['recordId'],
    old_values?: AuditLogUpdateBaseRecord['oldValues'],
    new_values?: AuditLogUpdateBaseRecord['newValues'],
    created_at?: AuditLogUpdateBaseRecord['createdAt'],
} => ({
    user_id: data.userId,
    action: data.action,
    table_name: data.tableName,
    record_id: data.recordId,
    old_values: data.oldValues,
    new_values: data.newValues,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.audit_logs" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const AuditLogsTableInsertSchema = AuditLogsTableWriteSchema.transform(transformAuditLogInsertRecord);

/**
 * The update schema for the "public.audit_logs" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const AuditLogsTableUpdateSchema = AuditLogsTableWriteSchema.partial().transform(transformAuditLogUpdateRecord);

type TableInsertRecord = z.input<typeof AuditLogsTableInsertSchema>;
type TableReadRecord = z.output<typeof AuditLogsTableSchema>;

/**
* Represents a database record from the "public.audit_logs" table.
*/
export interface AuditLogRecord {
    /**
    * Primary key for audit logs table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the user who performed the action
    */
    userId?: TableReadRecord['userId'];
    /**
    * Type of action performed
    */
    action: TableReadRecord['action'];
    /**
    * Name of the table affected
    */
    tableName?: TableReadRecord['tableName'];
    /**
    * ID of the record affected
    */
    recordId?: TableReadRecord['recordId'];
    /**
    * Previous values before the change
    */
    oldValues?: TableReadRecord['oldValues'];
    /**
    * New values after the change
    */
    newValues?: TableReadRecord['newValues'];
    /**
    * Timestamp when the action was performed
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.audit_logs" table.
*/
export interface AuditLogInsertRecord {
    /**
    * ID of the user who performed the action
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Type of action performed
    * @maxLen: 50
    */
    action: TableInsertRecord['action'];
    /**
    * Name of the table affected
    * @maxLen: 50
    */
    tableName?: TableInsertRecord['tableName'];
    /**
    * ID of the record affected
    */
    recordId?: TableInsertRecord['recordId'];
    /**
    * Previous values before the change
    */
    oldValues?: TableInsertRecord['oldValues'];
    /**
    * New values after the change
    */
    newValues?: TableInsertRecord['newValues'];
    /**
    * Timestamp when the action was performed
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.audit_logs" table.
*/
export type AuditLogUpdateRecord = Partial<AuditLogInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/categories/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/categories/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.categories" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const CategoriesTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('categories_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.categories" table.
 * This type represents the raw database record without any transformations.
 */
export type CategoryReadBaseRecord = z.output<typeof CategoriesTableReadSchema>;

/**
* The read transform function for the "public.categories" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformCategoryReadRecord = (data: CategoryReadBaseRecord): {
    id: CategoryReadBaseRecord['id'],
    name: CategoryReadBaseRecord['name'],
    description?: CategoryReadBaseRecord['description'],
    color?: CategoryReadBaseRecord['color'],
    createdAt?: CategoryReadBaseRecord['created_at'],
} => ({
    id: data.id,
    name: data.name,
    description: data.description,
    color: data.color,
    createdAt: data.created_at,
});

/**
 * The read schema for the "public.categories" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const CategoriesTableSchema = CategoriesTableReadSchema.transform(transformCategoryReadRecord);

/**
 * The base write schema for the "public.categories" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const CategoriesTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.string().max(7).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.categories" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type CategoryInsertBaseRecord = z.output<typeof CategoriesTableWriteSchema>;

/**
 * The base record type for the "public.categories" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type CategoryUpdateBaseRecord = Partial<CategoryInsertBaseRecord>;

/**
 * The insert transform function for the "public.categories" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformCategoryInsertRecord = (data: CategoryInsertBaseRecord): {
    name: CategoryInsertBaseRecord['name'],
    description?: CategoryInsertBaseRecord['description'],
    color?: CategoryInsertBaseRecord['color'],
    created_at?: CategoryInsertBaseRecord['createdAt'],
} => ({
    name: data.name,
    description: data.description,
    color: data.color,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.categories" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformCategoryUpdateRecord = (data: CategoryUpdateBaseRecord): {
    name: CategoryUpdateBaseRecord['name'],
    description?: CategoryUpdateBaseRecord['description'],
    color?: CategoryUpdateBaseRecord['color'],
    created_at?: CategoryUpdateBaseRecord['createdAt'],
} => ({
    name: data.name,
    description: data.description,
    color: data.color,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.categories" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const CategoriesTableInsertSchema = CategoriesTableWriteSchema.transform(transformCategoryInsertRecord);

/**
 * The update schema for the "public.categories" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const CategoriesTableUpdateSchema = CategoriesTableWriteSchema.partial().transform(transformCategoryUpdateRecord);

type TableInsertRecord = z.input<typeof CategoriesTableInsertSchema>;
type TableReadRecord = z.output<typeof CategoriesTableSchema>;

/**
* Represents a database record from the "public.categories" table.
*/
export interface CategoryRecord {
    /**
    * Primary key for categories table
    */
    id: TableReadRecord['id'];
    /**
    * Name of the category
    */
    name: TableReadRecord['name'];
    /**
    * Description of the category
    */
    description?: TableReadRecord['description'];
    /**
    * Hex color code for the category
    */
    color?: TableReadRecord['color'];
    /**
    * Timestamp when the category was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.categories" table.
*/
export interface CategoryInsertRecord {
    /**
    * Name of the category
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * Description of the category
    */
    description?: TableInsertRecord['description'];
    /**
    * Hex color code for the category
    * @maxLen: 7
    */
    color?: TableInsertRecord['color'];
    /**
    * Timestamp when the category was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.categories" table.
*/
export type CategoryUpdateRecord = Partial<CategoryInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/comments/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/comments/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.comments" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const CommentsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('comments_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    parent_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    is_approved: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.comments" table.
 * This type represents the raw database record without any transformations.
 */
export type CommentReadBaseRecord = z.output<typeof CommentsTableReadSchema>;

/**
* The read transform function for the "public.comments" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformCommentReadRecord = (data: CommentReadBaseRecord): {
    id: CommentReadBaseRecord['id'],
    postId?: CommentReadBaseRecord['post_id'],
    userId?: CommentReadBaseRecord['user_id'],
    parentId?: CommentReadBaseRecord['parent_id'],
    content: CommentReadBaseRecord['content'],
    isApproved?: CommentReadBaseRecord['is_approved'],
    createdAt?: CommentReadBaseRecord['created_at'],
    updatedAt?: CommentReadBaseRecord['updated_at'],
} => ({
    id: data.id,
    postId: data.post_id,
    userId: data.user_id,
    parentId: data.parent_id,
    content: data.content,
    isApproved: data.is_approved,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
});

/**
 * The read schema for the "public.comments" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const CommentsTableSchema = CommentsTableReadSchema.transform(transformCommentReadRecord);

/**
 * The base write schema for the "public.comments" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const CommentsTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    postId: z.number().int().nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    parentId: z.number().int().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    isApproved: z.boolean().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.comments" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type CommentInsertBaseRecord = z.output<typeof CommentsTableWriteSchema>;

/**
 * The base record type for the "public.comments" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type CommentUpdateBaseRecord = Partial<CommentInsertBaseRecord>;

/**
 * The insert transform function for the "public.comments" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformCommentInsertRecord = (data: CommentInsertBaseRecord): {
    post_id?: CommentInsertBaseRecord['postId'],
    user_id?: CommentInsertBaseRecord['userId'],
    parent_id?: CommentInsertBaseRecord['parentId'],
    content: CommentInsertBaseRecord['content'],
    is_approved?: CommentInsertBaseRecord['isApproved'],
    created_at?: CommentInsertBaseRecord['createdAt'],
    updated_at?: CommentInsertBaseRecord['updatedAt'],
} => ({
    post_id: data.postId,
    user_id: data.userId,
    parent_id: data.parentId,
    content: data.content,
    is_approved: data.isApproved,
    created_at: data.createdAt,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.comments" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformCommentUpdateRecord = (data: CommentUpdateBaseRecord): {
    post_id?: CommentUpdateBaseRecord['postId'],
    user_id?: CommentUpdateBaseRecord['userId'],
    parent_id?: CommentUpdateBaseRecord['parentId'],
    content: CommentUpdateBaseRecord['content'],
    is_approved?: CommentUpdateBaseRecord['isApproved'],
    created_at?: CommentUpdateBaseRecord['createdAt'],
    updated_at?: CommentUpdateBaseRecord['updatedAt'],
} => ({
    post_id: data.postId,
    user_id: data.userId,
    parent_id: data.parentId,
    content: data.content,
    is_approved: data.isApproved,
    created_at: data.createdAt,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.comments" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const CommentsTableInsertSchema = CommentsTableWriteSchema.transform(transformCommentInsertRecord);

/**
 * The update schema for the "public.comments" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const CommentsTableUpdateSchema = CommentsTableWriteSchema.partial().transform(transformCommentUpdateRecord);

type TableInsertRecord = z.input<typeof CommentsTableInsertSchema>;
type TableReadRecord = z.output<typeof CommentsTableSchema>;

/**
* Represents a database record from the "public.comments" table.
*/
export interface CommentRecord {
    /**
    * Primary key for comments table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the post this comment belongs to
    */
    postId?: TableReadRecord['postId'];
    /**
    * ID of the user who wrote the comment
    */
    userId?: TableReadRecord['userId'];
    /**
    * ID of the parent comment for nested comments
    */
    parentId?: TableReadRecord['parentId'];
    /**
    * Content of the comment
    */
    content: TableReadRecord['content'];
    /**
    * Whether the comment has been approved by moderators
    */
    isApproved?: TableReadRecord['isApproved'];
    /**
    * Timestamp when the comment was created
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    * Timestamp when the comment was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.comments" table.
*/
export interface CommentInsertRecord {
    /**
    * ID of the post this comment belongs to
    */
    postId?: TableInsertRecord['postId'];
    /**
    * ID of the user who wrote the comment
    */
    userId?: TableInsertRecord['userId'];
    /**
    * ID of the parent comment for nested comments
    */
    parentId?: TableInsertRecord['parentId'];
    /**
    * Content of the comment
    */
    content: TableInsertRecord['content'];
    /**
    * Whether the comment has been approved by moderators
    * @default: false
    */
    isApproved?: TableInsertRecord['isApproved'];
    /**
    * Timestamp when the comment was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    * Timestamp when the comment was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.comments" table.
*/
export type CommentUpdateRecord = Partial<CommentInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/constraint_variations/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/constraint_variations/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const CONSTRAINT_VARIATION_ANIMALS = ['cat', 'dog', 'bird', 'fish'] as const;
export const CONSTRAINT_VARIATION_FRUITS = ['apple', 'banana', 'orange', 'grape'] as const;
export const CONSTRAINT_VARIATION_VEHICLES = ['car', 'truck', 'motorcycle', 'bicycle'] as const;
export const CONSTRAINT_VARIATION_LANGUAGES = ['en', 'es', 'fr', 'de', 'it'] as const;
export const CONSTRAINT_VARIATION_ACTIVE_STATUSES = ['true', 'false'] as const;

/**
 * The base read schema for the "public.constraint_variations" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const ConstraintVariationsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('constraint_variations_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    animal: z.enum(CONSTRAINT_VARIATION_ANIMALS).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    fruit: z.enum(CONSTRAINT_VARIATION_FRUITS).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    vehicle: z.enum(CONSTRAINT_VARIATION_VEHICLES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    language: z.enum(CONSTRAINT_VARIATION_LANGUAGES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    rating: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bool
    * defaultValue: 
    */
    active_status: z.enum(CONSTRAINT_VARIATION_ACTIVE_STATUSES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents the raw database record without any transformations.
 */
export type ConstraintVariationReadBaseRecord = z.output<typeof ConstraintVariationsTableReadSchema>;

/**
* The read transform function for the "public.constraint_variations" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformConstraintVariationReadRecord = (data: ConstraintVariationReadBaseRecord): {
    id: ConstraintVariationReadBaseRecord['id'],
    animal?: ConstraintVariationReadBaseRecord['animal'],
    fruit?: ConstraintVariationReadBaseRecord['fruit'],
    vehicle?: ConstraintVariationReadBaseRecord['vehicle'],
    language?: ConstraintVariationReadBaseRecord['language'],
    rating?: ConstraintVariationReadBaseRecord['rating'],
    activeStatus?: ConstraintVariationReadBaseRecord['active_status'],
    createdAt?: ConstraintVariationReadBaseRecord['created_at'],
} => ({
    id: data.id,
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    activeStatus: data.active_status,
    createdAt: data.created_at,
});

/**
 * The read schema for the "public.constraint_variations" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const ConstraintVariationsTableSchema = ConstraintVariationsTableReadSchema.transform(transformConstraintVariationReadRecord);

/**
 * The base write schema for the "public.constraint_variations" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const ConstraintVariationsTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    animal: z.enum(CONSTRAINT_VARIATION_ANIMALS).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    fruit: z.enum(CONSTRAINT_VARIATION_FRUITS).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    vehicle: z.enum(CONSTRAINT_VARIATION_VEHICLES).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    language: z.enum(CONSTRAINT_VARIATION_LANGUAGES).nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    rating: z.number().int().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: 
    */
    activeStatus: z.enum(CONSTRAINT_VARIATION_ACTIVE_STATUSES).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type ConstraintVariationInsertBaseRecord = z.output<typeof ConstraintVariationsTableWriteSchema>;

/**
 * The base record type for the "public.constraint_variations" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type ConstraintVariationUpdateBaseRecord = Partial<ConstraintVariationInsertBaseRecord>;

/**
 * The insert transform function for the "public.constraint_variations" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformConstraintVariationInsertRecord = (data: ConstraintVariationInsertBaseRecord): {
    animal?: ConstraintVariationInsertBaseRecord['animal'],
    fruit?: ConstraintVariationInsertBaseRecord['fruit'],
    vehicle?: ConstraintVariationInsertBaseRecord['vehicle'],
    language?: ConstraintVariationInsertBaseRecord['language'],
    rating?: ConstraintVariationInsertBaseRecord['rating'],
    active_status?: ConstraintVariationInsertBaseRecord['activeStatus'],
    created_at?: ConstraintVariationInsertBaseRecord['createdAt'],
} => ({
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    active_status: data.activeStatus,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.constraint_variations" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformConstraintVariationUpdateRecord = (data: ConstraintVariationUpdateBaseRecord): {
    animal?: ConstraintVariationUpdateBaseRecord['animal'],
    fruit?: ConstraintVariationUpdateBaseRecord['fruit'],
    vehicle?: ConstraintVariationUpdateBaseRecord['vehicle'],
    language?: ConstraintVariationUpdateBaseRecord['language'],
    rating?: ConstraintVariationUpdateBaseRecord['rating'],
    active_status?: ConstraintVariationUpdateBaseRecord['activeStatus'],
    created_at?: ConstraintVariationUpdateBaseRecord['createdAt'],
} => ({
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    active_status: data.activeStatus,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.constraint_variations" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const ConstraintVariationsTableInsertSchema = ConstraintVariationsTableWriteSchema.transform(transformConstraintVariationInsertRecord);

/**
 * The update schema for the "public.constraint_variations" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const ConstraintVariationsTableUpdateSchema = ConstraintVariationsTableWriteSchema.partial().transform(transformConstraintVariationUpdateRecord);

type TableInsertRecord = z.input<typeof ConstraintVariationsTableInsertSchema>;
type TableReadRecord = z.output<typeof ConstraintVariationsTableSchema>;
export type ConstraintVariationAnimal = (typeof CONSTRAINT_VARIATION_ANIMALS)[number];
export type ConstraintVariationFruit = (typeof CONSTRAINT_VARIATION_FRUITS)[number];
export type ConstraintVariationVehicle = (typeof CONSTRAINT_VARIATION_VEHICLES)[number];
export type ConstraintVariationLanguage = (typeof CONSTRAINT_VARIATION_LANGUAGES)[number];
export type ConstraintVariationActiveStatus = (typeof CONSTRAINT_VARIATION_ACTIVE_STATUSES)[number];

/**
* Represents a database record from the "public.constraint_variations" table.
*/
export interface ConstraintVariationRecord {
    /**
    * Primary key for constraint variations table
    */
    id: TableReadRecord['id'];
    /**
    * Type of animal
    */
    animal?: TableReadRecord['animal'];
    /**
    * Type of fruit
    */
    fruit?: TableReadRecord['fruit'];
    /**
    * Type of vehicle
    */
    vehicle?: TableReadRecord['vehicle'];
    /**
    * Language code
    */
    language?: TableReadRecord['language'];
    /**
    * Rating score (1-5)
    */
    rating?: TableReadRecord['rating'];
    /**
    * Whether the item is active
    */
    activeStatus?: TableReadRecord['activeStatus'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.constraint_variations" table.
*/
export interface ConstraintVariationInsertRecord {
    /**
    * Type of animal
    * @maxLen: 20
    */
    animal?: TableInsertRecord['animal'];
    /**
    * Type of fruit
    */
    fruit?: TableInsertRecord['fruit'];
    /**
    * Type of vehicle
    * @maxLen: 15
    */
    vehicle?: TableInsertRecord['vehicle'];
    /**
    * Language code
    * @maxLen: 2
    */
    language?: TableInsertRecord['language'];
    /**
    * Rating score (1-5)
    */
    rating?: TableInsertRecord['rating'];
    /**
    * Whether the item is active
    */
    activeStatus?: TableInsertRecord['activeStatus'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.constraint_variations" table.
*/
export type ConstraintVariationUpdateRecord = Partial<ConstraintVariationInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/enum_tests/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/enum_tests/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const ENUM_TEST_PRIORITIES = ['low', 'medium', 'high', 'critical'] as const;
export const ENUM_TEST_COLORS = ['red', 'green', 'blue', 'yellow'] as const;
export const ENUM_TEST_SIZES = ['xs', 's', 'm', 'l', 'xl', 'xxl'] as const;
export const ENUM_TEST_GRADES = ['A', 'B', 'C', 'D', 'F'] as const;
export const ENUM_TEST_CATEGORIES = ['electronics', 'clothing', 'books', 'home-garden'] as const;
export const ENUM_TEST_MOODS = ['happy', 'sad', 'angry', 'excited', 'calm'] as const;
export const ENUM_TEST_DIRECTIONS = ['north', 'south', 'east', 'west'] as const;
export const ENUM_TEST_WEATHER_CONDITIONS = ['sunny', 'cloudy', 'rainy', 'snowy', 'foggy'] as const;
export const ENUM_TEST_TASK_STATUSES = ['todo', 'in-progress', 'done', 'cancelled'] as const;
export const ENUM_TEST_DIFFICULTIES = ['1', '2', '3', '4', '5'] as const;
export const ENUM_TEST_WEEKDAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const;
export const ENUM_TEST_PAYMENT_METHODS = ['cash', 'credit-card', 'debit-card', 'paypal', 'bank-transfer'] as const;

/**
 * The base read schema for the "public.enum_tests" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const EnumTestsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('enum_tests_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    priority: z.enum(ENUM_TEST_PRIORITIES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.enum(ENUM_TEST_COLORS).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    size: z.enum(ENUM_TEST_SIZES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    grade: z.enum(ENUM_TEST_GRADES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    category: z.enum(ENUM_TEST_CATEGORIES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    mood: z.enum(ENUM_TEST_MOODS).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    direction: z.enum(ENUM_TEST_DIRECTIONS).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    weather_condition: z.enum(ENUM_TEST_WEATHER_CONDITIONS).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    task_status: z.enum(ENUM_TEST_TASK_STATUSES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    difficulty: z.enum(ENUM_TEST_DIFFICULTIES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    weekday: z.enum(ENUM_TEST_WEEKDAYS).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    payment_method: z.enum(ENUM_TEST_PAYMENT_METHODS).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents the raw database record without any transformations.
 */
export type EnumTestReadBaseRecord = z.output<typeof EnumTestsTableReadSchema>;

/**
* The read transform function for the "public.enum_tests" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformEnumTestReadRecord = (data: EnumTestReadBaseRecord): {
    id: EnumTestReadBaseRecord['id'],
    priority?: EnumTestReadBaseRecord['priority'],
    color?: EnumTestReadBaseRecord['color'],
    size?: EnumTestReadBaseRecord['size'],
    grade?: EnumTestReadBaseRecord['grade'],
    category?: EnumTestReadBaseRecord['category'],
    mood?: EnumTestReadBaseRecord['mood'],
    direction?: EnumTestReadBaseRecord['direction'],
    weatherCondition?: EnumTestReadBaseRecord['weather_condition'],
    taskStatus?: EnumTestReadBaseRecord['task_status'],
    difficulty?: EnumTestReadBaseRecord['difficulty'],
    weekday?: EnumTestReadBaseRecord['weekday'],
    paymentMethod?: EnumTestReadBaseRecord['payment_method'],
    createdAt?: EnumTestReadBaseRecord['created_at'],
} => ({
    id: data.id,
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weatherCondition: data.weather_condition,
    taskStatus: data.task_status,
    difficulty: data.difficulty,
    weekday: data.weekday,
    paymentMethod: data.payment_method,
    createdAt: data.created_at,
});

/**
 * The read schema for the "public.enum_tests" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const EnumTestsTableSchema = EnumTestsTableReadSchema.transform(transformEnumTestReadRecord);

/**
 * The base write schema for the "public.enum_tests" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const EnumTestsTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    priority: z.enum(ENUM_TEST_PRIORITIES).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.enum(ENUM_TEST_COLORS).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    size: z.enum(ENUM_TEST_SIZES).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    grade: z.enum(ENUM_TEST_GRADES).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    category: z.enum(ENUM_TEST_CATEGORIES).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    mood: z.enum(ENUM_TEST_MOODS).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    direction: z.enum(ENUM_TEST_DIRECTIONS).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    weatherCondition: z.enum(ENUM_TEST_WEATHER_CONDITIONS).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    taskStatus: z.enum(ENUM_TEST_TASK_STATUSES).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    difficulty: z.enum(ENUM_TEST_DIFFICULTIES).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    weekday: z.enum(ENUM_TEST_WEEKDAYS).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    paymentMethod: z.enum(ENUM_TEST_PAYMENT_METHODS).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type EnumTestInsertBaseRecord = z.output<typeof EnumTestsTableWriteSchema>;

/**
 * The base record type for the "public.enum_tests" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type EnumTestUpdateBaseRecord = Partial<EnumTestInsertBaseRecord>;

/**
 * The insert transform function for the "public.enum_tests" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformEnumTestInsertRecord = (data: EnumTestInsertBaseRecord): {
    priority?: EnumTestInsertBaseRecord['priority'],
    color?: EnumTestInsertBaseRecord['color'],
    size?: EnumTestInsertBaseRecord['size'],
    grade?: EnumTestInsertBaseRecord['grade'],
    category?: EnumTestInsertBaseRecord['category'],
    mood?: EnumTestInsertBaseRecord['mood'],
    direction?: EnumTestInsertBaseRecord['direction'],
    weather_condition?: EnumTestInsertBaseRecord['weatherCondition'],
    task_status?: EnumTestInsertBaseRecord['taskStatus'],
    difficulty?: EnumTestInsertBaseRecord['difficulty'],
    weekday?: EnumTestInsertBaseRecord['weekday'],
    payment_method?: EnumTestInsertBaseRecord['paymentMethod'],
    created_at?: EnumTestInsertBaseRecord['createdAt'],
} => ({
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weather_condition: data.weatherCondition,
    task_status: data.taskStatus,
    difficulty: data.difficulty,
    weekday: data.weekday,
    payment_method: data.paymentMethod,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.enum_tests" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformEnumTestUpdateRecord = (data: EnumTestUpdateBaseRecord): {
    priority?: EnumTestUpdateBaseRecord['priority'],
    color?: EnumTestUpdateBaseRecord['color'],
    size?: EnumTestUpdateBaseRecord['size'],
    grade?: EnumTestUpdateBaseRecord['grade'],
    category?: EnumTestUpdateBaseRecord['category'],
    mood?: EnumTestUpdateBaseRecord['mood'],
    direction?: EnumTestUpdateBaseRecord['direction'],
    weather_condition?: EnumTestUpdateBaseRecord['weatherCondition'],
    task_status?: EnumTestUpdateBaseRecord['taskStatus'],
    difficulty?: EnumTestUpdateBaseRecord['difficulty'],
    weekday?: EnumTestUpdateBaseRecord['weekday'],
    payment_method?: EnumTestUpdateBaseRecord['paymentMethod'],
    created_at?: EnumTestUpdateBaseRecord['createdAt'],
} => ({
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weather_condition: data.weatherCondition,
    task_status: data.taskStatus,
    difficulty: data.difficulty,
    weekday: data.weekday,
    payment_method: data.paymentMethod,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.enum_tests" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const EnumTestsTableInsertSchema = EnumTestsTableWriteSchema.transform(transformEnumTestInsertRecord);

/**
 * The update schema for the "public.enum_tests" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const EnumTestsTableUpdateSchema = EnumTestsTableWriteSchema.partial().transform(transformEnumTestUpdateRecord);

type TableInsertRecord = z.input<typeof EnumTestsTableInsertSchema>;
type TableReadRecord = z.output<typeof EnumTestsTableSchema>;
export type EnumTestPriority = (typeof ENUM_TEST_PRIORITIES)[number];
export type EnumTestColor = (typeof ENUM_TEST_COLORS)[number];
export type EnumTestSize = (typeof ENUM_TEST_SIZES)[number];
export type EnumTestGrade = (typeof ENUM_TEST_GRADES)[number];
export type EnumTestCategory = (typeof ENUM_TEST_CATEGORIES)[number];
export type EnumTestMood = (typeof ENUM_TEST_MOODS)[number];
export type EnumTestDirection = (typeof ENUM_TEST_DIRECTIONS)[number];
export type EnumTestWeatherCondition = (typeof ENUM_TEST_WEATHER_CONDITIONS)[number];
export type EnumTestTaskStatus = (typeof ENUM_TEST_TASK_STATUSES)[number];
export type EnumTestDifficulty = (typeof ENUM_TEST_DIFFICULTIES)[number];
export type EnumTestWeekday = (typeof ENUM_TEST_WEEKDAYS)[number];
export type EnumTestPaymentMethod = (typeof ENUM_TEST_PAYMENT_METHODS)[number];

/**
* Represents a database record from the "public.enum_tests" table.
*/
export interface EnumTestRecord {
    /**
    * Primary key for enum tests table
    */
    id: TableReadRecord['id'];
    /**
    * Task priority level
    */
    priority?: TableReadRecord['priority'];
    /**
    * Color selection
    */
    color?: TableReadRecord['color'];
    /**
    * Size option
    */
    size?: TableReadRecord['size'];
    /**
    * Letter grade
    */
    grade?: TableReadRecord['grade'];
    /**
    * Product category
    */
    category?: TableReadRecord['category'];
    /**
    * Current mood state
    */
    mood?: TableReadRecord['mood'];
    /**
    * Compass direction
    */
    direction?: TableReadRecord['direction'];
    /**
    * Current weather condition
    */
    weatherCondition?: TableReadRecord['weatherCondition'];
    /**
    * Status of the task
    */
    taskStatus?: TableReadRecord['taskStatus'];
    /**
    * Difficulty level (1-5)
    */
    difficulty?: TableReadRecord['difficulty'];
    /**
    * Day of the week
    */
    weekday?: TableReadRecord['weekday'];
    /**
    * Payment method used
    */
    paymentMethod?: TableReadRecord['paymentMethod'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.enum_tests" table.
*/
export interface EnumTestInsertRecord {
    /**
    * Task priority level
    * @maxLen: 10
    */
    priority?: TableInsertRecord['priority'];
    /**
    * Color selection
    * @maxLen: 20
    */
    color?: TableInsertRecord['color'];
    /**
    * Size option
    */
    size?: TableInsertRecord['size'];
    /**
    * Letter grade
    * @maxLen: 1
    */
    grade?: TableInsertRecord['grade'];
    /**
    * Product category
    * @maxLen: 30
    */
    category?: TableInsertRecord['category'];
    /**
    * Current mood state
    */
    mood?: TableInsertRecord['mood'];
    /**
    * Compass direction
    * @maxLen: 10
    */
    direction?: TableInsertRecord['direction'];
    /**
    * Current weather condition
    */
    weatherCondition?: TableInsertRecord['weatherCondition'];
    /**
    * Status of the task
    * @maxLen: 20
    */
    taskStatus?: TableInsertRecord['taskStatus'];
    /**
    * Difficulty level (1-5)
    */
    difficulty?: TableInsertRecord['difficulty'];
    /**
    * Day of the week
    * @maxLen: 10
    */
    weekday?: TableInsertRecord['weekday'];
    /**
    * Payment method used
    */
    paymentMethod?: TableInsertRecord['paymentMethod'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.enum_tests" table.
*/
export type EnumTestUpdateRecord = Partial<EnumTestInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/files/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/files/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { FileMetadataSchema } from '../../json.js';


/**
 * The base read schema for the "public.files" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const FilesTableReadSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    file_path: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    file_size: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mime_type: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binary_data: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    is_encrypted: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    upload_time: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiry_date: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: FileMetadataSchema.nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().transform((value) => value ?? []).optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    access_count: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.files" table.
 * This type represents the raw database record without any transformations.
 */
export type FileReadBaseRecord = z.output<typeof FilesTableReadSchema>;

/**
* The read transform function for the "public.files" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformFileReadRecord = (data: FileReadBaseRecord): {
    id: FileReadBaseRecord['id'],
    filename: FileReadBaseRecord['filename'],
    filePath: FileReadBaseRecord['file_path'],
    fileSize: FileReadBaseRecord['file_size'],
    mimeType?: FileReadBaseRecord['mime_type'],
    checksum?: FileReadBaseRecord['checksum'],
    binaryData?: FileReadBaseRecord['binary_data'],
    isEncrypted?: FileReadBaseRecord['is_encrypted'],
    uploadTime?: FileReadBaseRecord['upload_time'],
    expiryDate?: FileReadBaseRecord['expiry_date'],
    metadata?: FileReadBaseRecord['metadata'],
    tags?: FileReadBaseRecord['tags'],
    accessCount?: FileReadBaseRecord['access_count'],
} => ({
    id: data.id,
    filename: data.filename,
    filePath: data.file_path,
    fileSize: data.file_size,
    mimeType: data.mime_type,
    checksum: data.checksum,
    binaryData: data.binary_data,
    isEncrypted: data.is_encrypted,
    uploadTime: data.upload_time,
    expiryDate: data.expiry_date,
    metadata: data.metadata,
    tags: data.tags,
    accessCount: data.access_count,
});

/**
 * The read schema for the "public.files" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const FilesTableSchema = FilesTableReadSchema.transform(transformFileReadRecord);

/**
 * The base write schema for the "public.files" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const FilesTableWriteSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string().max(255),
    /**
    * dataType: text
    * defaultValue: 
    */
    filePath: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    fileSize: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mimeType: z.string().max(100).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().max(64).nullish().optional(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binaryData: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    isEncrypted: z.boolean().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    uploadTime: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiryDate: z.date().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: FileMetadataSchema.nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    accessCount: z.number().int().nullish().optional(),
});

/**
 * The base record type for the "public.files" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type FileInsertBaseRecord = z.output<typeof FilesTableWriteSchema>;

/**
 * The base record type for the "public.files" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type FileUpdateBaseRecord = Partial<FileInsertBaseRecord>;

/**
 * The insert transform function for the "public.files" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformFileInsertRecord = (data: FileInsertBaseRecord): {
    id: FileInsertBaseRecord['id'],
    filename: FileInsertBaseRecord['filename'],
    file_path: FileInsertBaseRecord['filePath'],
    file_size: FileInsertBaseRecord['fileSize'],
    mime_type?: FileInsertBaseRecord['mimeType'],
    checksum?: FileInsertBaseRecord['checksum'],
    binary_data?: FileInsertBaseRecord['binaryData'],
    is_encrypted?: FileInsertBaseRecord['isEncrypted'],
    upload_time?: FileInsertBaseRecord['uploadTime'],
    expiry_date?: FileInsertBaseRecord['expiryDate'],
    metadata?: FileInsertBaseRecord['metadata'],
    tags?: FileInsertBaseRecord['tags'],
    access_count?: FileInsertBaseRecord['accessCount'],
} => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: data.metadata,
    tags: data.tags,
    access_count: data.accessCount,
});

/**
 * The update transform function for the "public.files" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformFileUpdateRecord = (data: FileUpdateBaseRecord): {
    id: FileUpdateBaseRecord['id'],
    filename: FileUpdateBaseRecord['filename'],
    file_path: FileUpdateBaseRecord['filePath'],
    file_size: FileUpdateBaseRecord['fileSize'],
    mime_type?: FileUpdateBaseRecord['mimeType'],
    checksum?: FileUpdateBaseRecord['checksum'],
    binary_data?: FileUpdateBaseRecord['binaryData'],
    is_encrypted?: FileUpdateBaseRecord['isEncrypted'],
    upload_time?: FileUpdateBaseRecord['uploadTime'],
    expiry_date?: FileUpdateBaseRecord['expiryDate'],
    metadata?: FileUpdateBaseRecord['metadata'],
    tags?: FileUpdateBaseRecord['tags'],
    access_count?: FileUpdateBaseRecord['accessCount'],
} => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: data.metadata,
    tags: data.tags,
    access_count: data.accessCount,
});

/**
 * The insert schema for the "public.files" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const FilesTableInsertSchema = FilesTableWriteSchema.transform(transformFileInsertRecord);

/**
 * The update schema for the "public.files" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const FilesTableUpdateSchema = FilesTableWriteSchema.partial().transform(transformFileUpdateRecord);

type TableInsertRecord = z.input<typeof FilesTableInsertSchema>;
type TableReadRecord = z.output<typeof FilesTableSchema>;

/**
* Represents a database record from the "public.files" table.
*/
export interface FileRecord {
    /**
    * Primary key for files table
    */
    id: TableReadRecord['id'];
    /**
    * Original filename
    */
    filename: TableReadRecord['filename'];
    /**
    * Path to the file
    */
    filePath: TableReadRecord['filePath'];
    /**
    * Size of the file in bytes
    */
    fileSize: TableReadRecord['fileSize'];
    /**
    * MIME type of the file
    */
    mimeType?: TableReadRecord['mimeType'];
    /**
    * SHA-256 checksum of the file
    */
    checksum?: TableReadRecord['checksum'];
    /**
    * Binary data of the file
    */
    binaryData?: TableReadRecord['binaryData'];
    /**
    * Whether the file is encrypted
    */
    isEncrypted?: TableReadRecord['isEncrypted'];
    /**
    * Timestamp when file was uploaded
    */
    uploadTime?: TableReadRecord['uploadTime'];
    /**
    * Expiry date of the file
    */
    expiryDate?: TableReadRecord['expiryDate'];
    /**
    * File metadata in JSON format
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Array of file tags
    */
    tags?: TableReadRecord['tags'];
    /**
    * Number of times file was accessed
    */
    accessCount?: TableReadRecord['accessCount'];
}

/**
* Represents an insertable database record from the "public.files" table.
*/
export interface FileInsertRecord {
    /**
    * Primary key for files table
    * @default: gen_random_uuid()
    */
    id: TableInsertRecord['id'];
    /**
    * Original filename
    * @maxLen: 255
    */
    filename: TableInsertRecord['filename'];
    /**
    * Path to the file
    */
    filePath: TableInsertRecord['filePath'];
    /**
    * Size of the file in bytes
    */
    fileSize: TableInsertRecord['fileSize'];
    /**
    * MIME type of the file
    * @maxLen: 100
    */
    mimeType?: TableInsertRecord['mimeType'];
    /**
    * SHA-256 checksum of the file
    * @maxLen: 64
    */
    checksum?: TableInsertRecord['checksum'];
    /**
    * Binary data of the file
    */
    binaryData?: TableInsertRecord['binaryData'];
    /**
    * Whether the file is encrypted
    * @default: false
    */
    isEncrypted?: TableInsertRecord['isEncrypted'];
    /**
    * Timestamp when file was uploaded
    * @default: now()
    */
    uploadTime?: TableInsertRecord['uploadTime'];
    /**
    * Expiry date of the file
    */
    expiryDate?: TableInsertRecord['expiryDate'];
    /**
    * File metadata in JSON format
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Array of file tags
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Number of times file was accessed
    * @default: 0
    */
    accessCount?: TableInsertRecord['accessCount'];
}

/**
* Represents an updateable database record from the "public.files" table.
*/
export type FileUpdateRecord = Partial<FileInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/geographic_data/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/geographic_data/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.geographic_data" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const GeographicDataTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('geographic_data_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    location_name: z.string(),
    /**
    * dataType: point
    * defaultValue: 
    */
    coordinates: z.string(),
    /**
    * dataType: polygon
    * defaultValue: 
    */
    boundary: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: circle
    * defaultValue: 
    */
    area_circle: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    elevation: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    timezone: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    country_code: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    postal_codes: z.array(z.string()).nullish().transform((value) => value ?? []).optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    population: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    established_date: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    last_updated: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents the raw database record without any transformations.
 */
export type GeographicDataReadBaseRecord = z.output<typeof GeographicDataTableReadSchema>;

/**
* The read transform function for the "public.geographic_data" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformGeographicDataReadRecord = (data: GeographicDataReadBaseRecord): {
    id: GeographicDataReadBaseRecord['id'],
    locationName: GeographicDataReadBaseRecord['location_name'],
    coordinates: GeographicDataReadBaseRecord['coordinates'],
    boundary?: GeographicDataReadBaseRecord['boundary'],
    areaCircle?: GeographicDataReadBaseRecord['area_circle'],
    elevation?: GeographicDataReadBaseRecord['elevation'],
    timezone?: GeographicDataReadBaseRecord['timezone'],
    countryCode?: GeographicDataReadBaseRecord['country_code'],
    postalCodes?: GeographicDataReadBaseRecord['postal_codes'],
    population?: GeographicDataReadBaseRecord['population'],
    establishedDate?: GeographicDataReadBaseRecord['established_date'],
    lastUpdated?: GeographicDataReadBaseRecord['last_updated'],
} => ({
    id: data.id,
    locationName: data.location_name,
    coordinates: data.coordinates,
    boundary: data.boundary,
    areaCircle: data.area_circle,
    elevation: data.elevation,
    timezone: data.timezone,
    countryCode: data.country_code,
    postalCodes: data.postal_codes,
    population: data.population,
    establishedDate: data.established_date,
    lastUpdated: data.last_updated,
});

/**
 * The read schema for the "public.geographic_data" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const GeographicDataTableSchema = GeographicDataTableReadSchema.transform(transformGeographicDataReadRecord);

/**
 * The base write schema for the "public.geographic_data" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const GeographicDataTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    locationName: z.string().max(255),
    /**
    * dataType: point
    * defaultValue: 
    */
    coordinates: z.string(),
    /**
    * dataType: polygon
    * defaultValue: 
    */
    boundary: z.string().nullish().optional(),
    /**
    * dataType: circle
    * defaultValue: 
    */
    areaCircle: z.string().nullish().optional(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    elevation: z.number().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    timezone: z.string().max(50).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    countryCode: z.string().max(2).nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    postalCodes: z.array(z.string()).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    population: z.number().int().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    establishedDate: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    lastUpdated: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type GeographicDataInsertBaseRecord = z.output<typeof GeographicDataTableWriteSchema>;

/**
 * The base record type for the "public.geographic_data" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type GeographicDataUpdateBaseRecord = Partial<GeographicDataInsertBaseRecord>;

/**
 * The insert transform function for the "public.geographic_data" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformGeographicDataInsertRecord = (data: GeographicDataInsertBaseRecord): {
    location_name: GeographicDataInsertBaseRecord['locationName'],
    coordinates: GeographicDataInsertBaseRecord['coordinates'],
    boundary?: GeographicDataInsertBaseRecord['boundary'],
    area_circle?: GeographicDataInsertBaseRecord['areaCircle'],
    elevation?: GeographicDataInsertBaseRecord['elevation'],
    timezone?: GeographicDataInsertBaseRecord['timezone'],
    country_code?: GeographicDataInsertBaseRecord['countryCode'],
    postal_codes?: GeographicDataInsertBaseRecord['postalCodes'],
    population?: GeographicDataInsertBaseRecord['population'],
    established_date?: GeographicDataInsertBaseRecord['establishedDate'],
    last_updated?: GeographicDataInsertBaseRecord['lastUpdated'],
} => ({
    location_name: data.locationName,
    coordinates: data.coordinates,
    boundary: data.boundary,
    area_circle: data.areaCircle,
    elevation: data.elevation,
    timezone: data.timezone,
    country_code: data.countryCode,
    postal_codes: data.postalCodes,
    population: data.population,
    established_date: data.establishedDate,
    last_updated: data.lastUpdated,
});

/**
 * The update transform function for the "public.geographic_data" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformGeographicDataUpdateRecord = (data: GeographicDataUpdateBaseRecord): {
    location_name: GeographicDataUpdateBaseRecord['locationName'],
    coordinates: GeographicDataUpdateBaseRecord['coordinates'],
    boundary?: GeographicDataUpdateBaseRecord['boundary'],
    area_circle?: GeographicDataUpdateBaseRecord['areaCircle'],
    elevation?: GeographicDataUpdateBaseRecord['elevation'],
    timezone?: GeographicDataUpdateBaseRecord['timezone'],
    country_code?: GeographicDataUpdateBaseRecord['countryCode'],
    postal_codes?: GeographicDataUpdateBaseRecord['postalCodes'],
    population?: GeographicDataUpdateBaseRecord['population'],
    established_date?: GeographicDataUpdateBaseRecord['establishedDate'],
    last_updated?: GeographicDataUpdateBaseRecord['lastUpdated'],
} => ({
    location_name: data.locationName,
    coordinates: data.coordinates,
    boundary: data.boundary,
    area_circle: data.areaCircle,
    elevation: data.elevation,
    timezone: data.timezone,
    country_code: data.countryCode,
    postal_codes: data.postalCodes,
    population: data.population,
    established_date: data.establishedDate,
    last_updated: data.lastUpdated,
});

/**
 * The insert schema for the "public.geographic_data" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const GeographicDataTableInsertSchema = GeographicDataTableWriteSchema.transform(transformGeographicDataInsertRecord);

/**
 * The update schema for the "public.geographic_data" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const GeographicDataTableUpdateSchema = GeographicDataTableWriteSchema.partial().transform(transformGeographicDataUpdateRecord);

type TableInsertRecord = z.input<typeof GeographicDataTableInsertSchema>;
type TableReadRecord = z.output<typeof GeographicDataTableSchema>;

/**
* Represents a database record from the "public.geographic_data" table.
*/
export interface GeographicDataRecord {
    /**
    * Primary key for geographic data table
    */
    id: TableReadRecord['id'];
    /**
    * Name of the location
    */
    locationName: TableReadRecord['locationName'];
    /**
    * Geographic coordinates
    */
    coordinates: TableReadRecord['coordinates'];
    /**
    * Geographic boundary as polygon
    */
    boundary?: TableReadRecord['boundary'];
    /**
    * Area represented as circle
    */
    areaCircle?: TableReadRecord['areaCircle'];
    /**
    * Elevation above sea level
    */
    elevation?: TableReadRecord['elevation'];
    /**
    * Timezone of the location
    */
    timezone?: TableReadRecord['timezone'];
    /**
    * ISO country code
    */
    countryCode?: TableReadRecord['countryCode'];
    /**
    * Array of postal codes
    */
    postalCodes?: TableReadRecord['postalCodes'];
    /**
    * Population count
    */
    population?: TableReadRecord['population'];
    /**
    * Date when location was established
    */
    establishedDate?: TableReadRecord['establishedDate'];
    /**
    * Timestamp when data was last updated
    */
    lastUpdated?: TableReadRecord['lastUpdated'];
}

/**
* Represents an insertable database record from the "public.geographic_data" table.
*/
export interface GeographicDataInsertRecord {
    /**
    * Name of the location
    * @maxLen: 255
    */
    locationName: TableInsertRecord['locationName'];
    /**
    * Geographic coordinates
    */
    coordinates: TableInsertRecord['coordinates'];
    /**
    * Geographic boundary as polygon
    */
    boundary?: TableInsertRecord['boundary'];
    /**
    * Area represented as circle
    */
    areaCircle?: TableInsertRecord['areaCircle'];
    /**
    * Elevation above sea level
    */
    elevation?: TableInsertRecord['elevation'];
    /**
    * Timezone of the location
    * @maxLen: 50
    */
    timezone?: TableInsertRecord['timezone'];
    /**
    * ISO country code
    * @maxLen: 2
    */
    countryCode?: TableInsertRecord['countryCode'];
    /**
    * Array of postal codes
    */
    postalCodes?: TableInsertRecord['postalCodes'];
    /**
    * Population count
    */
    population?: TableInsertRecord['population'];
    /**
    * Date when location was established
    */
    establishedDate?: TableInsertRecord['establishedDate'];
    /**
    * Timestamp when data was last updated
    * @default: now()
    */
    lastUpdated?: TableInsertRecord['lastUpdated'];
}

/**
* Represents an updateable database record from the "public.geographic_data" table.
*/
export type GeographicDataUpdateRecord = Partial<GeographicDataInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './audit_logs/index.js';
export * from './categories/index.js';
export * from './comments/index.js';
export * from './constraint_variations/index.js';
export * from './enum_tests/index.js';
export * from './files/index.js';
export * from './geographic_data/index.js';
export * from './inventory/index.js';
export * from './network_logs/index.js';
export * from './order_items/index.js';
export * from './orders/index.js';
export * from './post_categories/index.js';
export * from './posts/index.js';
export * from './products/index.js';
export * from './time_series/index.js';
export * from './user_sessions/index.js';
export * from './users/index.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/inventory/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/inventory/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { InventorySupplierInfoSchema } from '../../json.js';


/**
 * The base read schema for the "public.inventory" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const InventoryTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    product_id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stock_quantity: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reserved_quantity: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorder_level: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    last_restocked: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplier_info: InventorySupplierInfoSchema.nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouse_locations: z.array(z.string()).nullish().transform((value) => value ?? []).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.inventory" table.
 * This type represents the raw database record without any transformations.
 */
export type InventoryReadBaseRecord = z.output<typeof InventoryTableReadSchema>;

/**
* The read transform function for the "public.inventory" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformInventoryReadRecord = (data: InventoryReadBaseRecord): {
    productId: InventoryReadBaseRecord['product_id'],
    stockQuantity: InventoryReadBaseRecord['stock_quantity'],
    reservedQuantity?: InventoryReadBaseRecord['reserved_quantity'],
    reorderLevel?: InventoryReadBaseRecord['reorder_level'],
    lastRestocked?: InventoryReadBaseRecord['last_restocked'],
    supplierInfo?: InventoryReadBaseRecord['supplier_info'],
    warehouseLocations?: InventoryReadBaseRecord['warehouse_locations'],
    updatedAt?: InventoryReadBaseRecord['updated_at'],
} => ({
    productId: data.product_id,
    stockQuantity: data.stock_quantity,
    reservedQuantity: data.reserved_quantity,
    reorderLevel: data.reorder_level,
    lastRestocked: data.last_restocked,
    supplierInfo: data.supplier_info,
    warehouseLocations: data.warehouse_locations,
    updatedAt: data.updated_at,
});

/**
 * The read schema for the "public.inventory" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const InventoryTableSchema = InventoryTableReadSchema.transform(transformInventoryReadRecord);

/**
 * The base write schema for the "public.inventory" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const InventoryTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    productId: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stockQuantity: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reservedQuantity: z.number().int().nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorderLevel: z.number().int().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    lastRestocked: z.date().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplierInfo: InventorySupplierInfoSchema.nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouseLocations: z.array(z.string()).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.inventory" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type InventoryInsertBaseRecord = z.output<typeof InventoryTableWriteSchema>;

/**
 * The base record type for the "public.inventory" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type InventoryUpdateBaseRecord = Partial<InventoryInsertBaseRecord>;

/**
 * The insert transform function for the "public.inventory" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformInventoryInsertRecord = (data: InventoryInsertBaseRecord): {
    product_id: InventoryInsertBaseRecord['productId'],
    stock_quantity: InventoryInsertBaseRecord['stockQuantity'],
    reserved_quantity?: InventoryInsertBaseRecord['reservedQuantity'],
    reorder_level?: InventoryInsertBaseRecord['reorderLevel'],
    last_restocked?: InventoryInsertBaseRecord['lastRestocked'],
    supplier_info?: InventoryInsertBaseRecord['supplierInfo'],
    warehouse_locations?: InventoryInsertBaseRecord['warehouseLocations'],
    updated_at?: InventoryInsertBaseRecord['updatedAt'],
} => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: data.supplierInfo,
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.inventory" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformInventoryUpdateRecord = (data: InventoryUpdateBaseRecord): {
    product_id: InventoryUpdateBaseRecord['productId'],
    stock_quantity: InventoryUpdateBaseRecord['stockQuantity'],
    reserved_quantity?: InventoryUpdateBaseRecord['reservedQuantity'],
    reorder_level?: InventoryUpdateBaseRecord['reorderLevel'],
    last_restocked?: InventoryUpdateBaseRecord['lastRestocked'],
    supplier_info?: InventoryUpdateBaseRecord['supplierInfo'],
    warehouse_locations?: InventoryUpdateBaseRecord['warehouseLocations'],
    updated_at?: InventoryUpdateBaseRecord['updatedAt'],
} => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: data.supplierInfo,
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.inventory" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const InventoryTableInsertSchema = InventoryTableWriteSchema.transform(transformInventoryInsertRecord);

/**
 * The update schema for the "public.inventory" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const InventoryTableUpdateSchema = InventoryTableWriteSchema.partial().transform(transformInventoryUpdateRecord);

type TableInsertRecord = z.input<typeof InventoryTableInsertSchema>;
type TableReadRecord = z.output<typeof InventoryTableSchema>;

/**
* Represents a database record from the "public.inventory" table.
*/
export interface InventoryRecord {
    /**
    * ID of the product
    */
    productId: TableReadRecord['productId'];
    /**
    * Current stock quantity
    */
    stockQuantity: TableReadRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    */
    reservedQuantity?: TableReadRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    */
    reorderLevel?: TableReadRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableReadRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableReadRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableReadRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.inventory" table.
*/
export interface InventoryInsertRecord {
    /**
    * ID of the product
    */
    productId: TableInsertRecord['productId'];
    /**
    * Current stock quantity
    * @default: 0
    */
    stockQuantity: TableInsertRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    * @default: 0
    */
    reservedQuantity?: TableInsertRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    * @default: 10
    */
    reorderLevel?: TableInsertRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableInsertRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableInsertRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableInsertRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.inventory" table.
*/
export type InventoryUpdateRecord = Partial<InventoryInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/network_logs/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/network_logs/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { NetworkLogHeadersSchema } from '../../json.js';


/**
 * The base read schema for the "public.network_logs" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const NetworkLogsTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('network_logs_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ip_address: z.string(),
    /**
    * dataType: int4range
    * defaultValue: 
    */
    port_range: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: macaddr
    * defaultValue: 
    */
    mac_address: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    request_time: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: interval
    * defaultValue: 
    */
    response_time: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytes_sent: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytes_received: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    protocol: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    status_code: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    user_agent: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    headers: NetworkLogHeadersSchema.nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.network_logs" table.
 * This type represents the raw database record without any transformations.
 */
export type NetworkLogReadBaseRecord = z.output<typeof NetworkLogsTableReadSchema>;

/**
* The read transform function for the "public.network_logs" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformNetworkLogReadRecord = (data: NetworkLogReadBaseRecord): {
    id: NetworkLogReadBaseRecord['id'],
    ipAddress: NetworkLogReadBaseRecord['ip_address'],
    portRange?: NetworkLogReadBaseRecord['port_range'],
    macAddress?: NetworkLogReadBaseRecord['mac_address'],
    requestTime?: NetworkLogReadBaseRecord['request_time'],
    responseTime?: NetworkLogReadBaseRecord['response_time'],
    bytesSent?: NetworkLogReadBaseRecord['bytes_sent'],
    bytesReceived?: NetworkLogReadBaseRecord['bytes_received'],
    protocol?: NetworkLogReadBaseRecord['protocol'],
    statusCode?: NetworkLogReadBaseRecord['status_code'],
    userAgent?: NetworkLogReadBaseRecord['user_agent'],
    headers?: NetworkLogReadBaseRecord['headers'],
} => ({
    id: data.id,
    ipAddress: data.ip_address,
    portRange: data.port_range,
    macAddress: data.mac_address,
    requestTime: data.request_time,
    responseTime: data.response_time,
    bytesSent: data.bytes_sent,
    bytesReceived: data.bytes_received,
    protocol: data.protocol,
    statusCode: data.status_code,
    userAgent: data.user_agent,
    headers: data.headers,
});

/**
 * The read schema for the "public.network_logs" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const NetworkLogsTableSchema = NetworkLogsTableReadSchema.transform(transformNetworkLogReadRecord);

/**
 * The base write schema for the "public.network_logs" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const NetworkLogsTableWriteSchema = z.object({
    /**
    * dataType: inet
    * defaultValue: 
    */
    ipAddress: z.string(),
    /**
    * dataType: int4range
    * defaultValue: 
    */
    portRange: z.any().nullish().optional(),
    /**
    * dataType: macaddr
    * defaultValue: 
    */
    macAddress: z.string().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    requestTime: z.date().nullish().optional(),
    /**
    * dataType: interval
    * defaultValue: 
    */
    responseTime: z.any().nullish().optional(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytesSent: z.number().int().nullish().optional(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytesReceived: z.number().int().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    protocol: z.string().max(10).nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    statusCode: z.number().int().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    userAgent: z.string().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    headers: NetworkLogHeadersSchema.nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
});

/**
 * The base record type for the "public.network_logs" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type NetworkLogInsertBaseRecord = z.output<typeof NetworkLogsTableWriteSchema>;

/**
 * The base record type for the "public.network_logs" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type NetworkLogUpdateBaseRecord = Partial<NetworkLogInsertBaseRecord>;

/**
 * The insert transform function for the "public.network_logs" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformNetworkLogInsertRecord = (data: NetworkLogInsertBaseRecord): {
    ip_address: NetworkLogInsertBaseRecord['ipAddress'],
    port_range?: NetworkLogInsertBaseRecord['portRange'],
    mac_address?: NetworkLogInsertBaseRecord['macAddress'],
    request_time?: NetworkLogInsertBaseRecord['requestTime'],
    response_time?: NetworkLogInsertBaseRecord['responseTime'],
    bytes_sent?: NetworkLogInsertBaseRecord['bytesSent'],
    bytes_received?: NetworkLogInsertBaseRecord['bytesReceived'],
    protocol?: NetworkLogInsertBaseRecord['protocol'],
    status_code?: NetworkLogInsertBaseRecord['statusCode'],
    user_agent?: NetworkLogInsertBaseRecord['userAgent'],
    headers?: NetworkLogInsertBaseRecord['headers'],
} => ({
    ip_address: data.ipAddress,
    port_range: data.portRange,
    mac_address: data.macAddress,
    request_time: data.requestTime,
    response_time: data.responseTime,
    bytes_sent: data.bytesSent,
    bytes_received: data.bytesReceived,
    protocol: data.protocol,
    status_code: data.statusCode,
    user_agent: data.userAgent,
    headers: data.headers,
});

/**
 * The update transform function for the "public.network_logs" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformNetworkLogUpdateRecord = (data: NetworkLogUpdateBaseRecord): {
    ip_address: NetworkLogUpdateBaseRecord['ipAddress'],
    port_range?: NetworkLogUpdateBaseRecord['portRange'],
    mac_address?: NetworkLogUpdateBaseRecord['macAddress'],
    request_time?: NetworkLogUpdateBaseRecord['requestTime'],
    response_time?: NetworkLogUpdateBaseRecord['responseTime'],
    bytes_sent?: NetworkLogUpdateBaseRecord['bytesSent'],
    bytes_received?: NetworkLogUpdateBaseRecord['bytesReceived'],
    protocol?: NetworkLogUpdateBaseRecord['protocol'],
    status_code?: NetworkLogUpdateBaseRecord['statusCode'],
    user_agent?: NetworkLogUpdateBaseRecord['userAgent'],
    headers?: NetworkLogUpdateBaseRecord['headers'],
} => ({
    ip_address: data.ipAddress,
    port_range: data.portRange,
    mac_address: data.macAddress,
    request_time: data.requestTime,
    response_time: data.responseTime,
    bytes_sent: data.bytesSent,
    bytes_received: data.bytesReceived,
    protocol: data.protocol,
    status_code: data.statusCode,
    user_agent: data.userAgent,
    headers: data.headers,
});

/**
 * The insert schema for the "public.network_logs" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const NetworkLogsTableInsertSchema = NetworkLogsTableWriteSchema.transform(transformNetworkLogInsertRecord);

/**
 * The update schema for the "public.network_logs" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const NetworkLogsTableUpdateSchema = NetworkLogsTableWriteSchema.partial().transform(transformNetworkLogUpdateRecord);

type TableInsertRecord = z.input<typeof NetworkLogsTableInsertSchema>;
type TableReadRecord = z.output<typeof NetworkLogsTableSchema>;

/**
* Represents a database record from the "public.network_logs" table.
*/
export interface NetworkLogRecord {
    /**
    * Primary key for network logs table
    */
    id: TableReadRecord['id'];
    /**
    * IP address of the request
    */
    ipAddress: TableReadRecord['ipAddress'];
    /**
    * Port range used
    */
    portRange?: TableReadRecord['portRange'];
    /**
    * MAC address of the device
    */
    macAddress?: TableReadRecord['macAddress'];
    /**
    * Timestamp of the request
    */
    requestTime?: TableReadRecord['requestTime'];
    /**
    * Response time duration
    */
    responseTime?: TableReadRecord['responseTime'];
    /**
    * Number of bytes sent
    */
    bytesSent?: TableReadRecord['bytesSent'];
    /**
    * Number of bytes received
    */
    bytesReceived?: TableReadRecord['bytesReceived'];
    /**
    * Network protocol used
    */
    protocol?: TableReadRecord['protocol'];
    /**
    * HTTP status code
    */
    statusCode?: TableReadRecord['statusCode'];
    /**
    * User agent string
    */
    userAgent?: TableReadRecord['userAgent'];
    /**
    * Request headers in JSON format
    */
    headers?: TableReadRecord['headers'];
}

/**
* Represents an insertable database record from the "public.network_logs" table.
*/
export interface NetworkLogInsertRecord {
    /**
    * IP address of the request
    */
    ipAddress: TableInsertRecord['ipAddress'];
    /**
    * Port range used
    */
    portRange?: TableInsertRecord['portRange'];
    /**
    * MAC address of the device
    */
    macAddress?: TableInsertRecord['macAddress'];
    /**
    * Timestamp of the request
    * @default: now()
    */
    requestTime?: TableInsertRecord['requestTime'];
    /**
    * Response time duration
    */
    responseTime?: TableInsertRecord['responseTime'];
    /**
    * Number of bytes sent
    * @default: 0
    */
    bytesSent?: TableInsertRecord['bytesSent'];
    /**
    * Number of bytes received
    * @default: 0
    */
    bytesReceived?: TableInsertRecord['bytesReceived'];
    /**
    * Network protocol used
    * @maxLen: 10
    */
    protocol?: TableInsertRecord['protocol'];
    /**
    * HTTP status code
    */
    statusCode?: TableInsertRecord['statusCode'];
    /**
    * User agent string
    */
    userAgent?: TableInsertRecord['userAgent'];
    /**
    * Request headers in JSON format
    */
    headers?: TableInsertRecord['headers'];
}

/**
* Represents an updateable database record from the "public.network_logs" table.
*/
export type NetworkLogUpdateRecord = Partial<NetworkLogInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/order_items/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/order_items/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.order_items" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const OrderItemsTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('order_items_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    order_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    product_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    quantity: z.number().int(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    unit_price: z.number(),
    /**
    * dataType: numeric
    * defaultValue: 0
    */
    discount_percent: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: numeric
    * defaultValue: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    line_total: z.number().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.order_items" table.
 * This type represents the raw database record without any transformations.
 */
export type OrderItemReadBaseRecord = z.output<typeof OrderItemsTableReadSchema>;

/**
* The read transform function for the "public.order_items" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformOrderItemReadRecord = (data: OrderItemReadBaseRecord): {
    id: OrderItemReadBaseRecord['id'],
    orderId?: OrderItemReadBaseRecord['order_id'],
    productId?: OrderItemReadBaseRecord['product_id'],
    quantity: OrderItemReadBaseRecord['quantity'],
    unitPrice: OrderItemReadBaseRecord['unit_price'],
    discountPercent?: OrderItemReadBaseRecord['discount_percent'],
    lineTotal?: OrderItemReadBaseRecord['line_total'],
} => ({
    id: data.id,
    orderId: data.order_id,
    productId: data.product_id,
    quantity: data.quantity,
    unitPrice: data.unit_price,
    discountPercent: data.discount_percent,
    lineTotal: data.line_total,
});

/**
 * The read schema for the "public.order_items" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const OrderItemsTableSchema = OrderItemsTableReadSchema.transform(transformOrderItemReadRecord);

/**
 * The base write schema for the "public.order_items" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const OrderItemsTableWriteSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: 
    */
    orderId: z.number().int().nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    productId: z.number().int().nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    quantity: z.number().int(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    unitPrice: z.number().max(655362),
    /**
    * dataType: numeric
    * defaultValue: 0
    */
    discountPercent: z.number().max(327682).nullish().optional(),
    /**
    * dataType: numeric
    * defaultValue: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    lineTotal: z.number().max(786434).nullish().optional(),
});

/**
 * The base record type for the "public.order_items" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type OrderItemInsertBaseRecord = z.output<typeof OrderItemsTableWriteSchema>;

/**
 * The base record type for the "public.order_items" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type OrderItemUpdateBaseRecord = Partial<OrderItemInsertBaseRecord>;

/**
 * The insert transform function for the "public.order_items" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformOrderItemInsertRecord = (data: OrderItemInsertBaseRecord): {
    order_id?: OrderItemInsertBaseRecord['orderId'],
    product_id?: OrderItemInsertBaseRecord['productId'],
    quantity: OrderItemInsertBaseRecord['quantity'],
    unit_price: OrderItemInsertBaseRecord['unitPrice'],
    discount_percent?: OrderItemInsertBaseRecord['discountPercent'],
    line_total?: OrderItemInsertBaseRecord['lineTotal'],
} => ({
    order_id: data.orderId,
    product_id: data.productId,
    quantity: data.quantity,
    unit_price: data.unitPrice,
    discount_percent: data.discountPercent,
    line_total: data.lineTotal,
});

/**
 * The update transform function for the "public.order_items" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformOrderItemUpdateRecord = (data: OrderItemUpdateBaseRecord): {
    order_id?: OrderItemUpdateBaseRecord['orderId'],
    product_id?: OrderItemUpdateBaseRecord['productId'],
    quantity: OrderItemUpdateBaseRecord['quantity'],
    unit_price: OrderItemUpdateBaseRecord['unitPrice'],
    discount_percent?: OrderItemUpdateBaseRecord['discountPercent'],
    line_total?: OrderItemUpdateBaseRecord['lineTotal'],
} => ({
    order_id: data.orderId,
    product_id: data.productId,
    quantity: data.quantity,
    unit_price: data.unitPrice,
    discount_percent: data.discountPercent,
    line_total: data.lineTotal,
});

/**
 * The insert schema for the "public.order_items" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const OrderItemsTableInsertSchema = OrderItemsTableWriteSchema.transform(transformOrderItemInsertRecord);

/**
 * The update schema for the "public.order_items" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const OrderItemsTableUpdateSchema = OrderItemsTableWriteSchema.partial().transform(transformOrderItemUpdateRecord);

type TableInsertRecord = z.input<typeof OrderItemsTableInsertSchema>;
type TableReadRecord = z.output<typeof OrderItemsTableSchema>;

/**
* Represents a database record from the "public.order_items" table.
*/
export interface OrderItemRecord {
    /**
    * Primary key for order items table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the order this item belongs to
    */
    orderId?: TableReadRecord['orderId'];
    /**
    * ID of the product
    */
    productId?: TableReadRecord['productId'];
    /**
    * Quantity of the product ordered
    */
    quantity: TableReadRecord['quantity'];
    /**
    * Price per unit
    */
    unitPrice: TableReadRecord['unitPrice'];
    /**
    * Discount percentage applied
    */
    discountPercent?: TableReadRecord['discountPercent'];
    /**
    * Calculated line total
    */
    lineTotal?: TableReadRecord['lineTotal'];
}

/**
* Represents an insertable database record from the "public.order_items" table.
*/
export interface OrderItemInsertRecord {
    /**
    * ID of the order this item belongs to
    */
    orderId?: TableInsertRecord['orderId'];
    /**
    * ID of the product
    */
    productId?: TableInsertRecord['productId'];
    /**
    * Quantity of the product ordered
    */
    quantity: TableInsertRecord['quantity'];
    /**
    * Price per unit
    * @maxLen: 655362
    */
    unitPrice: TableInsertRecord['unitPrice'];
    /**
    * Discount percentage applied
    * @maxLen: 327682
    * @default: 0
    */
    discountPercent?: TableInsertRecord['discountPercent'];
    /**
    * Calculated line total
    * @maxLen: 786434
    * @default: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    lineTotal?: TableInsertRecord['lineTotal'];
}

/**
* Represents an updateable database record from the "public.order_items" table.
*/
export type OrderItemUpdateRecord = Partial<OrderItemInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/orders/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/orders/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { OrderMetadataSchema } from '../../json.js';


/**
 * The base read schema for the "public.orders" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const OrdersTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('orders_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    order_number: z.string(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: order_status
    * defaultValue: 'pending'::order_status
    */
    status: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: money
    * defaultValue: 
    */
    total_amount: z.number(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    tax_amount: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    shipping_cost: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: date
    * defaultValue: CURRENT_DATE
    */
    order_date: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    shipped_date: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: time
    * defaultValue: 
    */
    delivery_time: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    notes: z.array(z.string()).nullish().transform((value) => value ?? []).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: OrderMetadataSchema.nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.orders" table.
 * This type represents the raw database record without any transformations.
 */
export type OrderReadBaseRecord = z.output<typeof OrdersTableReadSchema>;

/**
* The read transform function for the "public.orders" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformOrderReadRecord = (data: OrderReadBaseRecord): {
    id: OrderReadBaseRecord['id'],
    orderNumber: OrderReadBaseRecord['order_number'],
    userId?: OrderReadBaseRecord['user_id'],
    status?: OrderReadBaseRecord['status'],
    totalAmount: OrderReadBaseRecord['total_amount'],
    taxAmount?: OrderReadBaseRecord['tax_amount'],
    shippingCost?: OrderReadBaseRecord['shipping_cost'],
    orderDate?: OrderReadBaseRecord['order_date'],
    shippedDate?: OrderReadBaseRecord['shipped_date'],
    deliveryTime?: OrderReadBaseRecord['delivery_time'],
    notes?: OrderReadBaseRecord['notes'],
    metadata?: OrderReadBaseRecord['metadata'],
    createdAt?: OrderReadBaseRecord['created_at'],
} => ({
    id: data.id,
    orderNumber: data.order_number,
    userId: data.user_id,
    status: data.status,
    totalAmount: data.total_amount,
    taxAmount: data.tax_amount,
    shippingCost: data.shipping_cost,
    orderDate: data.order_date,
    shippedDate: data.shipped_date,
    deliveryTime: data.delivery_time,
    notes: data.notes,
    metadata: data.metadata,
    createdAt: data.created_at,
});

/**
 * The read schema for the "public.orders" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const OrdersTableSchema = OrdersTableReadSchema.transform(transformOrderReadRecord);

/**
 * The base write schema for the "public.orders" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const OrdersTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    orderNumber: z.string().max(20),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: order_status
    * defaultValue: 'pending'::order_status
    */
    status: z.any().nullish().optional(),
    /**
    * dataType: money
    * defaultValue: 
    */
    totalAmount: z.number(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    taxAmount: z.number().nullish().optional(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    shippingCost: z.number().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: CURRENT_DATE
    */
    orderDate: z.date().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    shippedDate: z.date().nullish().optional(),
    /**
    * dataType: time
    * defaultValue: 
    */
    deliveryTime: z.string().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    notes: z.array(z.string()).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: OrderMetadataSchema.nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.orders" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type OrderInsertBaseRecord = z.output<typeof OrdersTableWriteSchema>;

/**
 * The base record type for the "public.orders" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type OrderUpdateBaseRecord = Partial<OrderInsertBaseRecord>;

/**
 * The insert transform function for the "public.orders" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformOrderInsertRecord = (data: OrderInsertBaseRecord): {
    order_number: OrderInsertBaseRecord['orderNumber'],
    user_id?: OrderInsertBaseRecord['userId'],
    status?: OrderInsertBaseRecord['status'],
    total_amount: OrderInsertBaseRecord['totalAmount'],
    tax_amount?: OrderInsertBaseRecord['taxAmount'],
    shipping_cost?: OrderInsertBaseRecord['shippingCost'],
    order_date?: OrderInsertBaseRecord['orderDate'],
    shipped_date?: OrderInsertBaseRecord['shippedDate'],
    delivery_time?: OrderInsertBaseRecord['deliveryTime'],
    notes?: OrderInsertBaseRecord['notes'],
    metadata?: OrderInsertBaseRecord['metadata'],
    created_at?: OrderInsertBaseRecord['createdAt'],
} => ({
    order_number: data.orderNumber,
    user_id: data.userId,
    status: data.status,
    total_amount: data.totalAmount,
    tax_amount: data.taxAmount,
    shipping_cost: data.shippingCost,
    order_date: data.orderDate,
    shipped_date: data.shippedDate,
    delivery_time: data.deliveryTime,
    notes: data.notes,
    metadata: data.metadata,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.orders" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformOrderUpdateRecord = (data: OrderUpdateBaseRecord): {
    order_number: OrderUpdateBaseRecord['orderNumber'],
    user_id?: OrderUpdateBaseRecord['userId'],
    status?: OrderUpdateBaseRecord['status'],
    total_amount: OrderUpdateBaseRecord['totalAmount'],
    tax_amount?: OrderUpdateBaseRecord['taxAmount'],
    shipping_cost?: OrderUpdateBaseRecord['shippingCost'],
    order_date?: OrderUpdateBaseRecord['orderDate'],
    shipped_date?: OrderUpdateBaseRecord['shippedDate'],
    delivery_time?: OrderUpdateBaseRecord['deliveryTime'],
    notes?: OrderUpdateBaseRecord['notes'],
    metadata?: OrderUpdateBaseRecord['metadata'],
    created_at?: OrderUpdateBaseRecord['createdAt'],
} => ({
    order_number: data.orderNumber,
    user_id: data.userId,
    status: data.status,
    total_amount: data.totalAmount,
    tax_amount: data.taxAmount,
    shipping_cost: data.shippingCost,
    order_date: data.orderDate,
    shipped_date: data.shippedDate,
    delivery_time: data.deliveryTime,
    notes: data.notes,
    metadata: data.metadata,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.orders" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const OrdersTableInsertSchema = OrdersTableWriteSchema.transform(transformOrderInsertRecord);

/**
 * The update schema for the "public.orders" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const OrdersTableUpdateSchema = OrdersTableWriteSchema.partial().transform(transformOrderUpdateRecord);

type TableInsertRecord = z.input<typeof OrdersTableInsertSchema>;
type TableReadRecord = z.output<typeof OrdersTableSchema>;

/**
* Represents a database record from the "public.orders" table.
*/
export interface OrderRecord {
    /**
    * Primary key for orders table
    */
    id: TableReadRecord['id'];
    /**
    * Unique order number
    */
    orderNumber: TableReadRecord['orderNumber'];
    /**
    * ID of the user who placed the order
    */
    userId?: TableReadRecord['userId'];
    /**
    * Current status of the order
    */
    status?: TableReadRecord['status'];
    /**
    * Total order amount
    */
    totalAmount: TableReadRecord['totalAmount'];
    /**
    * Tax amount for the order
    */
    taxAmount?: TableReadRecord['taxAmount'];
    /**
    * Shipping cost for the order
    */
    shippingCost?: TableReadRecord['shippingCost'];
    /**
    * Date when order was placed
    */
    orderDate?: TableReadRecord['orderDate'];
    /**
    * Date when order was shipped
    */
    shippedDate?: TableReadRecord['shippedDate'];
    /**
    * Expected delivery time
    */
    deliveryTime?: TableReadRecord['deliveryTime'];
    /**
    * Array of order notes
    */
    notes?: TableReadRecord['notes'];
    /**
    * Additional order metadata
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Timestamp when order was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.orders" table.
*/
export interface OrderInsertRecord {
    /**
    * Unique order number
    * @maxLen: 20
    */
    orderNumber: TableInsertRecord['orderNumber'];
    /**
    * ID of the user who placed the order
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Current status of the order
    * @default: 'pending'::order_status
    */
    status?: TableInsertRecord['status'];
    /**
    * Total order amount
    */
    totalAmount: TableInsertRecord['totalAmount'];
    /**
    * Tax amount for the order
    * @default: 0
    */
    taxAmount?: TableInsertRecord['taxAmount'];
    /**
    * Shipping cost for the order
    * @default: 0
    */
    shippingCost?: TableInsertRecord['shippingCost'];
    /**
    * Date when order was placed
    * @default: CURRENT_DATE
    */
    orderDate?: TableInsertRecord['orderDate'];
    /**
    * Date when order was shipped
    */
    shippedDate?: TableInsertRecord['shippedDate'];
    /**
    * Expected delivery time
    */
    deliveryTime?: TableInsertRecord['deliveryTime'];
    /**
    * Array of order notes
    */
    notes?: TableInsertRecord['notes'];
    /**
    * Additional order metadata
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Timestamp when order was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.orders" table.
*/
export type OrderUpdateRecord = Partial<OrderInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/post_categories/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/post_categories/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.post_categories" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const PostCategoriesTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    category_id: z.number().int(),
});

/**
 * The base record type for the "public.post_categories" table.
 * This type represents the raw database record without any transformations.
 */
export type PostCategoryReadBaseRecord = z.output<typeof PostCategoriesTableReadSchema>;

/**
* The read transform function for the "public.post_categories" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformPostCategoryReadRecord = (data: PostCategoryReadBaseRecord): {
    postId: PostCategoryReadBaseRecord['post_id'],
    categoryId: PostCategoryReadBaseRecord['category_id'],
} => ({
    postId: data.post_id,
    categoryId: data.category_id,
});

/**
 * The read schema for the "public.post_categories" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const PostCategoriesTableSchema = PostCategoriesTableReadSchema.transform(transformPostCategoryReadRecord);

/**
 * The base write schema for the "public.post_categories" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const PostCategoriesTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    postId: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    categoryId: z.number().int(),
});

/**
 * The base record type for the "public.post_categories" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type PostCategoryInsertBaseRecord = z.output<typeof PostCategoriesTableWriteSchema>;

/**
 * The base record type for the "public.post_categories" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type PostCategoryUpdateBaseRecord = Partial<PostCategoryInsertBaseRecord>;

/**
 * The insert transform function for the "public.post_categories" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostCategoryInsertRecord = (data: PostCategoryInsertBaseRecord): {
    post_id: PostCategoryInsertBaseRecord['postId'],
    category_id: PostCategoryInsertBaseRecord['categoryId'],
} => ({
    post_id: data.postId,
    category_id: data.categoryId,
});

/**
 * The update transform function for the "public.post_categories" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostCategoryUpdateRecord = (data: PostCategoryUpdateBaseRecord): {
    post_id: PostCategoryUpdateBaseRecord['postId'],
    category_id: PostCategoryUpdateBaseRecord['categoryId'],
} => ({
    post_id: data.postId,
    category_id: data.categoryId,
});

/**
 * The insert schema for the "public.post_categories" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const PostCategoriesTableInsertSchema = PostCategoriesTableWriteSchema.transform(transformPostCategoryInsertRecord);

/**
 * The update schema for the "public.post_categories" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const PostCategoriesTableUpdateSchema = PostCategoriesTableWriteSchema.partial().transform(transformPostCategoryUpdateRecord);

type TableInsertRecord = z.input<typeof PostCategoriesTableInsertSchema>;
type TableReadRecord = z.output<typeof PostCategoriesTableSchema>;

/**
* Represents a database record from the "public.post_categories" table.
*/
export interface PostCategoryRecord {
    /**
    * ID of the post
    */
    postId: TableReadRecord['postId'];
    /**
    * ID of the category
    */
    categoryId: TableReadRecord['categoryId'];
}

/**
* Represents an insertable database record from the "public.post_categories" table.
*/
export interface PostCategoryInsertRecord {
    /**
    * ID of the post
    */
    postId: TableInsertRecord['postId'];
    /**
    * ID of the category
    */
    categoryId: TableInsertRecord['categoryId'];
}

/**
* Represents an updateable database record from the "public.post_categories" table.
*/
export type PostCategoryUpdateRecord = Partial<PostCategoryInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/posts/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/posts/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { PostMetadataSchema } from '../../json.js';

export const POST_STATUSES = ['draft', 'published', 'archived'] as const;

/**
 * The base read schema for the "public.posts" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const PostsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('posts_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().transform((value) => value ?? []).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: PostMetadataSchema.nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    published_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents the raw database record without any transformations.
 */
export type PostReadBaseRecord = z.output<typeof PostsTableReadSchema>;

/**
* The read transform function for the "public.posts" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformPostReadRecord = (data: PostReadBaseRecord): {
    id: PostReadBaseRecord['id'],
    userId?: PostReadBaseRecord['user_id'],
    title: PostReadBaseRecord['title'],
    content?: PostReadBaseRecord['content'],
    published?: PostReadBaseRecord['published'],
    status?: PostReadBaseRecord['status'],
    views?: PostReadBaseRecord['views'],
    tags?: PostReadBaseRecord['tags'],
    metadata?: PostReadBaseRecord['metadata'],
    publishedAt?: PostReadBaseRecord['published_at'],
    updatedAt?: PostReadBaseRecord['updated_at'],
} => ({
    id: data.id,
    userId: data.user_id,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    publishedAt: data.published_at,
    updatedAt: data.updated_at,
});

/**
 * The read schema for the "public.posts" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const PostsTableSchema = PostsTableReadSchema.transform(transformPostReadRecord);

/**
 * The base write schema for the "public.posts" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const PostsTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.number().int().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: PostMetadataSchema.nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    publishedAt: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.posts" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type PostInsertBaseRecord = z.output<typeof PostsTableWriteSchema>;

/**
 * The base record type for the "public.posts" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type PostUpdateBaseRecord = Partial<PostInsertBaseRecord>;

/**
 * The insert transform function for the "public.posts" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostInsertRecord = (data: PostInsertBaseRecord): {
    user_id?: PostInsertBaseRecord['userId'],
    title: PostInsertBaseRecord['title'],
    content?: PostInsertBaseRecord['content'],
    published?: PostInsertBaseRecord['published'],
    status?: PostInsertBaseRecord['status'],
    views?: PostInsertBaseRecord['views'],
    tags?: PostInsertBaseRecord['tags'],
    metadata?: PostInsertBaseRecord['metadata'],
    published_at?: PostInsertBaseRecord['publishedAt'],
    updated_at?: PostInsertBaseRecord['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.posts" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformPostUpdateRecord = (data: PostUpdateBaseRecord): {
    user_id?: PostUpdateBaseRecord['userId'],
    title: PostUpdateBaseRecord['title'],
    content?: PostUpdateBaseRecord['content'],
    published?: PostUpdateBaseRecord['published'],
    status?: PostUpdateBaseRecord['status'],
    views?: PostUpdateBaseRecord['views'],
    tags?: PostUpdateBaseRecord['tags'],
    metadata?: PostUpdateBaseRecord['metadata'],
    published_at?: PostUpdateBaseRecord['publishedAt'],
    updated_at?: PostUpdateBaseRecord['updatedAt'],
} => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: data.metadata,
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.posts" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const PostsTableInsertSchema = PostsTableWriteSchema.transform(transformPostInsertRecord);

/**
 * The update schema for the "public.posts" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const PostsTableUpdateSchema = PostsTableWriteSchema.partial().transform(transformPostUpdateRecord);

type TableInsertRecord = z.input<typeof PostsTableInsertSchema>;
type TableReadRecord = z.output<typeof PostsTableSchema>;
export type PostStatus = (typeof POST_STATUSES)[number];

/**
* Represents a database record from the "public.posts" table.
*/
export interface PostRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    title: TableReadRecord['title'];
    /**
    */
    content?: TableReadRecord['content'];
    /**
    */
    published?: TableReadRecord['published'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    * Number of views for the post
    */
    views?: TableReadRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableReadRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableReadRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.posts" table.
*/
export interface PostInsertRecord {
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    */
    title: TableInsertRecord['title'];
    /**
    */
    content?: TableInsertRecord['content'];
    /**
    * @default: false
    */
    published?: TableInsertRecord['published'];
    /**
    * @maxLen: 20
    * @default: 'draft'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    * Number of views for the post
    * @default: 0
    */
    views?: TableInsertRecord['views'];
    /**
    * Array of tags associated with the post
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Additional metadata for the post
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Timestamp when the post was published
    */
    publishedAt?: TableInsertRecord['publishedAt'];
    /**
    * Timestamp when the post was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.posts" table.
*/
export type PostUpdateRecord = Partial<PostInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/products/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/products/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.products" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const ProductsTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('products_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sku: z.string(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    price: z.number(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    cost: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    weight: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: point
    * defaultValue: 
    */
    dimensions: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bool
    * defaultValue: true
    */
    is_active: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    barcode: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.products" table.
 * This type represents the raw database record without any transformations.
 */
export type ProductReadBaseRecord = z.output<typeof ProductsTableReadSchema>;

/**
* The read transform function for the "public.products" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformProductReadRecord = (data: ProductReadBaseRecord): {
    id: ProductReadBaseRecord['id'],
    name: ProductReadBaseRecord['name'],
    sku: ProductReadBaseRecord['sku'],
    price: ProductReadBaseRecord['price'],
    cost?: ProductReadBaseRecord['cost'],
    weight?: ProductReadBaseRecord['weight'],
    dimensions?: ProductReadBaseRecord['dimensions'],
    isActive?: ProductReadBaseRecord['is_active'],
    barcode?: ProductReadBaseRecord['barcode'],
    description?: ProductReadBaseRecord['description'],
    createdAt?: ProductReadBaseRecord['created_at'],
} => ({
    id: data.id,
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    isActive: data.is_active,
    barcode: data.barcode,
    description: data.description,
    createdAt: data.created_at,
});

/**
 * The read schema for the "public.products" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const ProductsTableSchema = ProductsTableReadSchema.transform(transformProductReadRecord);

/**
 * The base write schema for the "public.products" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const ProductsTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(255),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sku: z.string().max(50),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    price: z.number().max(655362),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    cost: z.number().max(655362).nullish().optional(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    weight: z.number().nullish().optional(),
    /**
    * dataType: point
    * defaultValue: 
    */
    dimensions: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: true
    */
    isActive: z.boolean().nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    barcode: z.string().max(13).nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.products" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type ProductInsertBaseRecord = z.output<typeof ProductsTableWriteSchema>;

/**
 * The base record type for the "public.products" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type ProductUpdateBaseRecord = Partial<ProductInsertBaseRecord>;

/**
 * The insert transform function for the "public.products" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformProductInsertRecord = (data: ProductInsertBaseRecord): {
    name: ProductInsertBaseRecord['name'],
    sku: ProductInsertBaseRecord['sku'],
    price: ProductInsertBaseRecord['price'],
    cost?: ProductInsertBaseRecord['cost'],
    weight?: ProductInsertBaseRecord['weight'],
    dimensions?: ProductInsertBaseRecord['dimensions'],
    is_active?: ProductInsertBaseRecord['isActive'],
    barcode?: ProductInsertBaseRecord['barcode'],
    description?: ProductInsertBaseRecord['description'],
    created_at?: ProductInsertBaseRecord['createdAt'],
} => ({
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    is_active: data.isActive,
    barcode: data.barcode,
    description: data.description,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.products" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformProductUpdateRecord = (data: ProductUpdateBaseRecord): {
    name: ProductUpdateBaseRecord['name'],
    sku: ProductUpdateBaseRecord['sku'],
    price: ProductUpdateBaseRecord['price'],
    cost?: ProductUpdateBaseRecord['cost'],
    weight?: ProductUpdateBaseRecord['weight'],
    dimensions?: ProductUpdateBaseRecord['dimensions'],
    is_active?: ProductUpdateBaseRecord['isActive'],
    barcode?: ProductUpdateBaseRecord['barcode'],
    description?: ProductUpdateBaseRecord['description'],
    created_at?: ProductUpdateBaseRecord['createdAt'],
} => ({
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    is_active: data.isActive,
    barcode: data.barcode,
    description: data.description,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.products" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const ProductsTableInsertSchema = ProductsTableWriteSchema.transform(transformProductInsertRecord);

/**
 * The update schema for the "public.products" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const ProductsTableUpdateSchema = ProductsTableWriteSchema.partial().transform(transformProductUpdateRecord);

type TableInsertRecord = z.input<typeof ProductsTableInsertSchema>;
type TableReadRecord = z.output<typeof ProductsTableSchema>;

/**
* Represents a database record from the "public.products" table.
*/
export interface ProductRecord {
    /**
    * Primary key for products table
    */
    id: TableReadRecord['id'];
    /**
    * Product name
    */
    name: TableReadRecord['name'];
    /**
    * Stock keeping unit identifier
    */
    sku: TableReadRecord['sku'];
    /**
    * Product price with 2 decimal precision
    */
    price: TableReadRecord['price'];
    /**
    * Product cost with 2 decimal precision
    */
    cost?: TableReadRecord['cost'];
    /**
    * Product weight in kilograms
    */
    weight?: TableReadRecord['weight'];
    /**
    * Product dimensions as geometric point
    */
    dimensions?: TableReadRecord['dimensions'];
    /**
    * Whether the product is active
    */
    isActive?: TableReadRecord['isActive'];
    /**
    * Product barcode (13 characters)
    */
    barcode?: TableReadRecord['barcode'];
    /**
    * Product description
    */
    description?: TableReadRecord['description'];
    /**
    * Timestamp when product was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.products" table.
*/
export interface ProductInsertRecord {
    /**
    * Product name
    * @maxLen: 255
    */
    name: TableInsertRecord['name'];
    /**
    * Stock keeping unit identifier
    * @maxLen: 50
    */
    sku: TableInsertRecord['sku'];
    /**
    * Product price with 2 decimal precision
    * @maxLen: 655362
    */
    price: TableInsertRecord['price'];
    /**
    * Product cost with 2 decimal precision
    * @maxLen: 655362
    */
    cost?: TableInsertRecord['cost'];
    /**
    * Product weight in kilograms
    */
    weight?: TableInsertRecord['weight'];
    /**
    * Product dimensions as geometric point
    */
    dimensions?: TableInsertRecord['dimensions'];
    /**
    * Whether the product is active
    * @default: true
    */
    isActive?: TableInsertRecord['isActive'];
    /**
    * Product barcode (13 characters)
    * @maxLen: 13
    */
    barcode?: TableInsertRecord['barcode'];
    /**
    * Product description
    */
    description?: TableInsertRecord['description'];
    /**
    * Timestamp when product was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.products" table.
*/
export type ProductUpdateRecord = Partial<ProductInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/time_series/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/time_series/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.time_series" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const TimeSeriesTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('time_series_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sensor_id: z.string(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    timestamp: z.date(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    temperature: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    humidity: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    pressure: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _numeric
    * defaultValue: 
    */
    readings: z.array(z.number()).nullish().transform((value) => value ?? []).optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    anomaly_detected: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    data_quality: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.time_series" table.
 * This type represents the raw database record without any transformations.
 */
export type TimeSeriesReadBaseRecord = z.output<typeof TimeSeriesTableReadSchema>;

/**
* The read transform function for the "public.time_series" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformTimeSeriesReadRecord = (data: TimeSeriesReadBaseRecord): {
    id: TimeSeriesReadBaseRecord['id'],
    sensorId: TimeSeriesReadBaseRecord['sensor_id'],
    timestamp: TimeSeriesReadBaseRecord['timestamp'],
    temperature?: TimeSeriesReadBaseRecord['temperature'],
    humidity?: TimeSeriesReadBaseRecord['humidity'],
    pressure?: TimeSeriesReadBaseRecord['pressure'],
    readings?: TimeSeriesReadBaseRecord['readings'],
    anomalyDetected?: TimeSeriesReadBaseRecord['anomaly_detected'],
    dataQuality?: TimeSeriesReadBaseRecord['data_quality'],
    createdAt?: TimeSeriesReadBaseRecord['created_at'],
} => ({
    id: data.id,
    sensorId: data.sensor_id,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomalyDetected: data.anomaly_detected,
    dataQuality: data.data_quality,
    createdAt: data.created_at,
});

/**
 * The read schema for the "public.time_series" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const TimeSeriesTableSchema = TimeSeriesTableReadSchema.transform(transformTimeSeriesReadRecord);

/**
 * The base write schema for the "public.time_series" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const TimeSeriesTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sensorId: z.string().max(50),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    timestamp: z.date(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    temperature: z.number().max(327682).nullish().optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    humidity: z.number().max(327682).nullish().optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    pressure: z.number().max(458754).nullish().optional(),
    /**
    * dataType: _numeric
    * defaultValue: 
    */
    readings: z.array(z.number()).nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    anomalyDetected: z.boolean().nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    dataQuality: z.number().int().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.time_series" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type TimeSeriesInsertBaseRecord = z.output<typeof TimeSeriesTableWriteSchema>;

/**
 * The base record type for the "public.time_series" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type TimeSeriesUpdateBaseRecord = Partial<TimeSeriesInsertBaseRecord>;

/**
 * The insert transform function for the "public.time_series" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformTimeSeriesInsertRecord = (data: TimeSeriesInsertBaseRecord): {
    sensor_id: TimeSeriesInsertBaseRecord['sensorId'],
    timestamp: TimeSeriesInsertBaseRecord['timestamp'],
    temperature?: TimeSeriesInsertBaseRecord['temperature'],
    humidity?: TimeSeriesInsertBaseRecord['humidity'],
    pressure?: TimeSeriesInsertBaseRecord['pressure'],
    readings?: TimeSeriesInsertBaseRecord['readings'],
    anomaly_detected?: TimeSeriesInsertBaseRecord['anomalyDetected'],
    data_quality?: TimeSeriesInsertBaseRecord['dataQuality'],
    created_at?: TimeSeriesInsertBaseRecord['createdAt'],
} => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.time_series" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformTimeSeriesUpdateRecord = (data: TimeSeriesUpdateBaseRecord): {
    sensor_id: TimeSeriesUpdateBaseRecord['sensorId'],
    timestamp: TimeSeriesUpdateBaseRecord['timestamp'],
    temperature?: TimeSeriesUpdateBaseRecord['temperature'],
    humidity?: TimeSeriesUpdateBaseRecord['humidity'],
    pressure?: TimeSeriesUpdateBaseRecord['pressure'],
    readings?: TimeSeriesUpdateBaseRecord['readings'],
    anomaly_detected?: TimeSeriesUpdateBaseRecord['anomalyDetected'],
    data_quality?: TimeSeriesUpdateBaseRecord['dataQuality'],
    created_at?: TimeSeriesUpdateBaseRecord['createdAt'],
} => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.time_series" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const TimeSeriesTableInsertSchema = TimeSeriesTableWriteSchema.transform(transformTimeSeriesInsertRecord);

/**
 * The update schema for the "public.time_series" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const TimeSeriesTableUpdateSchema = TimeSeriesTableWriteSchema.partial().transform(transformTimeSeriesUpdateRecord);

type TableInsertRecord = z.input<typeof TimeSeriesTableInsertSchema>;
type TableReadRecord = z.output<typeof TimeSeriesTableSchema>;

/**
* Represents a database record from the "public.time_series" table.
*/
export interface TimeSeriesRecord {
    /**
    * Primary key for time series table
    */
    id: TableReadRecord['id'];
    /**
    * Identifier of the sensor
    */
    sensorId: TableReadRecord['sensorId'];
    /**
    * Timestamp of the reading
    */
    timestamp: TableReadRecord['timestamp'];
    /**
    * Temperature reading
    */
    temperature?: TableReadRecord['temperature'];
    /**
    * Humidity reading
    */
    humidity?: TableReadRecord['humidity'];
    /**
    * Pressure reading
    */
    pressure?: TableReadRecord['pressure'];
    /**
    * Array of numeric readings
    */
    readings?: TableReadRecord['readings'];
    /**
    * Whether an anomaly was detected
    */
    anomalyDetected?: TableReadRecord['anomalyDetected'];
    /**
    * Data quality score (1-10)
    */
    dataQuality?: TableReadRecord['dataQuality'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.time_series" table.
*/
export interface TimeSeriesInsertRecord {
    /**
    * Identifier of the sensor
    * @maxLen: 50
    */
    sensorId: TableInsertRecord['sensorId'];
    /**
    * Timestamp of the reading
    */
    timestamp: TableInsertRecord['timestamp'];
    /**
    * Temperature reading
    * @maxLen: 327682
    */
    temperature?: TableInsertRecord['temperature'];
    /**
    * Humidity reading
    * @maxLen: 327682
    */
    humidity?: TableInsertRecord['humidity'];
    /**
    * Pressure reading
    * @maxLen: 458754
    */
    pressure?: TableInsertRecord['pressure'];
    /**
    * Array of numeric readings
    */
    readings?: TableInsertRecord['readings'];
    /**
    * Whether an anomaly was detected
    * @default: false
    */
    anomalyDetected?: TableInsertRecord['anomalyDetected'];
    /**
    * Data quality score (1-10)
    */
    dataQuality?: TableInsertRecord['dataQuality'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.time_series" table.
*/
export type TimeSeriesUpdateRecord = Partial<TimeSeriesInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/user_sessions/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/user_sessions/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.user_sessions" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const UserSessionsTableReadSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    token_hash: z.string(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expires_at: z.date(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    last_used_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ip_address: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    user_agent: z.string().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents the raw database record without any transformations.
 */
export type UserSessionReadBaseRecord = z.output<typeof UserSessionsTableReadSchema>;

/**
* The read transform function for the "public.user_sessions" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformUserSessionReadRecord = (data: UserSessionReadBaseRecord): {
    id: UserSessionReadBaseRecord['id'],
    userId?: UserSessionReadBaseRecord['user_id'],
    tokenHash: UserSessionReadBaseRecord['token_hash'],
    expiresAt: UserSessionReadBaseRecord['expires_at'],
    createdAt?: UserSessionReadBaseRecord['created_at'],
    lastUsedAt?: UserSessionReadBaseRecord['last_used_at'],
    ipAddress?: UserSessionReadBaseRecord['ip_address'],
    userAgent?: UserSessionReadBaseRecord['user_agent'],
} => ({
    id: data.id,
    userId: data.user_id,
    tokenHash: data.token_hash,
    expiresAt: data.expires_at,
    createdAt: data.created_at,
    lastUsedAt: data.last_used_at,
    ipAddress: data.ip_address,
    userAgent: data.user_agent,
});

/**
 * The read schema for the "public.user_sessions" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const UserSessionsTableSchema = UserSessionsTableReadSchema.transform(transformUserSessionReadRecord);

/**
 * The base write schema for the "public.user_sessions" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const UserSessionsTableWriteSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.number().int().nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    tokenHash: z.string().max(255),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiresAt: z.date(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    lastUsedAt: z.date().nullish().optional(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ipAddress: z.string().nullish().optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    userAgent: z.string().nullish().optional(),
});

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type UserSessionInsertBaseRecord = z.output<typeof UserSessionsTableWriteSchema>;

/**
 * The base record type for the "public.user_sessions" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type UserSessionUpdateBaseRecord = Partial<UserSessionInsertBaseRecord>;

/**
 * The insert transform function for the "public.user_sessions" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserSessionInsertRecord = (data: UserSessionInsertBaseRecord): {
    id: UserSessionInsertBaseRecord['id'],
    user_id?: UserSessionInsertBaseRecord['userId'],
    token_hash: UserSessionInsertBaseRecord['tokenHash'],
    expires_at: UserSessionInsertBaseRecord['expiresAt'],
    created_at?: UserSessionInsertBaseRecord['createdAt'],
    last_used_at?: UserSessionInsertBaseRecord['lastUsedAt'],
    ip_address?: UserSessionInsertBaseRecord['ipAddress'],
    user_agent?: UserSessionInsertBaseRecord['userAgent'],
} => ({
    id: data.id,
    user_id: data.userId,
    token_hash: data.tokenHash,
    expires_at: data.expiresAt,
    created_at: data.createdAt,
    last_used_at: data.lastUsedAt,
    ip_address: data.ipAddress,
    user_agent: data.userAgent,
});

/**
 * The update transform function for the "public.user_sessions" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserSessionUpdateRecord = (data: UserSessionUpdateBaseRecord): {
    id: UserSessionUpdateBaseRecord['id'],
    user_id?: UserSessionUpdateBaseRecord['userId'],
    token_hash: UserSessionUpdateBaseRecord['tokenHash'],
    expires_at: UserSessionUpdateBaseRecord['expiresAt'],
    created_at?: UserSessionUpdateBaseRecord['createdAt'],
    last_used_at?: UserSessionUpdateBaseRecord['lastUsedAt'],
    ip_address?: UserSessionUpdateBaseRecord['ipAddress'],
    user_agent?: UserSessionUpdateBaseRecord['userAgent'],
} => ({
    id: data.id,
    user_id: data.userId,
    token_hash: data.tokenHash,
    expires_at: data.expiresAt,
    created_at: data.createdAt,
    last_used_at: data.lastUsedAt,
    ip_address: data.ipAddress,
    user_agent: data.userAgent,
});

/**
 * The insert schema for the "public.user_sessions" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const UserSessionsTableInsertSchema = UserSessionsTableWriteSchema.transform(transformUserSessionInsertRecord);

/**
 * The update schema for the "public.user_sessions" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const UserSessionsTableUpdateSchema = UserSessionsTableWriteSchema.partial().transform(transformUserSessionUpdateRecord);

type TableInsertRecord = z.input<typeof UserSessionsTableInsertSchema>;
type TableReadRecord = z.output<typeof UserSessionsTableSchema>;

/**
* Represents a database record from the "public.user_sessions" table.
*/
export interface UserSessionRecord {
    /**
    * Primary key for user sessions table
    */
    id: TableReadRecord['id'];
    /**
    * ID of the user this session belongs to
    */
    userId?: TableReadRecord['userId'];
    /**
    * Hashed session token
    */
    tokenHash: TableReadRecord['tokenHash'];
    /**
    * Timestamp when the session expires
    */
    expiresAt: TableReadRecord['expiresAt'];
    /**
    * Timestamp when the session was created
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    * Timestamp when the session was last used
    */
    lastUsedAt?: TableReadRecord['lastUsedAt'];
    /**
    * IP address of the client
    */
    ipAddress?: TableReadRecord['ipAddress'];
    /**
    * User agent string of the client
    */
    userAgent?: TableReadRecord['userAgent'];
}

/**
* Represents an insertable database record from the "public.user_sessions" table.
*/
export interface UserSessionInsertRecord {
    /**
    * Primary key for user sessions table
    * @default: gen_random_uuid()
    */
    id: TableInsertRecord['id'];
    /**
    * ID of the user this session belongs to
    */
    userId?: TableInsertRecord['userId'];
    /**
    * Hashed session token
    * @maxLen: 255
    */
    tokenHash: TableInsertRecord['tokenHash'];
    /**
    * Timestamp when the session expires
    */
    expiresAt: TableInsertRecord['expiresAt'];
    /**
    * Timestamp when the session was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    * Timestamp when the session was last used
    * @default: now()
    */
    lastUsedAt?: TableInsertRecord['lastUsedAt'];
    /**
    * IP address of the client
    */
    ipAddress?: TableInsertRecord['ipAddress'];
    /**
    * User agent string of the client
    */
    userAgent?: TableInsertRecord['userAgent'];
}

/**
* Represents an updateable database record from the "public.user_sessions" table.
*/
export type UserSessionUpdateRecord = Partial<UserSessionInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/users/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > tables/users/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';
import { UserProfileSchema } from '../../json.js';

export const USER_ROLES = ['admin', 'editor', 'viewer'] as const;

/**
 * The base read schema for the "public.users" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const UsersTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('users_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: UserProfileSchema.nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().transform((value) => value ?? []).optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish().transform((value) => value ?? []).optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents the raw database record without any transformations.
 */
export type UserReadBaseRecord = z.output<typeof UsersTableReadSchema>;

/**
* The read transform function for the "public.users" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformUserReadRecord = (data: UserReadBaseRecord): {
    id: UserReadBaseRecord['id'],
    name: UserReadBaseRecord['name'],
    email?: UserReadBaseRecord['email'],
    status?: UserReadBaseRecord['status'],
    profile?: UserReadBaseRecord['profile'],
    createdAt?: UserReadBaseRecord['created_at'],
    roles?: UserReadBaseRecord['roles'],
    dates?: UserReadBaseRecord['dates'],
} => ({
    id: data.id,
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    createdAt: data.created_at,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The read schema for the "public.users" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const UsersTableSchema = UsersTableReadSchema.transform(transformUserReadRecord);

/**
 * The base write schema for the "public.users" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const UsersTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().max(255).nullish().optional(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().max(20).nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: UserProfileSchema.nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish().optional(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish().optional(),
});

/**
 * The base record type for the "public.users" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type UserInsertBaseRecord = z.output<typeof UsersTableWriteSchema>;

/**
 * The base record type for the "public.users" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type UserUpdateBaseRecord = Partial<UserInsertBaseRecord>;

/**
 * The insert transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserInsertRecord = (data: UserInsertBaseRecord): {
    name: UserInsertBaseRecord['name'],
    email?: UserInsertBaseRecord['email'],
    status?: UserInsertBaseRecord['status'],
    profile?: UserInsertBaseRecord['profile'],
    created_at?: UserInsertBaseRecord['createdAt'],
    roles?: UserInsertBaseRecord['roles'],
    dates?: UserInsertBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The update transform function for the "public.users" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformUserUpdateRecord = (data: UserUpdateBaseRecord): {
    name: UserUpdateBaseRecord['name'],
    email?: UserUpdateBaseRecord['email'],
    status?: UserUpdateBaseRecord['status'],
    profile?: UserUpdateBaseRecord['profile'],
    created_at?: UserUpdateBaseRecord['createdAt'],
    roles?: UserUpdateBaseRecord['roles'],
    dates?: UserUpdateBaseRecord['dates'],
} => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: data.profile,
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
});

/**
 * The insert schema for the "public.users" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const UsersTableInsertSchema = UsersTableWriteSchema.transform(transformUserInsertRecord);

/**
 * The update schema for the "public.users" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const UsersTableUpdateSchema = UsersTableWriteSchema.partial().transform(transformUserUpdateRecord);

type TableInsertRecord = z.input<typeof UsersTableInsertSchema>;
type TableReadRecord = z.output<typeof UsersTableSchema>;
export type UserRole = (typeof USER_ROLES)[number];

/**
* Represents a database record from the "public.users" table.
*/
export interface UserRecord {
    /**
    */
    id: TableReadRecord['id'];
    /**
    */
    name: TableReadRecord['name'];
    /**
    */
    email?: TableReadRecord['email'];
    /**
    */
    status?: TableReadRecord['status'];
    /**
    */
    profile?: TableReadRecord['profile'];
    /**
    */
    createdAt?: TableReadRecord['createdAt'];
    /**
    */
    roles?: TableReadRecord['roles'];
    /**
    */
    dates?: TableReadRecord['dates'];
}

/**
* Represents an insertable database record from the "public.users" table.
*/
export interface UserInsertRecord {
    /**
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * @maxLen: 255
    */
    email?: TableInsertRecord['email'];
    /**
    * @maxLen: 20
    * @default: 'active'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    */
    profile?: TableInsertRecord['profile'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    */
    roles?: TableInsertRecord['roles'];
    /**
    */
    dates?: TableInsertRecord['dates'];
}

/**
* Represents an updateable database record from the "public.users" table.
*/
export type UserUpdateRecord = Partial<UserInsertRecord>;
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > types.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export type Table = 
    | 'audit_logs'
    | 'categories'
    | 'comments'
    | 'constraint_variations'
    | 'enum_tests'
    | 'files'
    | 'geographic_data'
    | 'inventory'
    | 'network_logs'
    | 'order_items'
    | 'orders'
    | 'post_categories'
    | 'posts'
    | 'products'
    | 'time_series'
    | 'user_sessions'
    | 'users'

export type Views = 
    | 'view_user_posts'

export type MaterializedViews = 
    | 'mv_user_posts'
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > views/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './view_user_posts/index.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > views/view_user_posts/index.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

export * from './schema.js';
"
`;

exports[`CLI Basic Schema Generation > CLI generates correct zod schemas with basic options > views/view_user_posts/schema.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.view_user_posts" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const ViewUserPostsReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    user_name: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_title: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_content: z.string().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.view_user_posts" table.
 * This type represents the raw database record without any transformations.
 */
export type ViewUserPostReadBaseRecord = z.output<typeof ViewUserPostsReadSchema>;

/**
* The read transform function for the "public.view_user_posts" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformViewUserPostReadRecord = (data: ViewUserPostReadBaseRecord): {
    userId?: ViewUserPostReadBaseRecord['user_id'],
    userName?: ViewUserPostReadBaseRecord['user_name'],
    postId?: ViewUserPostReadBaseRecord['post_id'],
    postTitle?: ViewUserPostReadBaseRecord['post_title'],
    postContent?: ViewUserPostReadBaseRecord['post_content'],
} => ({
    userId: data.user_id,
    userName: data.user_name,
    postId: data.post_id,
    postTitle: data.post_title,
    postContent: data.post_content,
});

/**
 * The read schema for the "public.view_user_posts" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const ViewUserPostsSchema = ViewUserPostsReadSchema.transform(transformViewUserPostReadRecord);

type TableReadRecord = z.output<typeof ViewUserPostsSchema>;

/**
* Represents a database record from the "public.view_user_posts" view.
*/
export interface ViewUserPostRecord {
    /**
    */
    userId?: TableReadRecord['userId'];
    /**
    */
    userName?: TableReadRecord['userName'];
    /**
    */
    postId?: TableReadRecord['postId'];
    /**
    */
    postTitle?: TableReadRecord['postTitle'];
    /**
    */
    postContent?: TableReadRecord['postContent'];
}
"
`;
