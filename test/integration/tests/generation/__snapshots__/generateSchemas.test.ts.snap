// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generateZodSchemas > generates correct zod schemas > constants.ts 1`] = `
"// This file is auto-generated by zod-pg
// Do not edit this file directly.

export const MV_USER_POSTS = 'mv_user_posts';
export const TABLE_AUDIT_LOGS = 'audit_logs';
export const TABLE_CATEGORIES = 'categories';
export const TABLE_COMMENTS = 'comments';
export const TABLE_CONSTRAINT_VARIATIONS = 'constraint_variations';
export const TABLE_ENUM_TESTS = 'enum_tests';
export const TABLE_FILES = 'files';
export const TABLE_GEOGRAPHIC_DATA = 'geographic_data';
export const TABLE_INVENTORY = 'inventory';
export const TABLE_NETWORK_LOGS = 'network_logs';
export const TABLE_ORDER_ITEMS = 'order_items';
export const TABLE_ORDERS = 'orders';
export const TABLE_POST_CATEGORIES = 'post_categories';
export const TABLE_POSTS = 'posts';
export const TABLE_PRODUCTS = 'products';
export const TABLE_TIME_SERIES = 'time_series';
export const TABLE_USER_SESSIONS = 'user_sessions';
export const TABLE_USERS = 'users';
export const VIEW_USER_POSTS = 'view_user_posts';
"
`;

exports[`generateZodSchemas > generates correct zod schemas > materialized_views/index.ts 1`] = `
"// This file is auto-generated by zod-pg
// Do not edit this file directly.

export * from './mv_user_posts.js';
"
`;

exports[`generateZodSchemas > generates correct zod schemas > materialized_views/mv_user_posts.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const MvUserPostsSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.int().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    user_name: z.string().nullable(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.int().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_title: z.string().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_content: z.string().nullable(),
}).transform(data => ({
    userId: data.user_id ?? undefined,
    userName: data.user_name ?? undefined,
    postId: data.post_id ?? undefined,
    postTitle: data.post_title ?? undefined,
    postContent: data.post_content ?? undefined,
}));

type TableReadRecord = z.output<typeof MvUserPostsSchema>;

/**
* Represents a database record from the "public.mv_user_posts" table.
*/
export interface MvUserPostRecord {
    userId: TableReadRecord['userId'];
    userName: TableReadRecord['userName'];
    postId: TableReadRecord['postId'];
    postTitle: TableReadRecord['postTitle'];
    postContent: TableReadRecord['postContent'];
}
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/audit_logs.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const AuditLogsTableSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('audit_logs_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.int().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    action: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    table_name: z.string().nullable(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    record_id: z.int().nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    old_values: z.json().nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    new_values: z.json().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    userId: data.user_id ?? undefined,
    action: data.action,
    tableName: data.table_name ?? undefined,
    recordId: data.record_id ?? undefined,
    oldValues: data.old_values ?? undefined,
    newValues: data.new_values ?? undefined,
    createdAt: data.created_at ?? undefined,
}));

type TableReadRecord = z.output<typeof AuditLogsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.int().nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    action: z.string().max(50),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    tableName: z.string().max(50).nullish(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    recordId: z.int().nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    oldValues: z.json().nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    newValues: z.json().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
});

export const AuditLogsTableInsertSchema = TableWriteSchema.transform(data => ({
    user_id: data.userId,
    action: data.action,
    table_name: data.tableName,
    record_id: data.recordId,
    old_values: (data.oldValues ? JSON.stringify(data.oldValues) : data.oldValues),
    new_values: (data.newValues ? JSON.stringify(data.newValues) : data.newValues),
    created_at: data.createdAt,
}));

export const AuditLogsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    user_id: data.userId,
    action: data.action,
    table_name: data.tableName,
    record_id: data.recordId,
    old_values: (data.oldValues ? JSON.stringify(data.oldValues) : data.oldValues),
    new_values: (data.newValues ? JSON.stringify(data.newValues) : data.newValues),
    created_at: data.createdAt,
}));

type TableInsertRecord = z.input<typeof AuditLogsTableInsertSchema>;

/**
* Represents a database record from the "public.audit_logs" table.
*/
export interface AuditLogRecord {
    id: TableReadRecord['id'];
    userId: TableReadRecord['userId'];
    action: TableReadRecord['action'];
    tableName: TableReadRecord['tableName'];
    recordId: TableReadRecord['recordId'];
    oldValues: TableReadRecord['oldValues'];
    newValues: TableReadRecord['newValues'];
    createdAt: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.audit_logs" table.
*/
export interface AuditLogInsertRecord {
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    * @maxLen: 50
    */
    action: TableInsertRecord['action'];
    /**
    * @maxLen: 50
    */
    tableName?: TableInsertRecord['tableName'];
    /**
    */
    recordId?: TableInsertRecord['recordId'];
    /**
    */
    oldValues?: TableInsertRecord['oldValues'];
    /**
    */
    newValues?: TableInsertRecord['newValues'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.audit_logs" table.
*/
export type AuditLogUpdateRecord = Partial<AuditLogInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/categories.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const CategoriesTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('categories_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.string().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    name: data.name,
    description: data.description ?? undefined,
    color: data.color ?? undefined,
    createdAt: data.created_at ?? undefined,
}));

type TableReadRecord = z.output<typeof CategoriesTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.string().max(7).nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
});

export const CategoriesTableInsertSchema = TableWriteSchema.transform(data => ({
    name: data.name,
    description: data.description,
    color: data.color,
    created_at: data.createdAt,
}));

export const CategoriesTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    name: data.name,
    description: data.description,
    color: data.color,
    created_at: data.createdAt,
}));

type TableInsertRecord = z.input<typeof CategoriesTableInsertSchema>;

/**
* Represents a database record from the "public.categories" table.
*/
export interface CategoryRecord {
    id: TableReadRecord['id'];
    name: TableReadRecord['name'];
    description: TableReadRecord['description'];
    color: TableReadRecord['color'];
    createdAt: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.categories" table.
*/
export interface CategoryInsertRecord {
    /**
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    */
    description?: TableInsertRecord['description'];
    /**
    * @maxLen: 7
    */
    color?: TableInsertRecord['color'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.categories" table.
*/
export type CategoryUpdateRecord = Partial<CategoryInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/comments.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const CommentsTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('comments_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.int().nullable(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.int().nullable(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    parent_id: z.int().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    is_approved: z.boolean().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    postId: data.post_id ?? undefined,
    userId: data.user_id ?? undefined,
    parentId: data.parent_id ?? undefined,
    content: data.content,
    isApproved: data.is_approved ?? undefined,
    createdAt: data.created_at ?? undefined,
    updatedAt: data.updated_at ?? undefined,
}));

type TableReadRecord = z.output<typeof CommentsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    postId: z.int().nullish(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.int().nullish(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    parentId: z.int().nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    isApproved: z.boolean().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish(),
});

export const CommentsTableInsertSchema = TableWriteSchema.transform(data => ({
    post_id: data.postId,
    user_id: data.userId,
    parent_id: data.parentId,
    content: data.content,
    is_approved: data.isApproved,
    created_at: data.createdAt,
    updated_at: data.updatedAt,
}));

export const CommentsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    post_id: data.postId,
    user_id: data.userId,
    parent_id: data.parentId,
    content: data.content,
    is_approved: data.isApproved,
    created_at: data.createdAt,
    updated_at: data.updatedAt,
}));

type TableInsertRecord = z.input<typeof CommentsTableInsertSchema>;

/**
* Represents a database record from the "public.comments" table.
*/
export interface CommentRecord {
    id: TableReadRecord['id'];
    postId: TableReadRecord['postId'];
    userId: TableReadRecord['userId'];
    parentId: TableReadRecord['parentId'];
    content: TableReadRecord['content'];
    isApproved: TableReadRecord['isApproved'];
    createdAt: TableReadRecord['createdAt'];
    updatedAt: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.comments" table.
*/
export interface CommentInsertRecord {
    /**
    */
    postId?: TableInsertRecord['postId'];
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    */
    parentId?: TableInsertRecord['parentId'];
    /**
    */
    content: TableInsertRecord['content'];
    /**
    * @default: false
    */
    isApproved?: TableInsertRecord['isApproved'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.comments" table.
*/
export type CommentUpdateRecord = Partial<CommentInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/constraint_variations.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const CONSTRAINT_VARIATION_ANIMALS = ['cat', 'dog', 'bird', 'fish'] as const;

export const CONSTRAINT_VARIATION_FRUITS = ['apple', 'banana', 'orange', 'grape'] as const;

export const CONSTRAINT_VARIATION_VEHICLES = ['car', 'truck', 'motorcycle', 'bicycle'] as const;

export const CONSTRAINT_VARIATION_LANGUAGES = ['en', 'es', 'fr', 'de', 'it'] as const;

export const CONSTRAINT_VARIATION_ACTIVE_STATUSES = ['true', 'false'] as const;

export const ConstraintVariationsTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('constraint_variations_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    animal: z.enum(CONSTRAINT_VARIATION_ANIMALS).nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    fruit: z.enum(CONSTRAINT_VARIATION_FRUITS).nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    vehicle: z.enum(CONSTRAINT_VARIATION_VEHICLES).nullable(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    language: z.enum(CONSTRAINT_VARIATION_LANGUAGES).nullable(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    rating: z.int().nullable(),
    /**
    * dataType: bool
    * defaultValue: 
    */
    active_status: z.enum(CONSTRAINT_VARIATION_ACTIVE_STATUSES).nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    animal: data.animal ?? undefined,
    fruit: data.fruit ?? undefined,
    vehicle: data.vehicle ?? undefined,
    language: data.language ?? undefined,
    rating: data.rating ?? undefined,
    activeStatus: data.active_status ?? undefined,
    createdAt: data.created_at ?? undefined,
}));

type TableReadRecord = z.output<typeof ConstraintVariationsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    animal: z.enum(CONSTRAINT_VARIATION_ANIMALS).nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    fruit: z.enum(CONSTRAINT_VARIATION_FRUITS).nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    vehicle: z.enum(CONSTRAINT_VARIATION_VEHICLES).nullish(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    language: z.enum(CONSTRAINT_VARIATION_LANGUAGES).nullish(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    rating: z.int().nullish(),
    /**
    * dataType: bool
    * defaultValue: 
    */
    activeStatus: z.enum(CONSTRAINT_VARIATION_ACTIVE_STATUSES).nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
});

export const ConstraintVariationsTableInsertSchema = TableWriteSchema.transform(data => ({
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    active_status: data.activeStatus,
    created_at: data.createdAt,
}));

export const ConstraintVariationsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    animal: data.animal,
    fruit: data.fruit,
    vehicle: data.vehicle,
    language: data.language,
    rating: data.rating,
    active_status: data.activeStatus,
    created_at: data.createdAt,
}));

type TableInsertRecord = z.input<typeof ConstraintVariationsTableInsertSchema>;

export type ConstraintVariationAnimal = (typeof CONSTRAINT_VARIATION_ANIMALS)[number];

export type ConstraintVariationFruit = (typeof CONSTRAINT_VARIATION_FRUITS)[number];

export type ConstraintVariationVehicle = (typeof CONSTRAINT_VARIATION_VEHICLES)[number];

export type ConstraintVariationLanguage = (typeof CONSTRAINT_VARIATION_LANGUAGES)[number];

export type ConstraintVariationActiveStatus = (typeof CONSTRAINT_VARIATION_ACTIVE_STATUSES)[number];

/**
* Represents a database record from the "public.constraint_variations" table.
*/
export interface ConstraintVariationRecord {
    id: TableReadRecord['id'];
    animal: TableReadRecord['animal'];
    fruit: TableReadRecord['fruit'];
    vehicle: TableReadRecord['vehicle'];
    language: TableReadRecord['language'];
    rating: TableReadRecord['rating'];
    activeStatus: TableReadRecord['activeStatus'];
    createdAt: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.constraint_variations" table.
*/
export interface ConstraintVariationInsertRecord {
    /**
    * @maxLen: 20
    */
    animal?: TableInsertRecord['animal'];
    /**
    */
    fruit?: TableInsertRecord['fruit'];
    /**
    * @maxLen: 15
    */
    vehicle?: TableInsertRecord['vehicle'];
    /**
    * @maxLen: 2
    */
    language?: TableInsertRecord['language'];
    /**
    */
    rating?: TableInsertRecord['rating'];
    /**
    */
    activeStatus?: TableInsertRecord['activeStatus'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.constraint_variations" table.
*/
export type ConstraintVariationUpdateRecord = Partial<ConstraintVariationInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/enum_tests.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const ENUM_TEST_PRIORITIES = ['low', 'medium', 'high', 'critical'] as const;

export const ENUM_TEST_COLORS = ['red', 'green', 'blue', 'yellow'] as const;

export const ENUM_TEST_SIZES = ['xs', 's', 'm', 'l', 'xl', 'xxl'] as const;

export const ENUM_TEST_GRADES = ['A', 'B', 'C', 'D', 'F'] as const;

export const ENUM_TEST_CATEGORIES = ['electronics', 'clothing', 'books', 'home-garden'] as const;

export const ENUM_TEST_MOODS = ['happy', 'sad', 'angry', 'excited', 'calm'] as const;

export const ENUM_TEST_DIRECTIONS = ['north', 'south', 'east', 'west'] as const;

export const ENUM_TEST_WEATHER_CONDITIONS = ['sunny', 'cloudy', 'rainy', 'snowy', 'foggy'] as const;

export const ENUM_TEST_TASK_STATUSES = ['todo', 'in-progress', 'done', 'cancelled'] as const;

export const ENUM_TEST_DIFFICULTIES = ['1', '2', '3', '4', '5'] as const;

export const ENUM_TEST_WEEKDAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as const;

export const ENUM_TEST_PAYMENT_METHODS = ['cash', 'credit-card', 'debit-card', 'paypal', 'bank-transfer'] as const;

export const EnumTestsTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('enum_tests_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    priority: z.enum(ENUM_TEST_PRIORITIES).nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.enum(ENUM_TEST_COLORS).nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    size: z.enum(ENUM_TEST_SIZES).nullable(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    grade: z.enum(ENUM_TEST_GRADES).nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    category: z.enum(ENUM_TEST_CATEGORIES).nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    mood: z.enum(ENUM_TEST_MOODS).nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    direction: z.enum(ENUM_TEST_DIRECTIONS).nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    weather_condition: z.enum(ENUM_TEST_WEATHER_CONDITIONS).nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    task_status: z.enum(ENUM_TEST_TASK_STATUSES).nullable(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    difficulty: z.enum(ENUM_TEST_DIFFICULTIES).nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    weekday: z.enum(ENUM_TEST_WEEKDAYS).nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    payment_method: z.enum(ENUM_TEST_PAYMENT_METHODS).nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    priority: data.priority ?? undefined,
    color: data.color ?? undefined,
    size: data.size ?? undefined,
    grade: data.grade ?? undefined,
    category: data.category ?? undefined,
    mood: data.mood ?? undefined,
    direction: data.direction ?? undefined,
    weatherCondition: data.weather_condition ?? undefined,
    taskStatus: data.task_status ?? undefined,
    difficulty: data.difficulty ?? undefined,
    weekday: data.weekday ?? undefined,
    paymentMethod: data.payment_method ?? undefined,
    createdAt: data.created_at ?? undefined,
}));

type TableReadRecord = z.output<typeof EnumTestsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    priority: z.enum(ENUM_TEST_PRIORITIES).nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    color: z.enum(ENUM_TEST_COLORS).nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    size: z.enum(ENUM_TEST_SIZES).nullish(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    grade: z.enum(ENUM_TEST_GRADES).nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    category: z.enum(ENUM_TEST_CATEGORIES).nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    mood: z.enum(ENUM_TEST_MOODS).nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    direction: z.enum(ENUM_TEST_DIRECTIONS).nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    weatherCondition: z.enum(ENUM_TEST_WEATHER_CONDITIONS).nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    taskStatus: z.enum(ENUM_TEST_TASK_STATUSES).nullish(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    difficulty: z.enum(ENUM_TEST_DIFFICULTIES).nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    weekday: z.enum(ENUM_TEST_WEEKDAYS).nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    paymentMethod: z.enum(ENUM_TEST_PAYMENT_METHODS).nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
});

export const EnumTestsTableInsertSchema = TableWriteSchema.transform(data => ({
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weather_condition: data.weatherCondition,
    task_status: data.taskStatus,
    difficulty: data.difficulty,
    weekday: data.weekday,
    payment_method: data.paymentMethod,
    created_at: data.createdAt,
}));

export const EnumTestsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    priority: data.priority,
    color: data.color,
    size: data.size,
    grade: data.grade,
    category: data.category,
    mood: data.mood,
    direction: data.direction,
    weather_condition: data.weatherCondition,
    task_status: data.taskStatus,
    difficulty: data.difficulty,
    weekday: data.weekday,
    payment_method: data.paymentMethod,
    created_at: data.createdAt,
}));

type TableInsertRecord = z.input<typeof EnumTestsTableInsertSchema>;

export type EnumTestPriority = (typeof ENUM_TEST_PRIORITIES)[number];

export type EnumTestColor = (typeof ENUM_TEST_COLORS)[number];

export type EnumTestSize = (typeof ENUM_TEST_SIZES)[number];

export type EnumTestGrade = (typeof ENUM_TEST_GRADES)[number];

export type EnumTestCategory = (typeof ENUM_TEST_CATEGORIES)[number];

export type EnumTestMood = (typeof ENUM_TEST_MOODS)[number];

export type EnumTestDirection = (typeof ENUM_TEST_DIRECTIONS)[number];

export type EnumTestWeatherCondition = (typeof ENUM_TEST_WEATHER_CONDITIONS)[number];

export type EnumTestTaskStatus = (typeof ENUM_TEST_TASK_STATUSES)[number];

export type EnumTestDifficulty = (typeof ENUM_TEST_DIFFICULTIES)[number];

export type EnumTestWeekday = (typeof ENUM_TEST_WEEKDAYS)[number];

export type EnumTestPaymentMethod = (typeof ENUM_TEST_PAYMENT_METHODS)[number];

/**
* Represents a database record from the "public.enum_tests" table.
*/
export interface EnumTestRecord {
    id: TableReadRecord['id'];
    priority: TableReadRecord['priority'];
    color: TableReadRecord['color'];
    size: TableReadRecord['size'];
    grade: TableReadRecord['grade'];
    category: TableReadRecord['category'];
    mood: TableReadRecord['mood'];
    direction: TableReadRecord['direction'];
    weatherCondition: TableReadRecord['weatherCondition'];
    taskStatus: TableReadRecord['taskStatus'];
    difficulty: TableReadRecord['difficulty'];
    weekday: TableReadRecord['weekday'];
    paymentMethod: TableReadRecord['paymentMethod'];
    createdAt: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.enum_tests" table.
*/
export interface EnumTestInsertRecord {
    /**
    * @maxLen: 10
    */
    priority?: TableInsertRecord['priority'];
    /**
    * @maxLen: 20
    */
    color?: TableInsertRecord['color'];
    /**
    */
    size?: TableInsertRecord['size'];
    /**
    * @maxLen: 1
    */
    grade?: TableInsertRecord['grade'];
    /**
    * @maxLen: 30
    */
    category?: TableInsertRecord['category'];
    /**
    */
    mood?: TableInsertRecord['mood'];
    /**
    * @maxLen: 10
    */
    direction?: TableInsertRecord['direction'];
    /**
    */
    weatherCondition?: TableInsertRecord['weatherCondition'];
    /**
    * @maxLen: 20
    */
    taskStatus?: TableInsertRecord['taskStatus'];
    /**
    */
    difficulty?: TableInsertRecord['difficulty'];
    /**
    * @maxLen: 10
    */
    weekday?: TableInsertRecord['weekday'];
    /**
    */
    paymentMethod?: TableInsertRecord['paymentMethod'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.enum_tests" table.
*/
export type EnumTestUpdateRecord = Partial<EnumTestInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/files.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const FilesTableSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    file_path: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    file_size: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mime_type: z.string().nullable(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().nullable(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binary_data: z.string().nullable(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    is_encrypted: z.boolean().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    upload_time: z.date().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiry_date: z.date().nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.json().nullable(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullable(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    access_count: z.int().nullable(),
}).transform(data => ({
    id: data.id,
    filename: data.filename,
    filePath: data.file_path,
    fileSize: data.file_size,
    mimeType: data.mime_type ?? undefined,
    checksum: data.checksum ?? undefined,
    binaryData: data.binary_data ?? undefined,
    isEncrypted: data.is_encrypted ?? undefined,
    uploadTime: data.upload_time ?? undefined,
    expiryDate: data.expiry_date ?? undefined,
    metadata: data.metadata ?? undefined,
    tags: data.tags ?? undefined,
    accessCount: data.access_count ?? undefined,
}));

type TableReadRecord = z.output<typeof FilesTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string().max(255),
    /**
    * dataType: text
    * defaultValue: 
    */
    filePath: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    fileSize: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mimeType: z.string().max(100).nullish(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().max(64).nullish(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binaryData: z.string().nullish(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    isEncrypted: z.boolean().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    uploadTime: z.date().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiryDate: z.date().nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.json().nullish(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    accessCount: z.int().nullish(),
});

export const FilesTableInsertSchema = TableWriteSchema.transform(data => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    tags: data.tags,
    access_count: data.accessCount,
}));

export const FilesTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    tags: data.tags,
    access_count: data.accessCount,
}));

type TableInsertRecord = z.input<typeof FilesTableInsertSchema>;

/**
* Represents a database record from the "public.files" table.
*/
export interface FileRecord {
    id: TableReadRecord['id'];
    filename: TableReadRecord['filename'];
    filePath: TableReadRecord['filePath'];
    fileSize: TableReadRecord['fileSize'];
    mimeType: TableReadRecord['mimeType'];
    checksum: TableReadRecord['checksum'];
    binaryData: TableReadRecord['binaryData'];
    isEncrypted: TableReadRecord['isEncrypted'];
    uploadTime: TableReadRecord['uploadTime'];
    expiryDate: TableReadRecord['expiryDate'];
    metadata: TableReadRecord['metadata'];
    tags: TableReadRecord['tags'];
    accessCount: TableReadRecord['accessCount'];
}

/**
* Represents an insertable database record from the "public.files" table.
*/
export interface FileInsertRecord {
    /**
    * @default: gen_random_uuid()
    */
    id: TableInsertRecord['id'];
    /**
    * @maxLen: 255
    */
    filename: TableInsertRecord['filename'];
    /**
    */
    filePath: TableInsertRecord['filePath'];
    /**
    */
    fileSize: TableInsertRecord['fileSize'];
    /**
    * @maxLen: 100
    */
    mimeType?: TableInsertRecord['mimeType'];
    /**
    * @maxLen: 64
    */
    checksum?: TableInsertRecord['checksum'];
    /**
    */
    binaryData?: TableInsertRecord['binaryData'];
    /**
    * @default: false
    */
    isEncrypted?: TableInsertRecord['isEncrypted'];
    /**
    * @default: now()
    */
    uploadTime?: TableInsertRecord['uploadTime'];
    /**
    */
    expiryDate?: TableInsertRecord['expiryDate'];
    /**
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    */
    tags?: TableInsertRecord['tags'];
    /**
    * @default: 0
    */
    accessCount?: TableInsertRecord['accessCount'];
}

/**
* Represents an updateable database record from the "public.files" table.
*/
export type FileUpdateRecord = Partial<FileInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/geographic_data.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const GeographicDataTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('geographic_data_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    location_name: z.string(),
    /**
    * dataType: point
    * defaultValue: 
    */
    coordinates: z.string(),
    /**
    * dataType: polygon
    * defaultValue: 
    */
    boundary: z.string().nullable(),
    /**
    * dataType: circle
    * defaultValue: 
    */
    area_circle: z.string().nullable(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    elevation: z.number().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    timezone: z.string().nullable(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    country_code: z.string().nullable(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    postal_codes: z.array(z.string()).nullable(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    population: z.int().nullable(),
    /**
    * dataType: date
    * defaultValue: 
    */
    established_date: z.date().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    last_updated: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    locationName: data.location_name,
    coordinates: data.coordinates,
    boundary: data.boundary ?? undefined,
    areaCircle: data.area_circle ?? undefined,
    elevation: data.elevation ?? undefined,
    timezone: data.timezone ?? undefined,
    countryCode: data.country_code ?? undefined,
    postalCodes: data.postal_codes ?? undefined,
    population: data.population ?? undefined,
    establishedDate: data.established_date ?? undefined,
    lastUpdated: data.last_updated ?? undefined,
}));

type TableReadRecord = z.output<typeof GeographicDataTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    locationName: z.string().max(255),
    /**
    * dataType: point
    * defaultValue: 
    */
    coordinates: z.string(),
    /**
    * dataType: polygon
    * defaultValue: 
    */
    boundary: z.string().nullish(),
    /**
    * dataType: circle
    * defaultValue: 
    */
    areaCircle: z.string().nullish(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    elevation: z.number().nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    timezone: z.string().max(50).nullish(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    countryCode: z.string().max(2).nullish(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    postalCodes: z.array(z.string()).nullish(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    population: z.int().nullish(),
    /**
    * dataType: date
    * defaultValue: 
    */
    establishedDate: z.date().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    lastUpdated: z.date().nullish(),
});

export const GeographicDataTableInsertSchema = TableWriteSchema.transform(data => ({
    location_name: data.locationName,
    coordinates: data.coordinates,
    boundary: data.boundary,
    area_circle: data.areaCircle,
    elevation: data.elevation,
    timezone: data.timezone,
    country_code: data.countryCode,
    postal_codes: data.postalCodes,
    population: data.population,
    established_date: data.establishedDate,
    last_updated: data.lastUpdated,
}));

export const GeographicDataTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    location_name: data.locationName,
    coordinates: data.coordinates,
    boundary: data.boundary,
    area_circle: data.areaCircle,
    elevation: data.elevation,
    timezone: data.timezone,
    country_code: data.countryCode,
    postal_codes: data.postalCodes,
    population: data.population,
    established_date: data.establishedDate,
    last_updated: data.lastUpdated,
}));

type TableInsertRecord = z.input<typeof GeographicDataTableInsertSchema>;

/**
* Represents a database record from the "public.geographic_data" table.
*/
export interface GeographicDatumRecord {
    id: TableReadRecord['id'];
    locationName: TableReadRecord['locationName'];
    coordinates: TableReadRecord['coordinates'];
    boundary: TableReadRecord['boundary'];
    areaCircle: TableReadRecord['areaCircle'];
    elevation: TableReadRecord['elevation'];
    timezone: TableReadRecord['timezone'];
    countryCode: TableReadRecord['countryCode'];
    postalCodes: TableReadRecord['postalCodes'];
    population: TableReadRecord['population'];
    establishedDate: TableReadRecord['establishedDate'];
    lastUpdated: TableReadRecord['lastUpdated'];
}

/**
* Represents an insertable database record from the "public.geographic_data" table.
*/
export interface GeographicDatumInsertRecord {
    /**
    * @maxLen: 255
    */
    locationName: TableInsertRecord['locationName'];
    /**
    */
    coordinates: TableInsertRecord['coordinates'];
    /**
    */
    boundary?: TableInsertRecord['boundary'];
    /**
    */
    areaCircle?: TableInsertRecord['areaCircle'];
    /**
    */
    elevation?: TableInsertRecord['elevation'];
    /**
    * @maxLen: 50
    */
    timezone?: TableInsertRecord['timezone'];
    /**
    * @maxLen: 2
    */
    countryCode?: TableInsertRecord['countryCode'];
    /**
    */
    postalCodes?: TableInsertRecord['postalCodes'];
    /**
    */
    population?: TableInsertRecord['population'];
    /**
    */
    establishedDate?: TableInsertRecord['establishedDate'];
    /**
    * @default: now()
    */
    lastUpdated?: TableInsertRecord['lastUpdated'];
}

/**
* Represents an updateable database record from the "public.geographic_data" table.
*/
export type GeographicDatumUpdateRecord = Partial<GeographicDatumInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/index.ts 1`] = `
"// This file is auto-generated by zod-pg
// Do not edit this file directly.

export * from './audit_logs.js';
export * from './categories.js';
export * from './comments.js';
export * from './constraint_variations.js';
export * from './enum_tests.js';
export * from './files.js';
export * from './geographic_data.js';
export * from './inventory.js';
export * from './network_logs.js';
export * from './order_items.js';
export * from './orders.js';
export * from './post_categories.js';
export * from './posts.js';
export * from './products.js';
export * from './time_series.js';
export * from './user_sessions.js';
export * from './users.js';
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/inventory.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const InventoryTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    product_id: z.int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stock_quantity: z.int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reserved_quantity: z.int().nullable(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorder_level: z.int().nullable(),
    /**
    * dataType: date
    * defaultValue: 
    */
    last_restocked: z.date().nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplier_info: z.json().nullable(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouse_locations: z.array(z.string()).nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullable(),
}).transform(data => ({
    productId: data.product_id,
    stockQuantity: data.stock_quantity,
    reservedQuantity: data.reserved_quantity ?? undefined,
    reorderLevel: data.reorder_level ?? undefined,
    lastRestocked: data.last_restocked ?? undefined,
    supplierInfo: data.supplier_info ?? undefined,
    warehouseLocations: data.warehouse_locations ?? undefined,
    updatedAt: data.updated_at ?? undefined,
}));

type TableReadRecord = z.output<typeof InventoryTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    productId: z.int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stockQuantity: z.int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reservedQuantity: z.int().nullish(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorderLevel: z.int().nullish(),
    /**
    * dataType: date
    * defaultValue: 
    */
    lastRestocked: z.date().nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplierInfo: z.json().nullish(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouseLocations: z.array(z.string()).nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish(),
});

export const InventoryTableInsertSchema = TableWriteSchema.transform(data => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: (data.supplierInfo ? JSON.stringify(data.supplierInfo) : data.supplierInfo),
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
}));

export const InventoryTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: (data.supplierInfo ? JSON.stringify(data.supplierInfo) : data.supplierInfo),
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
}));

type TableInsertRecord = z.input<typeof InventoryTableInsertSchema>;

/**
* Represents a database record from the "public.inventory" table.
*/
export interface InventoryRecord {
    productId: TableReadRecord['productId'];
    stockQuantity: TableReadRecord['stockQuantity'];
    reservedQuantity: TableReadRecord['reservedQuantity'];
    reorderLevel: TableReadRecord['reorderLevel'];
    lastRestocked: TableReadRecord['lastRestocked'];
    supplierInfo: TableReadRecord['supplierInfo'];
    warehouseLocations: TableReadRecord['warehouseLocations'];
    updatedAt: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.inventory" table.
*/
export interface InventoryInsertRecord {
    /**
    */
    productId: TableInsertRecord['productId'];
    /**
    * @default: 0
    */
    stockQuantity: TableInsertRecord['stockQuantity'];
    /**
    * @default: 0
    */
    reservedQuantity?: TableInsertRecord['reservedQuantity'];
    /**
    * @default: 10
    */
    reorderLevel?: TableInsertRecord['reorderLevel'];
    /**
    */
    lastRestocked?: TableInsertRecord['lastRestocked'];
    /**
    */
    supplierInfo?: TableInsertRecord['supplierInfo'];
    /**
    */
    warehouseLocations?: TableInsertRecord['warehouseLocations'];
    /**
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.inventory" table.
*/
export type InventoryUpdateRecord = Partial<InventoryInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/network_logs.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const NetworkLogsTableSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('network_logs_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ip_address: z.string(),
    /**
    * dataType: int4range
    * defaultValue: 
    */
    port_range: z.any().nullable(),
    /**
    * dataType: macaddr
    * defaultValue: 
    */
    mac_address: z.string().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    request_time: z.date().nullable(),
    /**
    * dataType: interval
    * defaultValue: 
    */
    response_time: z.any().nullable(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytes_sent: z.int().nullable(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytes_received: z.int().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    protocol: z.string().nullable(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    status_code: z.int().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    user_agent: z.string().nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    headers: z.json().nullable(),
}).transform(data => ({
    id: data.id,
    ipAddress: data.ip_address,
    portRange: data.port_range ?? undefined,
    macAddress: data.mac_address ?? undefined,
    requestTime: data.request_time ?? undefined,
    responseTime: data.response_time ?? undefined,
    bytesSent: data.bytes_sent ?? undefined,
    bytesReceived: data.bytes_received ?? undefined,
    protocol: data.protocol ?? undefined,
    statusCode: data.status_code ?? undefined,
    userAgent: data.user_agent ?? undefined,
    headers: data.headers ?? undefined,
}));

type TableReadRecord = z.output<typeof NetworkLogsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: inet
    * defaultValue: 
    */
    ipAddress: z.string(),
    /**
    * dataType: int4range
    * defaultValue: 
    */
    portRange: z.any().nullish(),
    /**
    * dataType: macaddr
    * defaultValue: 
    */
    macAddress: z.string().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    requestTime: z.date().nullish(),
    /**
    * dataType: interval
    * defaultValue: 
    */
    responseTime: z.any().nullish(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytesSent: z.int().nullish(),
    /**
    * dataType: int8
    * defaultValue: 0
    */
    bytesReceived: z.int().nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    protocol: z.string().max(10).nullish(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    statusCode: z.int().nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    userAgent: z.string().nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    headers: z.json().nullish(),
});

export const NetworkLogsTableInsertSchema = TableWriteSchema.transform(data => ({
    ip_address: data.ipAddress,
    port_range: data.portRange,
    mac_address: data.macAddress,
    request_time: data.requestTime,
    response_time: data.responseTime,
    bytes_sent: data.bytesSent,
    bytes_received: data.bytesReceived,
    protocol: data.protocol,
    status_code: data.statusCode,
    user_agent: data.userAgent,
    headers: (data.headers ? JSON.stringify(data.headers) : data.headers),
}));

export const NetworkLogsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    ip_address: data.ipAddress,
    port_range: data.portRange,
    mac_address: data.macAddress,
    request_time: data.requestTime,
    response_time: data.responseTime,
    bytes_sent: data.bytesSent,
    bytes_received: data.bytesReceived,
    protocol: data.protocol,
    status_code: data.statusCode,
    user_agent: data.userAgent,
    headers: (data.headers ? JSON.stringify(data.headers) : data.headers),
}));

type TableInsertRecord = z.input<typeof NetworkLogsTableInsertSchema>;

/**
* Represents a database record from the "public.network_logs" table.
*/
export interface NetworkLogRecord {
    id: TableReadRecord['id'];
    ipAddress: TableReadRecord['ipAddress'];
    portRange: TableReadRecord['portRange'];
    macAddress: TableReadRecord['macAddress'];
    requestTime: TableReadRecord['requestTime'];
    responseTime: TableReadRecord['responseTime'];
    bytesSent: TableReadRecord['bytesSent'];
    bytesReceived: TableReadRecord['bytesReceived'];
    protocol: TableReadRecord['protocol'];
    statusCode: TableReadRecord['statusCode'];
    userAgent: TableReadRecord['userAgent'];
    headers: TableReadRecord['headers'];
}

/**
* Represents an insertable database record from the "public.network_logs" table.
*/
export interface NetworkLogInsertRecord {
    /**
    */
    ipAddress: TableInsertRecord['ipAddress'];
    /**
    */
    portRange?: TableInsertRecord['portRange'];
    /**
    */
    macAddress?: TableInsertRecord['macAddress'];
    /**
    * @default: now()
    */
    requestTime?: TableInsertRecord['requestTime'];
    /**
    */
    responseTime?: TableInsertRecord['responseTime'];
    /**
    * @default: 0
    */
    bytesSent?: TableInsertRecord['bytesSent'];
    /**
    * @default: 0
    */
    bytesReceived?: TableInsertRecord['bytesReceived'];
    /**
    * @maxLen: 10
    */
    protocol?: TableInsertRecord['protocol'];
    /**
    */
    statusCode?: TableInsertRecord['statusCode'];
    /**
    */
    userAgent?: TableInsertRecord['userAgent'];
    /**
    */
    headers?: TableInsertRecord['headers'];
}

/**
* Represents an updateable database record from the "public.network_logs" table.
*/
export type NetworkLogUpdateRecord = Partial<NetworkLogInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/order_items.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const OrderItemsTableSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('order_items_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    order_id: z.int().nullable(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    product_id: z.int().nullable(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    quantity: z.int(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    unit_price: z.number(),
    /**
    * dataType: numeric
    * defaultValue: 0
    */
    discount_percent: z.number().nullable(),
    /**
    * dataType: numeric
    * defaultValue: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    line_total: z.number().nullable(),
}).transform(data => ({
    id: data.id,
    orderId: data.order_id ?? undefined,
    productId: data.product_id ?? undefined,
    quantity: data.quantity,
    unitPrice: data.unit_price,
    discountPercent: data.discount_percent ?? undefined,
    lineTotal: data.line_total ?? undefined,
}));

type TableReadRecord = z.output<typeof OrderItemsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: 
    */
    orderId: z.int().nullish(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    productId: z.int().nullish(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    quantity: z.int(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    unitPrice: z.number().max(655362),
    /**
    * dataType: numeric
    * defaultValue: 0
    */
    discountPercent: z.number().max(327682).nullish(),
    /**
    * dataType: numeric
    * defaultValue: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    lineTotal: z.number().max(786434).nullish(),
});

export const OrderItemsTableInsertSchema = TableWriteSchema.transform(data => ({
    order_id: data.orderId,
    product_id: data.productId,
    quantity: data.quantity,
    unit_price: data.unitPrice,
    discount_percent: data.discountPercent,
    line_total: data.lineTotal,
}));

export const OrderItemsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    order_id: data.orderId,
    product_id: data.productId,
    quantity: data.quantity,
    unit_price: data.unitPrice,
    discount_percent: data.discountPercent,
    line_total: data.lineTotal,
}));

type TableInsertRecord = z.input<typeof OrderItemsTableInsertSchema>;

/**
* Represents a database record from the "public.order_items" table.
*/
export interface OrderItemRecord {
    id: TableReadRecord['id'];
    orderId: TableReadRecord['orderId'];
    productId: TableReadRecord['productId'];
    quantity: TableReadRecord['quantity'];
    unitPrice: TableReadRecord['unitPrice'];
    discountPercent: TableReadRecord['discountPercent'];
    lineTotal: TableReadRecord['lineTotal'];
}

/**
* Represents an insertable database record from the "public.order_items" table.
*/
export interface OrderItemInsertRecord {
    /**
    */
    orderId?: TableInsertRecord['orderId'];
    /**
    */
    productId?: TableInsertRecord['productId'];
    /**
    */
    quantity: TableInsertRecord['quantity'];
    /**
    * @maxLen: 655362
    */
    unitPrice: TableInsertRecord['unitPrice'];
    /**
    * @maxLen: 327682
    * @default: 0
    */
    discountPercent?: TableInsertRecord['discountPercent'];
    /**
    * @maxLen: 786434
    * @default: (((quantity)::numeric * unit_price) * ((1)::numeric - (discount_percent / (100)::numeric)))
    */
    lineTotal?: TableInsertRecord['lineTotal'];
}

/**
* Represents an updateable database record from the "public.order_items" table.
*/
export type OrderItemUpdateRecord = Partial<OrderItemInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/orders.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const OrdersTableSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('orders_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    order_number: z.string(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.int().nullable(),
    /**
    * dataType: order_status
    * defaultValue: 'pending'::order_status
    */
    status: z.any().nullable(),
    /**
    * dataType: money
    * defaultValue: 
    */
    total_amount: z.number(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    tax_amount: z.number().nullable(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    shipping_cost: z.number().nullable(),
    /**
    * dataType: date
    * defaultValue: CURRENT_DATE
    */
    order_date: z.date().nullable(),
    /**
    * dataType: date
    * defaultValue: 
    */
    shipped_date: z.date().nullable(),
    /**
    * dataType: time
    * defaultValue: 
    */
    delivery_time: z.string().nullable(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    notes: z.array(z.string()).nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.json().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    orderNumber: data.order_number,
    userId: data.user_id ?? undefined,
    status: data.status ?? undefined,
    totalAmount: data.total_amount,
    taxAmount: data.tax_amount ?? undefined,
    shippingCost: data.shipping_cost ?? undefined,
    orderDate: data.order_date ?? undefined,
    shippedDate: data.shipped_date ?? undefined,
    deliveryTime: data.delivery_time ?? undefined,
    notes: data.notes ?? undefined,
    metadata: data.metadata ?? undefined,
    createdAt: data.created_at ?? undefined,
}));

type TableReadRecord = z.output<typeof OrdersTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    orderNumber: z.string().max(20),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.int().nullish(),
    /**
    * dataType: order_status
    * defaultValue: 'pending'::order_status
    */
    status: z.any().nullish(),
    /**
    * dataType: money
    * defaultValue: 
    */
    totalAmount: z.number(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    taxAmount: z.number().nullish(),
    /**
    * dataType: money
    * defaultValue: 0
    */
    shippingCost: z.number().nullish(),
    /**
    * dataType: date
    * defaultValue: CURRENT_DATE
    */
    orderDate: z.date().nullish(),
    /**
    * dataType: date
    * defaultValue: 
    */
    shippedDate: z.date().nullish(),
    /**
    * dataType: time
    * defaultValue: 
    */
    deliveryTime: z.string().nullish(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    notes: z.array(z.string()).nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.json().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
});

export const OrdersTableInsertSchema = TableWriteSchema.transform(data => ({
    order_number: data.orderNumber,
    user_id: data.userId,
    status: data.status,
    total_amount: data.totalAmount,
    tax_amount: data.taxAmount,
    shipping_cost: data.shippingCost,
    order_date: data.orderDate,
    shipped_date: data.shippedDate,
    delivery_time: data.deliveryTime,
    notes: data.notes,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    created_at: data.createdAt,
}));

export const OrdersTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    order_number: data.orderNumber,
    user_id: data.userId,
    status: data.status,
    total_amount: data.totalAmount,
    tax_amount: data.taxAmount,
    shipping_cost: data.shippingCost,
    order_date: data.orderDate,
    shipped_date: data.shippedDate,
    delivery_time: data.deliveryTime,
    notes: data.notes,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    created_at: data.createdAt,
}));

type TableInsertRecord = z.input<typeof OrdersTableInsertSchema>;

/**
* Represents a database record from the "public.orders" table.
*/
export interface OrderRecord {
    id: TableReadRecord['id'];
    orderNumber: TableReadRecord['orderNumber'];
    userId: TableReadRecord['userId'];
    status: TableReadRecord['status'];
    totalAmount: TableReadRecord['totalAmount'];
    taxAmount: TableReadRecord['taxAmount'];
    shippingCost: TableReadRecord['shippingCost'];
    orderDate: TableReadRecord['orderDate'];
    shippedDate: TableReadRecord['shippedDate'];
    deliveryTime: TableReadRecord['deliveryTime'];
    notes: TableReadRecord['notes'];
    metadata: TableReadRecord['metadata'];
    createdAt: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.orders" table.
*/
export interface OrderInsertRecord {
    /**
    * @maxLen: 20
    */
    orderNumber: TableInsertRecord['orderNumber'];
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    * @default: 'pending'::order_status
    */
    status?: TableInsertRecord['status'];
    /**
    */
    totalAmount: TableInsertRecord['totalAmount'];
    /**
    * @default: 0
    */
    taxAmount?: TableInsertRecord['taxAmount'];
    /**
    * @default: 0
    */
    shippingCost?: TableInsertRecord['shippingCost'];
    /**
    * @default: CURRENT_DATE
    */
    orderDate?: TableInsertRecord['orderDate'];
    /**
    */
    shippedDate?: TableInsertRecord['shippedDate'];
    /**
    */
    deliveryTime?: TableInsertRecord['deliveryTime'];
    /**
    */
    notes?: TableInsertRecord['notes'];
    /**
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.orders" table.
*/
export type OrderUpdateRecord = Partial<OrderInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/post_categories.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const PostCategoriesTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    category_id: z.int(),
}).transform(data => ({
    postId: data.post_id,
    categoryId: data.category_id,
}));

type TableReadRecord = z.output<typeof PostCategoriesTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    postId: z.int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    categoryId: z.int(),
});

export const PostCategoriesTableInsertSchema = TableWriteSchema.transform(data => ({
    post_id: data.postId,
    category_id: data.categoryId,
}));

export const PostCategoriesTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    post_id: data.postId,
    category_id: data.categoryId,
}));

type TableInsertRecord = z.input<typeof PostCategoriesTableInsertSchema>;

/**
* Represents a database record from the "public.post_categories" table.
*/
export interface PostCategoryRecord {
    postId: TableReadRecord['postId'];
    categoryId: TableReadRecord['categoryId'];
}

/**
* Represents an insertable database record from the "public.post_categories" table.
*/
export interface PostCategoryInsertRecord {
    /**
    */
    postId: TableInsertRecord['postId'];
    /**
    */
    categoryId: TableInsertRecord['categoryId'];
}

/**
* Represents an updateable database record from the "public.post_categories" table.
*/
export type PostCategoryUpdateRecord = Partial<PostCategoryInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/posts.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const POST_STATUSES = ['draft', 'published', 'archived'] as const;

export const PostsTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('posts_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.int().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullable(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullable(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.int().nullable(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.json().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    published_at: z.date().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    userId: data.user_id ?? undefined,
    title: data.title,
    content: data.content ?? undefined,
    published: data.published ?? undefined,
    status: data.status ?? undefined,
    views: data.views ?? undefined,
    tags: data.tags ?? undefined,
    metadata: data.metadata ?? undefined,
    publishedAt: data.published_at ?? undefined,
    updatedAt: data.updated_at ?? undefined,
}));

type TableReadRecord = z.output<typeof PostsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.int().nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    title: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    content: z.string().nullish(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    published: z.boolean().nullish(),
    /**
    * dataType: varchar
    * defaultValue: 'draft'::character varying
    */
    status: z.enum(POST_STATUSES).nullish(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    views: z.int().nullish(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.json().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    publishedAt: z.date().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish(),
});

export const PostsTableInsertSchema = TableWriteSchema.transform(data => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
}));

export const PostsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    user_id: data.userId,
    title: data.title,
    content: data.content,
    published: data.published,
    status: data.status,
    views: data.views,
    tags: data.tags,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    published_at: data.publishedAt,
    updated_at: data.updatedAt,
}));

type TableInsertRecord = z.input<typeof PostsTableInsertSchema>;

export type PostStatus = (typeof POST_STATUSES)[number];

/**
* Represents a database record from the "public.posts" table.
*/
export interface PostRecord {
    id: TableReadRecord['id'];
    userId: TableReadRecord['userId'];
    title: TableReadRecord['title'];
    content: TableReadRecord['content'];
    published: TableReadRecord['published'];
    status: TableReadRecord['status'];
    views: TableReadRecord['views'];
    tags: TableReadRecord['tags'];
    metadata: TableReadRecord['metadata'];
    publishedAt: TableReadRecord['publishedAt'];
    updatedAt: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.posts" table.
*/
export interface PostInsertRecord {
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    */
    title: TableInsertRecord['title'];
    /**
    */
    content?: TableInsertRecord['content'];
    /**
    * @default: false
    */
    published?: TableInsertRecord['published'];
    /**
    * @maxLen: 20
    * @default: 'draft'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    * @default: 0
    */
    views?: TableInsertRecord['views'];
    /**
    */
    tags?: TableInsertRecord['tags'];
    /**
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    */
    publishedAt?: TableInsertRecord['publishedAt'];
    /**
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.posts" table.
*/
export type PostUpdateRecord = Partial<PostInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/products.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const ProductsTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('products_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sku: z.string(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    price: z.number(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    cost: z.number().nullable(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    weight: z.number().nullable(),
    /**
    * dataType: point
    * defaultValue: 
    */
    dimensions: z.string().nullable(),
    /**
    * dataType: bool
    * defaultValue: true
    */
    is_active: z.boolean().nullable(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    barcode: z.string().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost ?? undefined,
    weight: data.weight ?? undefined,
    dimensions: data.dimensions ?? undefined,
    isActive: data.is_active ?? undefined,
    barcode: data.barcode ?? undefined,
    description: data.description ?? undefined,
    createdAt: data.created_at ?? undefined,
}));

type TableReadRecord = z.output<typeof ProductsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(255),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sku: z.string().max(50),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    price: z.number().max(655362),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    cost: z.number().max(655362).nullish(),
    /**
    * dataType: float4
    * defaultValue: 
    */
    weight: z.number().nullish(),
    /**
    * dataType: point
    * defaultValue: 
    */
    dimensions: z.string().nullish(),
    /**
    * dataType: bool
    * defaultValue: true
    */
    isActive: z.boolean().nullish(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    barcode: z.string().max(13).nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    description: z.string().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
});

export const ProductsTableInsertSchema = TableWriteSchema.transform(data => ({
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    is_active: data.isActive,
    barcode: data.barcode,
    description: data.description,
    created_at: data.createdAt,
}));

export const ProductsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    name: data.name,
    sku: data.sku,
    price: data.price,
    cost: data.cost,
    weight: data.weight,
    dimensions: data.dimensions,
    is_active: data.isActive,
    barcode: data.barcode,
    description: data.description,
    created_at: data.createdAt,
}));

type TableInsertRecord = z.input<typeof ProductsTableInsertSchema>;

/**
* Represents a database record from the "public.products" table.
*/
export interface ProductRecord {
    id: TableReadRecord['id'];
    name: TableReadRecord['name'];
    sku: TableReadRecord['sku'];
    price: TableReadRecord['price'];
    cost: TableReadRecord['cost'];
    weight: TableReadRecord['weight'];
    dimensions: TableReadRecord['dimensions'];
    isActive: TableReadRecord['isActive'];
    barcode: TableReadRecord['barcode'];
    description: TableReadRecord['description'];
    createdAt: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.products" table.
*/
export interface ProductInsertRecord {
    /**
    * @maxLen: 255
    */
    name: TableInsertRecord['name'];
    /**
    * @maxLen: 50
    */
    sku: TableInsertRecord['sku'];
    /**
    * @maxLen: 655362
    */
    price: TableInsertRecord['price'];
    /**
    * @maxLen: 655362
    */
    cost?: TableInsertRecord['cost'];
    /**
    */
    weight?: TableInsertRecord['weight'];
    /**
    */
    dimensions?: TableInsertRecord['dimensions'];
    /**
    * @default: true
    */
    isActive?: TableInsertRecord['isActive'];
    /**
    * @maxLen: 13
    */
    barcode?: TableInsertRecord['barcode'];
    /**
    */
    description?: TableInsertRecord['description'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.products" table.
*/
export type ProductUpdateRecord = Partial<ProductInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/time_series.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const TimeSeriesTableSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('time_series_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sensor_id: z.string(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    timestamp: z.date(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    temperature: z.number().nullable(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    humidity: z.number().nullable(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    pressure: z.number().nullable(),
    /**
    * dataType: _numeric
    * defaultValue: 
    */
    readings: z.array(z.number()).nullable(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    anomaly_detected: z.boolean().nullable(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    data_quality: z.int().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
}).transform(data => ({
    id: data.id,
    sensorId: data.sensor_id,
    timestamp: data.timestamp,
    temperature: data.temperature ?? undefined,
    humidity: data.humidity ?? undefined,
    pressure: data.pressure ?? undefined,
    readings: data.readings ?? undefined,
    anomalyDetected: data.anomaly_detected ?? undefined,
    dataQuality: data.data_quality ?? undefined,
    createdAt: data.created_at ?? undefined,
}));

type TableReadRecord = z.output<typeof TimeSeriesTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sensorId: z.string().max(50),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    timestamp: z.date(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    temperature: z.number().max(327682).nullish(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    humidity: z.number().max(327682).nullish(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    pressure: z.number().max(458754).nullish(),
    /**
    * dataType: _numeric
    * defaultValue: 
    */
    readings: z.array(z.number()).nullish(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    anomalyDetected: z.boolean().nullish(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    dataQuality: z.int().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
});

export const TimeSeriesTableInsertSchema = TableWriteSchema.transform(data => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
}));

export const TimeSeriesTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
}));

type TableInsertRecord = z.input<typeof TimeSeriesTableInsertSchema>;

/**
* Represents a database record from the "public.time_series" table.
*/
export interface TimeSeryRecord {
    id: TableReadRecord['id'];
    sensorId: TableReadRecord['sensorId'];
    timestamp: TableReadRecord['timestamp'];
    temperature: TableReadRecord['temperature'];
    humidity: TableReadRecord['humidity'];
    pressure: TableReadRecord['pressure'];
    readings: TableReadRecord['readings'];
    anomalyDetected: TableReadRecord['anomalyDetected'];
    dataQuality: TableReadRecord['dataQuality'];
    createdAt: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.time_series" table.
*/
export interface TimeSeryInsertRecord {
    /**
    * @maxLen: 50
    */
    sensorId: TableInsertRecord['sensorId'];
    /**
    */
    timestamp: TableInsertRecord['timestamp'];
    /**
    * @maxLen: 327682
    */
    temperature?: TableInsertRecord['temperature'];
    /**
    * @maxLen: 327682
    */
    humidity?: TableInsertRecord['humidity'];
    /**
    * @maxLen: 458754
    */
    pressure?: TableInsertRecord['pressure'];
    /**
    */
    readings?: TableInsertRecord['readings'];
    /**
    * @default: false
    */
    anomalyDetected?: TableInsertRecord['anomalyDetected'];
    /**
    */
    dataQuality?: TableInsertRecord['dataQuality'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.time_series" table.
*/
export type TimeSeryUpdateRecord = Partial<TimeSeryInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/user_sessions.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const UserSessionsTableSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.uuid(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.int().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    token_hash: z.string(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expires_at: z.date(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    last_used_at: z.date().nullable(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ip_address: z.string().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    user_agent: z.string().nullable(),
}).transform(data => ({
    id: data.id,
    userId: data.user_id ?? undefined,
    tokenHash: data.token_hash,
    expiresAt: data.expires_at,
    createdAt: data.created_at ?? undefined,
    lastUsedAt: data.last_used_at ?? undefined,
    ipAddress: data.ip_address ?? undefined,
    userAgent: data.user_agent ?? undefined,
}));

type TableReadRecord = z.output<typeof UserSessionsTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.uuid(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    userId: z.int().nullish(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    tokenHash: z.string().max(255),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiresAt: z.date(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    lastUsedAt: z.date().nullish(),
    /**
    * dataType: inet
    * defaultValue: 
    */
    ipAddress: z.string().nullish(),
    /**
    * dataType: text
    * defaultValue: 
    */
    userAgent: z.string().nullish(),
});

export const UserSessionsTableInsertSchema = TableWriteSchema.transform(data => ({
    id: data.id,
    user_id: data.userId,
    token_hash: data.tokenHash,
    expires_at: data.expiresAt,
    created_at: data.createdAt,
    last_used_at: data.lastUsedAt,
    ip_address: data.ipAddress,
    user_agent: data.userAgent,
}));

export const UserSessionsTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    id: data.id,
    user_id: data.userId,
    token_hash: data.tokenHash,
    expires_at: data.expiresAt,
    created_at: data.createdAt,
    last_used_at: data.lastUsedAt,
    ip_address: data.ipAddress,
    user_agent: data.userAgent,
}));

type TableInsertRecord = z.input<typeof UserSessionsTableInsertSchema>;

/**
* Represents a database record from the "public.user_sessions" table.
*/
export interface UserSessionRecord {
    id: TableReadRecord['id'];
    userId: TableReadRecord['userId'];
    tokenHash: TableReadRecord['tokenHash'];
    expiresAt: TableReadRecord['expiresAt'];
    createdAt: TableReadRecord['createdAt'];
    lastUsedAt: TableReadRecord['lastUsedAt'];
    ipAddress: TableReadRecord['ipAddress'];
    userAgent: TableReadRecord['userAgent'];
}

/**
* Represents an insertable database record from the "public.user_sessions" table.
*/
export interface UserSessionInsertRecord {
    /**
    * @default: gen_random_uuid()
    */
    id: TableInsertRecord['id'];
    /**
    */
    userId?: TableInsertRecord['userId'];
    /**
    * @maxLen: 255
    */
    tokenHash: TableInsertRecord['tokenHash'];
    /**
    */
    expiresAt: TableInsertRecord['expiresAt'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    * @default: now()
    */
    lastUsedAt?: TableInsertRecord['lastUsedAt'];
    /**
    */
    ipAddress?: TableInsertRecord['ipAddress'];
    /**
    */
    userAgent?: TableInsertRecord['userAgent'];
}

/**
* Represents an updateable database record from the "public.user_sessions" table.
*/
export type UserSessionUpdateRecord = Partial<UserSessionInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > tables/users.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const USER_ROLES = ['admin', 'editor', 'viewer'] as const;

export const UsersTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: nextval('users_id_seq'::regclass)
    */
    id: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: z.json().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullable(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullable(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullable(),
}).transform(data => ({
    id: data.id,
    name: data.name,
    email: data.email ?? undefined,
    status: data.status ?? undefined,
    profile: data.profile ?? undefined,
    createdAt: data.created_at ?? undefined,
    roles: data.roles ?? undefined,
    dates: data.dates ?? undefined,
}));

type TableReadRecord = z.output<typeof UsersTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    name: z.string().max(100),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    email: z.string().max(255).nullish(),
    /**
    * dataType: varchar
    * defaultValue: 'active'::character varying
    */
    status: z.string().max(20).nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    profile: z.json().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    roles: z.array(z.enum(USER_ROLES)).nullish(),
    /**
    * dataType: _timestamp
    * defaultValue: 
    */
    dates: z.array(z.date()).nullish(),
});

export const UsersTableInsertSchema = TableWriteSchema.transform(data => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: (data.profile ? JSON.stringify(data.profile) : data.profile),
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
}));

export const UsersTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    name: data.name,
    email: data.email,
    status: data.status,
    profile: (data.profile ? JSON.stringify(data.profile) : data.profile),
    created_at: data.createdAt,
    roles: data.roles,
    dates: data.dates,
}));

type TableInsertRecord = z.input<typeof UsersTableInsertSchema>;

export type UserRoles = (typeof USER_ROLES)[number];

/**
* Represents a database record from the "public.users" table.
*/
export interface UserRecord {
    id: TableReadRecord['id'];
    name: TableReadRecord['name'];
    email: TableReadRecord['email'];
    status: TableReadRecord['status'];
    profile: TableReadRecord['profile'];
    createdAt: TableReadRecord['createdAt'];
    roles: TableReadRecord['roles'];
    dates: TableReadRecord['dates'];
}

/**
* Represents an insertable database record from the "public.users" table.
*/
export interface UserInsertRecord {
    /**
    * @maxLen: 100
    */
    name: TableInsertRecord['name'];
    /**
    * @maxLen: 255
    */
    email?: TableInsertRecord['email'];
    /**
    * @maxLen: 20
    * @default: 'active'::character varying
    */
    status?: TableInsertRecord['status'];
    /**
    */
    profile?: TableInsertRecord['profile'];
    /**
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
    /**
    */
    roles?: TableInsertRecord['roles'];
    /**
    */
    dates?: TableInsertRecord['dates'];
}

/**
* Represents an updateable database record from the "public.users" table.
*/
export type UserUpdateRecord = Partial<UserInsertRecord>;
"
`;

exports[`generateZodSchemas > generates correct zod schemas > types.ts 1`] = `
"// This file is auto-generated by zod-pg
// Do not edit this file directly.

export type Table = 
  | 'audit_logs'
  | 'categories'
  | 'comments'
  | 'constraint_variations'
  | 'enum_tests'
  | 'files'
  | 'geographic_data'
  | 'inventory'
  | 'network_logs'
  | 'order_items'
  | 'orders'
  | 'post_categories'
  | 'posts'
  | 'products'
  | 'time_series'
  | 'user_sessions'
  | 'users';
"
`;

exports[`generateZodSchemas > generates correct zod schemas > views/index.ts 1`] = `
"// This file is auto-generated by zod-pg
// Do not edit this file directly.

export * from './view_user_posts.js';
"
`;

exports[`generateZodSchemas > generates correct zod schemas > views/view_user_posts.ts 1`] = `
"// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const ViewUserPostsSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    user_id: z.int().nullable(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    user_name: z.string().nullable(),
    /**
    * dataType: int4
    * defaultValue: 
    */
    post_id: z.int().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_title: z.string().nullable(),
    /**
    * dataType: text
    * defaultValue: 
    */
    post_content: z.string().nullable(),
}).transform(data => ({
    userId: data.user_id ?? undefined,
    userName: data.user_name ?? undefined,
    postId: data.post_id ?? undefined,
    postTitle: data.post_title ?? undefined,
    postContent: data.post_content ?? undefined,
}));

type TableReadRecord = z.output<typeof ViewUserPostsSchema>;

/**
* Represents a database record from the "public.view_user_posts" table.
*/
export interface ViewUserPostRecord {
    userId: TableReadRecord['userId'];
    userName: TableReadRecord['userName'];
    postId: TableReadRecord['postId'];
    postTitle: TableReadRecord['postTitle'];
    postContent: TableReadRecord['postContent'];
}
"
`;
