// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const FilesTableSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    file_path: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    file_size: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mime_type: z.string().nullable(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().nullable(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binary_data: z.string().nullable(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    is_encrypted: z.boolean().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    upload_time: z.date().nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiry_date: z.date().nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.json().nullable(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullable(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    access_count: z.int().nullable(),
}).transform(data => ({
    id: data.id,
    filename: data.filename,
    filePath: data.file_path,
    fileSize: data.file_size,
    mimeType: data.mime_type ?? undefined,
    checksum: data.checksum ?? undefined,
    binaryData: data.binary_data ?? undefined,
    isEncrypted: data.is_encrypted ?? undefined,
    uploadTime: data.upload_time ?? undefined,
    expiryDate: data.expiry_date ?? undefined,
    metadata: data.metadata ?? undefined,
    tags: data.tags ?? undefined,
    accessCount: data.access_count ?? undefined,
}));

type TableReadRecord = z.output<typeof FilesTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string().max(255),
    /**
    * dataType: text
    * defaultValue: 
    */
    filePath: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    fileSize: z.int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mimeType: z.string().max(100).nullish(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().max(64).nullish(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binaryData: z.string().nullish(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    isEncrypted: z.boolean().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    uploadTime: z.date().nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiryDate: z.date().nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.json().nullish(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    accessCount: z.int().nullish(),
});

export const FilesTableInsertSchema = TableWriteSchema.transform(data => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    tags: data.tags,
    access_count: data.accessCount,
}));

export const FilesTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: (data.metadata ? JSON.stringify(data.metadata) : data.metadata),
    tags: data.tags,
    access_count: data.accessCount,
}));

type TableInsertRecord = z.input<typeof FilesTableInsertSchema>;

/**
* Represents a database record from the "public.files" table.
*/
export interface FileRecord {
    id: TableReadRecord['id'];
    filename: TableReadRecord['filename'];
    filePath: TableReadRecord['filePath'];
    fileSize: TableReadRecord['fileSize'];
    mimeType: TableReadRecord['mimeType'];
    checksum: TableReadRecord['checksum'];
    binaryData: TableReadRecord['binaryData'];
    isEncrypted: TableReadRecord['isEncrypted'];
    uploadTime: TableReadRecord['uploadTime'];
    expiryDate: TableReadRecord['expiryDate'];
    metadata: TableReadRecord['metadata'];
    tags: TableReadRecord['tags'];
    accessCount: TableReadRecord['accessCount'];
}

/**
* Represents an insertable database record from the "public.files" table.
*/
export interface FileInsertRecord {
    /**
    * @default: gen_random_uuid()
    */
    id: TableInsertRecord['id'];
    /**
    * @maxLen: 255
    */
    filename: TableInsertRecord['filename'];
    /**
    */
    filePath: TableInsertRecord['filePath'];
    /**
    */
    fileSize: TableInsertRecord['fileSize'];
    /**
    * @maxLen: 100
    */
    mimeType?: TableInsertRecord['mimeType'];
    /**
    * @maxLen: 64
    */
    checksum?: TableInsertRecord['checksum'];
    /**
    */
    binaryData?: TableInsertRecord['binaryData'];
    /**
    * @default: false
    */
    isEncrypted?: TableInsertRecord['isEncrypted'];
    /**
    * @default: now()
    */
    uploadTime?: TableInsertRecord['uploadTime'];
    /**
    */
    expiryDate?: TableInsertRecord['expiryDate'];
    /**
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    */
    tags?: TableInsertRecord['tags'];
    /**
    * @default: 0
    */
    accessCount?: TableInsertRecord['accessCount'];
}

/**
* Represents an updateable database record from the "public.files" table.
*/
export type FileUpdateRecord = Partial<FileInsertRecord>;
