// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.files" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const FilesTableReadSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string(),
    /**
    * dataType: text
    * defaultValue: 
    */
    file_path: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    file_size: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mime_type: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binary_data: z.string().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    is_encrypted: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    upload_time: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiry_date: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    access_count: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.files" table.
 * This type represents the raw database record without any transformations.
 */
export type FileReadBaseRecord = z.output<typeof FilesTableReadSchema>;

/**
* The read transform function for the "public.files" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformFileReadRecord = (data: FileReadBaseRecord): {
    id: FileReadBaseRecord['id'],
    filename: FileReadBaseRecord['filename'],
    filePath: FileReadBaseRecord['file_path'],
    fileSize: FileReadBaseRecord['file_size'],
    mimeType?: FileReadBaseRecord['mime_type'],
    checksum?: FileReadBaseRecord['checksum'],
    binaryData?: FileReadBaseRecord['binary_data'],
    isEncrypted?: FileReadBaseRecord['is_encrypted'],
    uploadTime?: FileReadBaseRecord['upload_time'],
    expiryDate?: FileReadBaseRecord['expiry_date'],
    metadata?: FileReadBaseRecord['metadata'],
    tags?: FileReadBaseRecord['tags'],
    accessCount?: FileReadBaseRecord['access_count'],
} => ({
    id: data.id,
    filename: data.filename,
    filePath: data.file_path,
    fileSize: data.file_size,
    mimeType: data.mime_type,
    checksum: data.checksum,
    binaryData: data.binary_data,
    isEncrypted: data.is_encrypted,
    uploadTime: data.upload_time,
    expiryDate: data.expiry_date,
    metadata: data.metadata,
    tags: data.tags,
    accessCount: data.access_count,
});

/**
 * The read schema for the "public.files" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const FilesTableSchema = FilesTableReadSchema.transform(transformFileReadRecord);

/**
 * The base write schema for the "public.files" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const FilesTableWriteSchema = z.object({
    /**
    * dataType: uuid
    * defaultValue: gen_random_uuid()
    */
    id: z.string().uuid(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    filename: z.string().max(255),
    /**
    * dataType: text
    * defaultValue: 
    */
    filePath: z.string(),
    /**
    * dataType: int8
    * defaultValue: 
    */
    fileSize: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    mimeType: z.string().max(100).nullish().optional(),
    /**
    * dataType: bpchar
    * defaultValue: 
    */
    checksum: z.string().max(64).nullish().optional(),
    /**
    * dataType: bytea
    * defaultValue: 
    */
    binaryData: z.string().nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    isEncrypted: z.boolean().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    uploadTime: z.date().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    expiryDate: z.date().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    metadata: z.any().nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    tags: z.array(z.string()).nullish().optional(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    accessCount: z.number().int().nullish().optional(),
});

/**
 * The base record type for the "public.files" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type FileInsertBaseRecord = z.output<typeof FilesTableWriteSchema>;

/**
 * The base record type for the "public.files" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type FileUpdateBaseRecord = Partial<FileInsertBaseRecord>;

/**
 * The insert transform function for the "public.files" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformFileInsertRecord = (data: FileInsertBaseRecord): {
    id: FileInsertBaseRecord['id'],
    filename: FileInsertBaseRecord['filename'],
    file_path: FileInsertBaseRecord['filePath'],
    file_size: FileInsertBaseRecord['fileSize'],
    mime_type?: FileInsertBaseRecord['mimeType'],
    checksum?: FileInsertBaseRecord['checksum'],
    binary_data?: FileInsertBaseRecord['binaryData'],
    is_encrypted?: FileInsertBaseRecord['isEncrypted'],
    upload_time?: FileInsertBaseRecord['uploadTime'],
    expiry_date?: FileInsertBaseRecord['expiryDate'],
    metadata?: FileInsertBaseRecord['metadata'],
    tags?: FileInsertBaseRecord['tags'],
    access_count?: FileInsertBaseRecord['accessCount'],
} => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: data.metadata,
    tags: data.tags,
    access_count: data.accessCount,
});

/**
 * The update transform function for the "public.files" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformFileUpdateRecord = (data: FileUpdateBaseRecord): {
    id: FileUpdateBaseRecord['id'],
    filename: FileUpdateBaseRecord['filename'],
    file_path: FileUpdateBaseRecord['filePath'],
    file_size: FileUpdateBaseRecord['fileSize'],
    mime_type?: FileUpdateBaseRecord['mimeType'],
    checksum?: FileUpdateBaseRecord['checksum'],
    binary_data?: FileUpdateBaseRecord['binaryData'],
    is_encrypted?: FileUpdateBaseRecord['isEncrypted'],
    upload_time?: FileUpdateBaseRecord['uploadTime'],
    expiry_date?: FileUpdateBaseRecord['expiryDate'],
    metadata?: FileUpdateBaseRecord['metadata'],
    tags?: FileUpdateBaseRecord['tags'],
    access_count?: FileUpdateBaseRecord['accessCount'],
} => ({
    id: data.id,
    filename: data.filename,
    file_path: data.filePath,
    file_size: data.fileSize,
    mime_type: data.mimeType,
    checksum: data.checksum,
    binary_data: data.binaryData,
    is_encrypted: data.isEncrypted,
    upload_time: data.uploadTime,
    expiry_date: data.expiryDate,
    metadata: data.metadata,
    tags: data.tags,
    access_count: data.accessCount,
});

/**
 * The insert schema for the "public.files" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const FilesTableInsertSchema = FilesTableWriteSchema.transform(transformFileInsertRecord);

/**
 * The update schema for the "public.files" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const FilesTableUpdateSchema = FilesTableWriteSchema.partial().transform(transformFileUpdateRecord);

type TableInsertRecord = z.input<typeof FilesTableInsertSchema>;
type TableReadRecord = z.output<typeof FilesTableSchema>;

/**
* Represents a database record from the "public.files" table.
*/
export interface FileRecord {
    /**
    * Primary key for files table
    */
    id: TableReadRecord['id'];
    /**
    * Original filename
    */
    filename: TableReadRecord['filename'];
    /**
    * Path to the file
    */
    filePath: TableReadRecord['filePath'];
    /**
    * Size of the file in bytes
    */
    fileSize: TableReadRecord['fileSize'];
    /**
    * MIME type of the file
    */
    mimeType?: TableReadRecord['mimeType'];
    /**
    * SHA-256 checksum of the file
    */
    checksum?: TableReadRecord['checksum'];
    /**
    * Binary data of the file
    */
    binaryData?: TableReadRecord['binaryData'];
    /**
    * Whether the file is encrypted
    */
    isEncrypted?: TableReadRecord['isEncrypted'];
    /**
    * Timestamp when file was uploaded
    */
    uploadTime?: TableReadRecord['uploadTime'];
    /**
    * Expiry date of the file
    */
    expiryDate?: TableReadRecord['expiryDate'];
    /**
    * File metadata in JSON format
    */
    metadata?: TableReadRecord['metadata'];
    /**
    * Array of file tags
    */
    tags?: TableReadRecord['tags'];
    /**
    * Number of times file was accessed
    */
    accessCount?: TableReadRecord['accessCount'];
}

/**
* Represents an insertable database record from the "public.files" table.
*/
export interface FileInsertRecord {
    /**
    * Primary key for files table
    * @default: gen_random_uuid()
    */
    id: TableInsertRecord['id'];
    /**
    * Original filename
    * @maxLen: 255
    */
    filename: TableInsertRecord['filename'];
    /**
    * Path to the file
    */
    filePath: TableInsertRecord['filePath'];
    /**
    * Size of the file in bytes
    */
    fileSize: TableInsertRecord['fileSize'];
    /**
    * MIME type of the file
    * @maxLen: 100
    */
    mimeType?: TableInsertRecord['mimeType'];
    /**
    * SHA-256 checksum of the file
    * @maxLen: 64
    */
    checksum?: TableInsertRecord['checksum'];
    /**
    * Binary data of the file
    */
    binaryData?: TableInsertRecord['binaryData'];
    /**
    * Whether the file is encrypted
    * @default: false
    */
    isEncrypted?: TableInsertRecord['isEncrypted'];
    /**
    * Timestamp when file was uploaded
    * @default: now()
    */
    uploadTime?: TableInsertRecord['uploadTime'];
    /**
    * Expiry date of the file
    */
    expiryDate?: TableInsertRecord['expiryDate'];
    /**
    * File metadata in JSON format
    */
    metadata?: TableInsertRecord['metadata'];
    /**
    * Array of file tags
    */
    tags?: TableInsertRecord['tags'];
    /**
    * Number of times file was accessed
    * @default: 0
    */
    accessCount?: TableInsertRecord['accessCount'];
}

/**
* Represents an updateable database record from the "public.files" table.
*/
export type FileUpdateRecord = Partial<FileInsertRecord>;
