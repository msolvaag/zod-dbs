// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.time_series" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const TimeSeriesTableReadSchema = z.object({
    /**
    * dataType: int8
    * defaultValue: nextval('time_series_id_seq'::regclass)
    */
    id: z.number().int(),
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sensor_id: z.string(),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    timestamp: z.date(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    temperature: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    humidity: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    pressure: z.number().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _numeric
    * defaultValue: 
    */
    readings: z.array(z.number()).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    anomaly_detected: z.boolean().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    data_quality: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    created_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.time_series" table.
 * This type represents the raw database record without any transformations.
 */
export type TimeSeriesReadBaseRecord = z.output<typeof TimeSeriesTableReadSchema>;

/**
* The read transform function for the "public.time_series" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformTimeSeriesReadRecord = (data: TimeSeriesReadBaseRecord): {
    id: TimeSeriesReadBaseRecord['id'],
    sensorId: TimeSeriesReadBaseRecord['sensor_id'],
    timestamp: TimeSeriesReadBaseRecord['timestamp'],
    temperature?: TimeSeriesReadBaseRecord['temperature'],
    humidity?: TimeSeriesReadBaseRecord['humidity'],
    pressure?: TimeSeriesReadBaseRecord['pressure'],
    readings?: TimeSeriesReadBaseRecord['readings'],
    anomalyDetected?: TimeSeriesReadBaseRecord['anomaly_detected'],
    dataQuality?: TimeSeriesReadBaseRecord['data_quality'],
    createdAt?: TimeSeriesReadBaseRecord['created_at'],
} => ({
    id: data.id,
    sensorId: data.sensor_id,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomalyDetected: data.anomaly_detected,
    dataQuality: data.data_quality,
    createdAt: data.created_at,
});

/**
 * The read schema for the "public.time_series" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const TimeSeriesTableSchema = TimeSeriesTableReadSchema.transform(transformTimeSeriesReadRecord);

/**
 * The base write schema for the "public.time_series" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const TimeSeriesTableWriteSchema = z.object({
    /**
    * dataType: varchar
    * defaultValue: 
    */
    sensorId: z.string().max(50),
    /**
    * dataType: timestamptz
    * defaultValue: 
    */
    timestamp: z.date(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    temperature: z.number().max(327682).nullish().optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    humidity: z.number().max(327682).nullish().optional(),
    /**
    * dataType: numeric
    * defaultValue: 
    */
    pressure: z.number().max(458754).nullish().optional(),
    /**
    * dataType: _numeric
    * defaultValue: 
    */
    readings: z.array(z.number()).nullish().optional(),
    /**
    * dataType: bool
    * defaultValue: false
    */
    anomalyDetected: z.boolean().nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 
    */
    dataQuality: z.number().int().nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    createdAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.time_series" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type TimeSeriesInsertBaseRecord = z.output<typeof TimeSeriesTableWriteSchema>;

/**
 * The base record type for the "public.time_series" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type TimeSeriesUpdateBaseRecord = Partial<TimeSeriesInsertBaseRecord>;

/**
 * The insert transform function for the "public.time_series" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformTimeSeriesInsertRecord = (data: TimeSeriesInsertBaseRecord): {
    sensor_id: TimeSeriesInsertBaseRecord['sensorId'],
    timestamp: TimeSeriesInsertBaseRecord['timestamp'],
    temperature?: TimeSeriesInsertBaseRecord['temperature'],
    humidity?: TimeSeriesInsertBaseRecord['humidity'],
    pressure?: TimeSeriesInsertBaseRecord['pressure'],
    readings?: TimeSeriesInsertBaseRecord['readings'],
    anomaly_detected?: TimeSeriesInsertBaseRecord['anomalyDetected'],
    data_quality?: TimeSeriesInsertBaseRecord['dataQuality'],
    created_at?: TimeSeriesInsertBaseRecord['createdAt'],
} => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
});

/**
 * The update transform function for the "public.time_series" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformTimeSeriesUpdateRecord = (data: TimeSeriesUpdateBaseRecord): {
    sensor_id: TimeSeriesUpdateBaseRecord['sensorId'],
    timestamp: TimeSeriesUpdateBaseRecord['timestamp'],
    temperature?: TimeSeriesUpdateBaseRecord['temperature'],
    humidity?: TimeSeriesUpdateBaseRecord['humidity'],
    pressure?: TimeSeriesUpdateBaseRecord['pressure'],
    readings?: TimeSeriesUpdateBaseRecord['readings'],
    anomaly_detected?: TimeSeriesUpdateBaseRecord['anomalyDetected'],
    data_quality?: TimeSeriesUpdateBaseRecord['dataQuality'],
    created_at?: TimeSeriesUpdateBaseRecord['createdAt'],
} => ({
    sensor_id: data.sensorId,
    timestamp: data.timestamp,
    temperature: data.temperature,
    humidity: data.humidity,
    pressure: data.pressure,
    readings: data.readings,
    anomaly_detected: data.anomalyDetected,
    data_quality: data.dataQuality,
    created_at: data.createdAt,
});

/**
 * The insert schema for the "public.time_series" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const TimeSeriesTableInsertSchema = TimeSeriesTableWriteSchema.transform(transformTimeSeriesInsertRecord);

/**
 * The update schema for the "public.time_series" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const TimeSeriesTableUpdateSchema = TimeSeriesTableWriteSchema.partial().transform(transformTimeSeriesUpdateRecord);

type TableInsertRecord = z.input<typeof TimeSeriesTableInsertSchema>;
type TableReadRecord = z.output<typeof TimeSeriesTableSchema>;

/**
* Represents a database record from the "public.time_series" table.
*/
export interface TimeSeriesRecord {
    /**
    * Primary key for time series table
    */
    id: TableReadRecord['id'];
    /**
    * Identifier of the sensor
    */
    sensorId: TableReadRecord['sensorId'];
    /**
    * Timestamp of the reading
    */
    timestamp: TableReadRecord['timestamp'];
    /**
    * Temperature reading
    */
    temperature?: TableReadRecord['temperature'];
    /**
    * Humidity reading
    */
    humidity?: TableReadRecord['humidity'];
    /**
    * Pressure reading
    */
    pressure?: TableReadRecord['pressure'];
    /**
    * Array of numeric readings
    */
    readings?: TableReadRecord['readings'];
    /**
    * Whether an anomaly was detected
    */
    anomalyDetected?: TableReadRecord['anomalyDetected'];
    /**
    * Data quality score (1-10)
    */
    dataQuality?: TableReadRecord['dataQuality'];
    /**
    * Timestamp when record was created
    */
    createdAt?: TableReadRecord['createdAt'];
}

/**
* Represents an insertable database record from the "public.time_series" table.
*/
export interface TimeSeriesInsertRecord {
    /**
    * Identifier of the sensor
    * @maxLen: 50
    */
    sensorId: TableInsertRecord['sensorId'];
    /**
    * Timestamp of the reading
    */
    timestamp: TableInsertRecord['timestamp'];
    /**
    * Temperature reading
    * @maxLen: 327682
    */
    temperature?: TableInsertRecord['temperature'];
    /**
    * Humidity reading
    * @maxLen: 327682
    */
    humidity?: TableInsertRecord['humidity'];
    /**
    * Pressure reading
    * @maxLen: 458754
    */
    pressure?: TableInsertRecord['pressure'];
    /**
    * Array of numeric readings
    */
    readings?: TableInsertRecord['readings'];
    /**
    * Whether an anomaly was detected
    * @default: false
    */
    anomalyDetected?: TableInsertRecord['anomalyDetected'];
    /**
    * Data quality score (1-10)
    */
    dataQuality?: TableInsertRecord['dataQuality'];
    /**
    * Timestamp when record was created
    * @default: now()
    */
    createdAt?: TableInsertRecord['createdAt'];
}

/**
* Represents an updateable database record from the "public.time_series" table.
*/
export type TimeSeriesUpdateRecord = Partial<TimeSeriesInsertRecord>;
