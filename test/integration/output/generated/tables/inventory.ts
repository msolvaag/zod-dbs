// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';

export const InventoryTableSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    product_id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stock_quantity: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reserved_quantity: z.number().int().nullable(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorder_level: z.number().int().nullable(),
    /**
    * dataType: date
    * defaultValue: 
    */
    last_restocked: z.date().nullable(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplier_info: z.any().nullable(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouse_locations: z.array(z.string()).nullable(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullable(),
}).transform(data => ({
    productId: data.product_id,
    stockQuantity: data.stock_quantity,
    reservedQuantity: data.reserved_quantity ?? undefined,
    reorderLevel: data.reorder_level ?? undefined,
    lastRestocked: data.last_restocked ?? undefined,
    supplierInfo: data.supplier_info ?? undefined,
    warehouseLocations: data.warehouse_locations ?? undefined,
    updatedAt: data.updated_at ?? undefined,
}));

type TableReadRecord = z.output<typeof InventoryTableSchema>;

const TableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    productId: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stockQuantity: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reservedQuantity: z.number().int().nullish(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorderLevel: z.number().int().nullish(),
    /**
    * dataType: date
    * defaultValue: 
    */
    lastRestocked: z.date().nullish(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplierInfo: z.any().nullish(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouseLocations: z.array(z.string()).nullish(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish(),
});

export const InventoryTableInsertSchema = TableWriteSchema.transform(data => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: (data.supplierInfo ? JSON.stringify(data.supplierInfo) : data.supplierInfo),
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
}));

export const InventoryTableUpdateSchema = TableWriteSchema.partial().transform(data => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: (data.supplierInfo ? JSON.stringify(data.supplierInfo) : data.supplierInfo),
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
}));

type TableInsertRecord = z.input<typeof InventoryTableInsertSchema>;

/**
* Represents a database record from the "public.inventory" table.
*/
export interface InventoryRecord {
    /**
     * ID of the product
     */
    productId: TableReadRecord['productId'];
    /**
     * Current stock quantity
     */
    stockQuantity: TableReadRecord['stockQuantity'];
    /**
     * Quantity reserved for orders
     */
    reservedQuantity: TableReadRecord['reservedQuantity'];
    /**
     * Minimum stock level before reorder
     */
    reorderLevel: TableReadRecord['reorderLevel'];
    /**
     * Date when last restocked
     */
    lastRestocked: TableReadRecord['lastRestocked'];
    /**
     * Supplier information in JSON format
     */
    supplierInfo: TableReadRecord['supplierInfo'];
    /**
     * Array of warehouse locations
     */
    warehouseLocations: TableReadRecord['warehouseLocations'];
    /**
     * Timestamp when inventory was last updated
     */
    updatedAt: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.inventory" table.
*/
export interface InventoryInsertRecord {
    /**
    * ID of the product
    */
    productId: TableInsertRecord['productId'];
    /**
    * Current stock quantity
    * @default: 0
    */
    stockQuantity: TableInsertRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    * @default: 0
    */
    reservedQuantity?: TableInsertRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    * @default: 10
    */
    reorderLevel?: TableInsertRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableInsertRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableInsertRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableInsertRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.inventory" table.
*/
export type InventoryUpdateRecord = Partial<InventoryInsertRecord>;
