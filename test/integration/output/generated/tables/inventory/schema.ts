// This file is auto-generated by zod-pg. Do not edit this file directly.

import { z } from 'zod';


/**
 * The base read schema for the "public.inventory" table.
 * This schema is used to validate the data read from the database without any transformations.
 */
export const InventoryTableReadSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    product_id: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stock_quantity: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reserved_quantity: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorder_level: z.number().int().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    last_restocked: z.date().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplier_info: z.any().nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouse_locations: z.array(z.string()).nullish().transform((value) => value ?? undefined).optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updated_at: z.date().nullish().transform((value) => value ?? undefined).optional(),
});

/**
 * The base record type for the "public.inventory" table.
 * This type represents the raw database record without any transformations.
 */
export type InventoryReadBaseRecord = z.output<typeof InventoryTableReadSchema>;

/**
* The read transform function for the "public.inventory" table.
* Maps the raw database fields to expected property names. e.g snake_case to camelCase.
*/
export const transformInventoryReadRecord = (data: InventoryReadBaseRecord): {
    productId: InventoryReadBaseRecord['product_id'],
    stockQuantity: InventoryReadBaseRecord['stock_quantity'],
    reservedQuantity?: InventoryReadBaseRecord['reserved_quantity'],
    reorderLevel?: InventoryReadBaseRecord['reorder_level'],
    lastRestocked?: InventoryReadBaseRecord['last_restocked'],
    supplierInfo?: InventoryReadBaseRecord['supplier_info'],
    warehouseLocations?: InventoryReadBaseRecord['warehouse_locations'],
    updatedAt?: InventoryReadBaseRecord['updated_at'],
} => ({
    productId: data.product_id,
    stockQuantity: data.stock_quantity,
    reservedQuantity: data.reserved_quantity,
    reorderLevel: data.reorder_level,
    lastRestocked: data.last_restocked,
    supplierInfo: data.supplier_info,
    warehouseLocations: data.warehouse_locations,
    updatedAt: data.updated_at,
});

/**
 * The read schema for the "public.inventory" table.
 * This schema is used to validate the data read from the database with transformations.
 */
export const InventoryTableSchema = InventoryTableReadSchema.transform(transformInventoryReadRecord);

/**
 * The base write schema for the "public.inventory" table.
 * This schema is used to validate the data before writing to the database without any transformations.
 */
export const InventoryTableWriteSchema = z.object({
    /**
    * dataType: int4
    * defaultValue: 
    */
    productId: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    stockQuantity: z.number().int(),
    /**
    * dataType: int4
    * defaultValue: 0
    */
    reservedQuantity: z.number().int().nullish().optional(),
    /**
    * dataType: int2
    * defaultValue: 10
    */
    reorderLevel: z.number().int().nullish().optional(),
    /**
    * dataType: date
    * defaultValue: 
    */
    lastRestocked: z.date().nullish().optional(),
    /**
    * dataType: jsonb
    * defaultValue: 
    */
    supplierInfo: z.any().nullish().transform((value) => value ? JSON.stringify(value) : value).optional(),
    /**
    * dataType: _text
    * defaultValue: 
    */
    warehouseLocations: z.array(z.string()).nullish().optional(),
    /**
    * dataType: timestamptz
    * defaultValue: now()
    */
    updatedAt: z.date().nullish().optional(),
});

/**
 * The base record type for the "public.inventory" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type InventoryInsertBaseRecord = z.output<typeof InventoryTableWriteSchema>;

/**
 * The base record type for the "public.inventory" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type InventoryUpdateBaseRecord = Partial<InventoryInsertBaseRecord>;

/**
 * The insert transform function for the "public.inventory" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformInventoryInsertRecord = (data: InventoryInsertBaseRecord): {
    product_id: InventoryInsertBaseRecord['productId'],
    stock_quantity: InventoryInsertBaseRecord['stockQuantity'],
    reserved_quantity?: InventoryInsertBaseRecord['reservedQuantity'],
    reorder_level?: InventoryInsertBaseRecord['reorderLevel'],
    last_restocked?: InventoryInsertBaseRecord['lastRestocked'],
    supplier_info?: InventoryInsertBaseRecord['supplierInfo'],
    warehouse_locations?: InventoryInsertBaseRecord['warehouseLocations'],
    updated_at?: InventoryInsertBaseRecord['updatedAt'],
} => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: data.supplierInfo,
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
});

/**
 * The update transform function for the "public.inventory" table.
 * Maps the expected property names to raw database fields. e.g camelCase to snake_case.
 */
export const transformInventoryUpdateRecord = (data: InventoryUpdateBaseRecord): {
    product_id: InventoryUpdateBaseRecord['productId'],
    stock_quantity: InventoryUpdateBaseRecord['stockQuantity'],
    reserved_quantity?: InventoryUpdateBaseRecord['reservedQuantity'],
    reorder_level?: InventoryUpdateBaseRecord['reorderLevel'],
    last_restocked?: InventoryUpdateBaseRecord['lastRestocked'],
    supplier_info?: InventoryUpdateBaseRecord['supplierInfo'],
    warehouse_locations?: InventoryUpdateBaseRecord['warehouseLocations'],
    updated_at?: InventoryUpdateBaseRecord['updatedAt'],
} => ({
    product_id: data.productId,
    stock_quantity: data.stockQuantity,
    reserved_quantity: data.reservedQuantity,
    reorder_level: data.reorderLevel,
    last_restocked: data.lastRestocked,
    supplier_info: data.supplierInfo,
    warehouse_locations: data.warehouseLocations,
    updated_at: data.updatedAt,
});

/**
 * The insert schema for the "public.inventory" table.
 * This schema is used to validate and transform a record before inserting into the database.
 */
export const InventoryTableInsertSchema = InventoryTableWriteSchema.transform(transformInventoryInsertRecord);

/**
 * The update schema for the "public.inventory" table.
 * This schema is used to validate and transform a record before updating the database.
 */
export const InventoryTableUpdateSchema = InventoryTableWriteSchema.partial().transform(transformInventoryUpdateRecord);

type TableInsertRecord = z.input<typeof InventoryTableInsertSchema>;
type TableReadRecord = z.output<typeof InventoryTableSchema>;

/**
* Represents a database record from the "public.inventory" table.
*/
export interface InventoryRecord {
    /**
    * ID of the product
    */
    productId: TableReadRecord['productId'];
    /**
    * Current stock quantity
    */
    stockQuantity: TableReadRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    */
    reservedQuantity?: TableReadRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    */
    reorderLevel?: TableReadRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableReadRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableReadRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableReadRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    */
    updatedAt?: TableReadRecord['updatedAt'];
}

/**
* Represents an insertable database record from the "public.inventory" table.
*/
export interface InventoryInsertRecord {
    /**
    * ID of the product
    */
    productId: TableInsertRecord['productId'];
    /**
    * Current stock quantity
    * @default: 0
    */
    stockQuantity: TableInsertRecord['stockQuantity'];
    /**
    * Quantity reserved for orders
    * @default: 0
    */
    reservedQuantity?: TableInsertRecord['reservedQuantity'];
    /**
    * Minimum stock level before reorder
    * @default: 10
    */
    reorderLevel?: TableInsertRecord['reorderLevel'];
    /**
    * Date when last restocked
    */
    lastRestocked?: TableInsertRecord['lastRestocked'];
    /**
    * Supplier information in JSON format
    */
    supplierInfo?: TableInsertRecord['supplierInfo'];
    /**
    * Array of warehouse locations
    */
    warehouseLocations?: TableInsertRecord['warehouseLocations'];
    /**
    * Timestamp when inventory was last updated
    * @default: now()
    */
    updatedAt?: TableInsertRecord['updatedAt'];
}

/**
* Represents an updateable database record from the "public.inventory" table.
*/
export type InventoryUpdateRecord = Partial<InventoryInsertRecord>;
